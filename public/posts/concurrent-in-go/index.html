<!DOCTYPE html>
<html lang="zh-cn">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<meta name="theme-color" content="#20293a">
	<meta name="msapplication-TileColor" content="#20293a">
<meta itemprop="name" content="go并发的几个问题">
<meta itemprop="description" content="前言 作为世界上除了PHP之外最好的语言golang，只需go关键字修饰函数，就可以直接启动一个goroutine(协程)运行，但在实际的场景中，我们需要考虑到协程的数量，其之间的同步与通信，以及精确控制其结束。
如何控制协程的通信 引入全局变量 这是最简单也是最容易想到的方法：虽然goroutine的退出只能由其自身的决定，不允许从外部直接控制，不过我们可以通过引入全局变量，所有的goroutine都共享这个变量，并且不断寻查其是否更新，在主程序中对其更改，goroutine勘测到其变化后做出反应。
package main import ( &#34;fmt&#34; &#34;time&#34; ) var running bool func run() { for running { fmt.Println(&#34;running&#34;) time.Sleep(500*time.Millisecond) } fmt.Println(&#34;stop now&#34;) } func main(){ running=true go run() go run() time.Sleep(time.Second) running=false time.Sleep(time.Second) } /* out: running running running running stop now stop now */ 这种写法看似很简单，但是还是有好几个问题：
 全局变量存在数据同步问题，如果有多个写入需要加锁处理。 协程之间的通信量很小，只有事先定义的全局变量，并且只能单向从主程序通知给协程。  利用channel通信 相信写go的兄弟，一定对这一句话不陌生：
 Go语言的并发模型是CSP（Communicating Sequential Processes）通信顺序进程，提倡通过通信共享内存而不是通过共享内存而实现通信。
 这里简单谈谈我的理解:
共享内存是什么?如果在一个系统中，不同进程或者线程共享一块内存，那么他们之间不需要进行平凡的交互，如果有大量的数据传输，也省去了数据拷贝的消耗。
但是这有一个很大的问题，就是多线程下，共享一块内存，肯定会存在数据冲突。为了对抗这种冲突，人们发明了很多机制，比如加锁，信号量，各种调度算法等等，但是这毫无都会对并发的性能造成影响。(但并不是说全部都不行，比如深度 | 字节跳动微服务架构体系演进）
最终“通过通信来实现进程/线程间交互”的方案脱颖而出,go就在语言层提供了channel来实现这一方案，简单理解就是设计的时候，对于消息队列，只提供读写接口，而对于内部的实现你完全不用去在意，看起来消息队列就像是共享内存一样了。然而你的消息队列可以利用socket进行通信。
通过看channel的源码，可以看出它其实就是一个队列加一个轻量锁
type hchan struct { qcount uint // total data in the queue  dataqsiz uint // size of the circular queue  buf unsafe."><meta itemprop="datePublished" content="2021-12-02T23:30:20+08:00" />
<meta itemprop="dateModified" content="2021-12-02T23:30:20+08:00" />
<meta itemprop="wordCount" content="591">
<meta itemprop="keywords" content="" /><meta property="og:title" content="go并发的几个问题" />
<meta property="og:description" content="前言 作为世界上除了PHP之外最好的语言golang，只需go关键字修饰函数，就可以直接启动一个goroutine(协程)运行，但在实际的场景中，我们需要考虑到协程的数量，其之间的同步与通信，以及精确控制其结束。
如何控制协程的通信 引入全局变量 这是最简单也是最容易想到的方法：虽然goroutine的退出只能由其自身的决定，不允许从外部直接控制，不过我们可以通过引入全局变量，所有的goroutine都共享这个变量，并且不断寻查其是否更新，在主程序中对其更改，goroutine勘测到其变化后做出反应。
package main import ( &#34;fmt&#34; &#34;time&#34; ) var running bool func run() { for running { fmt.Println(&#34;running&#34;) time.Sleep(500*time.Millisecond) } fmt.Println(&#34;stop now&#34;) } func main(){ running=true go run() go run() time.Sleep(time.Second) running=false time.Sleep(time.Second) } /* out: running running running running stop now stop now */ 这种写法看似很简单，但是还是有好几个问题：
 全局变量存在数据同步问题，如果有多个写入需要加锁处理。 协程之间的通信量很小，只有事先定义的全局变量，并且只能单向从主程序通知给协程。  利用channel通信 相信写go的兄弟，一定对这一句话不陌生：
 Go语言的并发模型是CSP（Communicating Sequential Processes）通信顺序进程，提倡通过通信共享内存而不是通过共享内存而实现通信。
 这里简单谈谈我的理解:
共享内存是什么?如果在一个系统中，不同进程或者线程共享一块内存，那么他们之间不需要进行平凡的交互，如果有大量的数据传输，也省去了数据拷贝的消耗。
但是这有一个很大的问题，就是多线程下，共享一块内存，肯定会存在数据冲突。为了对抗这种冲突，人们发明了很多机制，比如加锁，信号量，各种调度算法等等，但是这毫无都会对并发的性能造成影响。(但并不是说全部都不行，比如深度 | 字节跳动微服务架构体系演进）
最终“通过通信来实现进程/线程间交互”的方案脱颖而出,go就在语言层提供了channel来实现这一方案，简单理解就是设计的时候，对于消息队列，只提供读写接口，而对于内部的实现你完全不用去在意，看起来消息队列就像是共享内存一样了。然而你的消息队列可以利用socket进行通信。
通过看channel的源码，可以看出它其实就是一个队列加一个轻量锁
type hchan struct { qcount uint // total data in the queue  dataqsiz uint // size of the circular queue  buf unsafe." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://theoyu.top/posts/concurrent-in-go/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-12-02T23:30:20+08:00" />
<meta property="article:modified_time" content="2021-12-02T23:30:20+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="go并发的几个问题"/>
<meta name="twitter:description" content="前言 作为世界上除了PHP之外最好的语言golang，只需go关键字修饰函数，就可以直接启动一个goroutine(协程)运行，但在实际的场景中，我们需要考虑到协程的数量，其之间的同步与通信，以及精确控制其结束。
如何控制协程的通信 引入全局变量 这是最简单也是最容易想到的方法：虽然goroutine的退出只能由其自身的决定，不允许从外部直接控制，不过我们可以通过引入全局变量，所有的goroutine都共享这个变量，并且不断寻查其是否更新，在主程序中对其更改，goroutine勘测到其变化后做出反应。
package main import ( &#34;fmt&#34; &#34;time&#34; ) var running bool func run() { for running { fmt.Println(&#34;running&#34;) time.Sleep(500*time.Millisecond) } fmt.Println(&#34;stop now&#34;) } func main(){ running=true go run() go run() time.Sleep(time.Second) running=false time.Sleep(time.Second) } /* out: running running running running stop now stop now */ 这种写法看似很简单，但是还是有好几个问题：
 全局变量存在数据同步问题，如果有多个写入需要加锁处理。 协程之间的通信量很小，只有事先定义的全局变量，并且只能单向从主程序通知给协程。  利用channel通信 相信写go的兄弟，一定对这一句话不陌生：
 Go语言的并发模型是CSP（Communicating Sequential Processes）通信顺序进程，提倡通过通信共享内存而不是通过共享内存而实现通信。
 这里简单谈谈我的理解:
共享内存是什么?如果在一个系统中，不同进程或者线程共享一块内存，那么他们之间不需要进行平凡的交互，如果有大量的数据传输，也省去了数据拷贝的消耗。
但是这有一个很大的问题，就是多线程下，共享一块内存，肯定会存在数据冲突。为了对抗这种冲突，人们发明了很多机制，比如加锁，信号量，各种调度算法等等，但是这毫无都会对并发的性能造成影响。(但并不是说全部都不行，比如深度 | 字节跳动微服务架构体系演进）
最终“通过通信来实现进程/线程间交互”的方案脱颖而出,go就在语言层提供了channel来实现这一方案，简单理解就是设计的时候，对于消息队列，只提供读写接口，而对于内部的实现你完全不用去在意，看起来消息队列就像是共享内存一样了。然而你的消息队列可以利用socket进行通信。
通过看channel的源码，可以看出它其实就是一个队列加一个轻量锁
type hchan struct { qcount uint // total data in the queue  dataqsiz uint // size of the circular queue  buf unsafe."/>

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="/favicon.ico">

	<title>go并发的几个问题</title>
	<link rel="stylesheet" href="https://theoyu.top/css/style.min.948bbb56de2e03535e20f1dcdeada9d463fac9cb3e67a99667928e9208ec6fa8.css" integrity="sha256-lIu7Vt4uA1NeIPHc3q2p1GP6ycs+Z6mWZ5KOkgjsb6g=" crossorigin="anonymous">
	
</head>

<body id="page">
	
	<header id="site-header" class="animated slideInUp">
		<div class="hdr-wrapper section-inner">
			<div class="hdr-left">
				<div class="site-branding">
					<a href="https://theoyu.top/">Theoyu&#39;s Blog</a>
				</div>
				<nav class="site-nav hide-in-mobile">
					
				<a href="https://theoyu.top/posts/">Posts</a>
				<a href="https://theoyu.top/about-me/">About</a>

				</nav>
			</div>
			<div class="hdr-right hdr-icons">
				<button id="toc-btn" class="hdr-btn desktop-only-ib" title=""><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-list"><line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3" y2="6"></line><line x1="3" y1="12" x2="3" y2="12"></line><line x1="3" y1="18" x2="3" y2="18"></line></svg></button><span class="hdr-social hide-in-mobile"><a href="mailto:zeyu.ou@foxmail.com" target="_blank" rel="noopener me" title="Email"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline></svg></a><a href="https://instagram.com/" target="_blank" rel="noopener me" title="Instagram"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="2" width="20" height="20" rx="5" ry="5"></rect><path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"></path><line x1="17.5" y1="6.5" x2="17.5" y2="6.5"></line></svg></a><a href="https://github.com/yuuuuu422" target="_blank" rel="noopener me" title="Github"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a></span><button id="menu-btn" class="hdr-btn" title=""><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button>
			</div>
		</div>
	</header>
	<div id="mobile-menu" class="animated fast">
		<ul>
			<li><a href="https://theoyu.top/posts/">Posts</a></li>
			<li><a href="https://theoyu.top/about-me/">About</a></li>
		</ul>
	</div>


	<main class="site-main section-inner animated fadeIn faster">
		<article class="thin">
			<header class="post-header">
				<div class="post-meta"><span>Dec 2, 2021</span></div>
				<h1>go并发的几个问题</h1>
			</header>
			<div class="content">
				<h2 id="前言">前言<a href="#前言" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>作为世界上除了PHP之外最好的语言golang，只需<code>go</code>关键字修饰函数，就可以直接启动一个goroutine(协程)运行，但在实际的场景中，我们需要考虑到协程的数量，其之间的同步与通信，以及精确控制其结束。</p>
<h2 id="如何控制协程的通信">如何控制协程的通信<a href="#如何控制协程的通信" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<h3 id="引入全局变量">引入全局变量<a href="#引入全局变量" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>这是最简单也是最容易想到的方法：虽然goroutine的退出只能由其自身的决定，不允许从外部直接控制，不过我们可以通过引入全局变量，所有的goroutine都共享这个变量，并且不断寻查其是否更新，在主程序中对其更改，goroutine勘测到其变化后做出反应。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>
<span class="kd">var</span> <span class="nx">running</span> <span class="kt">bool</span>
<span class="kd">func</span> <span class="nf">run</span><span class="p">()</span>  <span class="p">{</span>
	<span class="k">for</span> <span class="nx">running</span>  <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;running&#34;</span><span class="p">)</span>
		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">500</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;stop now&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">(){</span>
	<span class="nx">running</span><span class="p">=</span><span class="kc">true</span>
	<span class="k">go</span> <span class="nf">run</span><span class="p">()</span>
	<span class="k">go</span> <span class="nf">run</span><span class="p">()</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
	<span class="nx">running</span><span class="p">=</span><span class="kc">false</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="p">}</span>

<span class="cm">/*
</span><span class="cm">out:
</span><span class="cm">running
</span><span class="cm">running
</span><span class="cm">running
</span><span class="cm">running
</span><span class="cm">stop now
</span><span class="cm">stop now
</span><span class="cm">*/</span>
</code></pre></div><p>这种写法看似很简单，但是还是有好几个问题：</p>
<ol>
<li>全局变量存在数据同步问题，如果有多个写入需要加锁处理。</li>
<li>协程之间的通信量很小，只有事先定义的全局变量，并且只能单向从主程序通知给协程。</li>
</ol>
<h3 id="利用channel通信">利用channel通信<a href="#利用channel通信" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>相信写go的兄弟，一定对这一句话不陌生：</p>
<blockquote>
<p>Go语言的并发模型是CSP（Communicating Sequential Processes）通信顺序进程，提倡通过通信共享内存而不是通过共享内存而实现通信。</p>
</blockquote>
<p>这里简单谈谈我的理解:</p>
<p>共享内存是什么?如果在一个系统中，不同进程或者线程共享一块内存，那么他们之间不需要进行平凡的交互，如果有大量的数据传输，也省去了数据拷贝的消耗。</p>
<p>但是这有一个很大的问题，就是多线程下，共享一块内存，肯定会存在数据冲突。为了对抗这种冲突，人们发明了很多机制，比如加锁，信号量，各种调度算法等等，但是这毫无都会对并发的性能造成影响。(但并不是说全部都不行，比如<a href="https://zhuanlan.zhihu.com/p/382833278">深度 | 字节跳动微服务架构体系演进</a>）</p>
<p>最终“通过通信来实现进程/线程间交互”的方案脱颖而出,go就在语言层提供了channel来实现这一方案，简单理解就是设计的时候，对于消息队列，只提供读写接口，而对于内部的实现你完全不用去在意，看起来消息队列就像是共享内存一样了。然而你的消息队列可以利用socket进行通信。</p>
<p>通过看channel的源码，可以看出它其实就是一个队列加一个轻量锁</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">hchan</span> <span class="kd">struct</span> <span class="p">{</span>
   <span class="nx">qcount</span>   <span class="kt">uint</span>           <span class="c1">// total data in the queue
</span><span class="c1"></span>   <span class="nx">dataqsiz</span> <span class="kt">uint</span>           <span class="c1">// size of the circular queue
</span><span class="c1"></span>   <span class="nx">buf</span>      <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// points to an array of dataqsiz elements
</span><span class="c1"></span>   <span class="nx">elemsize</span> <span class="kt">uint16</span>
   <span class="nx">closed</span>   <span class="kt">uint32</span>
   <span class="nx">elemtype</span> <span class="o">*</span><span class="nx">_type</span> <span class="c1">// element type
</span><span class="c1"></span>   <span class="nx">sendx</span>    <span class="kt">uint</span>   <span class="c1">// send index
</span><span class="c1"></span>   <span class="nx">recvx</span>    <span class="kt">uint</span>   <span class="c1">// receive index
</span><span class="c1"></span>   <span class="nx">recvq</span>    <span class="nx">waitq</span>  <span class="c1">// list of recv waiters
</span><span class="c1"></span>   <span class="nx">sendq</span>    <span class="nx">waitq</span>  <span class="c1">// list of send waiters
</span><span class="c1"></span>
   <span class="c1">// lock protects all fields in hchan, as well as several
</span><span class="c1"></span>   <span class="c1">// fields in sudogs blocked on this channel.
</span><span class="c1"></span>   <span class="c1">//
</span><span class="c1"></span>   <span class="c1">// Do not change another G&#39;s status while holding this lock
</span><span class="c1"></span>   <span class="c1">// (in particular, do not ready a G), as this can deadlock
</span><span class="c1"></span>   <span class="c1">// with stack shrinking.
</span><span class="c1"></span>   <span class="nx">lock</span> <span class="nx">mutex</span>
<span class="p">}</span>
</code></pre></div><p>再谈谈select机制，可以理解为select, poll, epoll 相似的功能：监听多个描述符的读/写等事件，属于基于事件的并发处理(欸好像和之前看csapp第12章的知识连起来了)，简单来说就是监听多个channel，每一个case都是一个事件，按照先后(如果相同则随机)执行，如果没监听的事件暂时堵塞则会执行default。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
   <span class="s">&#34;fmt&#34;</span>
   <span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="nx">output1</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
   <span class="k">go</span> <span class="nf">write</span><span class="p">(</span><span class="nx">output1</span><span class="p">)</span>
   <span class="k">for</span> <span class="nx">s</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">output1</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;res:&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
      <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">write</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">for</span> <span class="p">{</span>
      <span class="k">select</span> <span class="p">{</span>
      <span class="k">case</span> <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="s">&#34;hello&#34;</span><span class="p">:</span>
         <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;write hello&#34;</span><span class="p">)</span>
      <span class="k">default</span><span class="p">:</span>
         <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;channel full&#34;</span><span class="p">)</span>
      <span class="p">}</span>
      <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span> <span class="o">*</span> <span class="mi">500</span><span class="p">)</span>
   <span class="p">}</span>
<span class="p">}</span>
<span class="cm">/*
</span><span class="cm">write hello
</span><span class="cm">res: hello
</span><span class="cm">write hello
</span><span class="cm">write hello
</span><span class="cm">write hello
</span><span class="cm">res: hello
</span><span class="cm">write hello
</span><span class="cm">write hello
</span><span class="cm">write hello
</span><span class="cm">channel full
</span><span class="cm">......
</span><span class="cm">*/</span>
</code></pre></div><h2 id="控制并发量">控制并发量<a href="#控制并发量" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>准备写这里的时候，在知乎上看到一个老哥说可以通过<code>runtime.GOMAXPROCS(n)</code>直接修改最大线程数&hellip;</p>
<p>这是对并发和并行没有弄清楚</p>
<pre><code>多线程程序在一个核的cpu上运行，就是并发。
多线程程序在多个核的cpu上运行，就是并行。
</code></pre><p>当一个函数创建为goroutine时，编译器会将其视为一个独立的工作单元。这个单元会被调度到<strong>可用的逻辑处理器</strong>（可用的核数）上执行。线程是和逻辑处理器绑定的。而<code>runtime.GOMAXPROCS(n)</code>就是分配n个逻辑处理器。但我们这里谈并发，还是在一个偏<del>微观</del>的层面，可以说这个回答是毫无相关了。</p>
<p>我们首先看看过高的并发会导致什么问题：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;math&#34;</span>
	<span class="s">&#34;sync&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">math</span><span class="p">.</span><span class="nx">MaxInt32</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
			<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
		<span class="p">}(</span><span class="nx">i</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><pre><code>panic: too many concurrent operations on a single file or socket (max 1048575)

goroutine 1127972 [running]:
internal/poll.(*fdMutex).rwlock(0xc000110280, 0x113500, 0x7600000001)
        D:/go/src/internal/poll/fd_mutex.go:147 +0x146
internal/poll.(*FD).writeLock(...)
        D:/go/src/internal/poll/fd_mutex.go:239
internal/poll.(*FD).Write(0xc000110280, 0xc17470e5f0, 0x8, 0x8, 0x0, 0x0, 0x0)
</code></pre><p>报错是由<code>fmt.println</code>引起的，对单个 file/socket 的并发操作个数超过了系统上限，那如果我们把<code>fmt.println</code>换成并发安全的<code>log.println</code>呢？</p>
<p>运行后，goland直接退出，chrome浏览器也闪退。每个协程至少需要消耗 2KB 的空间，在骤减的内存空间下，程序运行很容易崩溃，总而言之就是并发的控制不当导致系统的资源被耗尽了。</p>
<p>不同的应用程序对资源的需求是不同的，比如如果是并发对本地资源的操作，那么应该需要考虑系统资源的承受能力；如果是对外端口扫描、密码破解，那还需要考虑会不会触发风控警告等等。总之，并发的上限应该由程序主动控制。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
   <span class="s">&#34;log&#34;</span>
   <span class="s">&#34;sync&#34;</span>
   <span class="s">&#34;time&#34;</span>
<span class="p">)</span>
<span class="kd">func</span> <span class="nf">crack</span><span class="p">(</span><span class="nx">taskChan</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span><span class="nx">wg</span> <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">){</span>
   <span class="k">for</span> <span class="nx">task</span><span class="o">:=</span><span class="k">range</span> <span class="nx">taskChan</span><span class="p">{</span>
      <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;crack: &#34;</span><span class="p">,</span><span class="nx">task</span><span class="p">)</span>
      <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
      <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
   <span class="p">}</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
   <span class="nx">threat</span><span class="o">:=</span><span class="mi">10</span>
   <span class="nx">taskChan</span><span class="o">:=</span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span><span class="nx">threat</span><span class="p">)</span>
   <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nx">threat</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
      <span class="k">go</span> <span class="nf">crack</span><span class="p">(</span><span class="nx">taskChan</span><span class="p">,</span><span class="o">&amp;</span><span class="nx">wg</span><span class="p">)</span>
   <span class="p">}</span>

   <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="mi">100</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
      <span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
      <span class="nx">taskChan</span><span class="o">&lt;-</span><span class="nx">i</span>
   <span class="p">}</span>
   <span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
   <span class="nb">close</span><span class="p">(</span><span class="nx">taskChan</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>上面这个实例很好理解，相当于创建了10个并发的crack消费者，range感知taskChan的变化，再通过一个for依次把目标输送给goroutine。</p>
<p>实际上，除了控制并发之外，有时候我们还需要控制发包的速率，避免过快触发警告，可以利用<code>time.NewTicker(rateLimit)</code>计时器来控制发包</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">(){</span>
  <span class="nx">rate</span><span class="o">:=</span><span class="mi">10</span>
  <span class="nx">rateLimit</span><span class="o">:=</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="o">/</span><span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nx">rate</span><span class="p">)</span>
  <span class="nx">ticker</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTicker</span><span class="p">(</span><span class="nx">rateLimit</span><span class="p">)</span>
  <span class="nx">worker</span><span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">{</span>
      <span class="o">&lt;-</span><span class="nx">ticker</span><span class="p">.</span><span class="nx">C</span>
      <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;ok&#34;</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">go</span> <span class="nf">worker</span><span class="p">()</span>
  <span class="k">go</span> <span class="nf">worker</span><span class="p">()</span>
  <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="o">*</span><span class="mi">10</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>但如果在实际工程的时候，需要考虑一些问题。比如如果是多ip的扫描，应该给每个ip分发一个ticker而不是共享，不然对效率会有比较大的损失。</p>
<h2 id="退出协程的几种方式">退出协程的几种方式<a href="#退出协程的几种方式" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>关于协程，我们不仅要关注创建和通信，还要关注如何合理的退出。当然之前说到全局变量的确可以，但是不推荐，以下讲述三种方式退出协程。</p>
<h3 id="for-range退出">for-range退出<a href="#for-range退出" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>之前说过range可以感知channel的变化，如果协程只从一个channel中读取数据，那么下列的程序即可主动退出协程</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">(){</span>
   <span class="nx">channel</span><span class="o">:=</span><span class="nf">make</span> <span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
   <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;exit&#34;</span><span class="p">)</span>
      <span class="k">for</span> <span class="nx">x</span><span class="o">:=</span><span class="k">range</span> <span class="nx">channel</span><span class="p">{</span>
         <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
      <span class="p">}</span>
   <span class="p">}()</span>

   <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">1</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;=</span><span class="mi">10</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
      <span class="nx">channel</span><span class="o">&lt;-</span><span class="nx">i</span>
      <span class="k">if</span> <span class="nx">i</span><span class="o">==</span><span class="mi">5</span><span class="p">{</span>
         <span class="nb">close</span><span class="p">(</span><span class="nx">channel</span><span class="p">)</span>
         <span class="k">break</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h3 id="select退出">select退出<a href="#select退出" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>上述只是针对单个channel的读取，select的多路复用可以处理多个chanel，但是其并不能感知channel的关闭，会一直读取到0值。因为关闭的channel可以读取，但是写入会引发panic。不过我们可以用<code>,ok</code>来解决这个问题。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;exit&#34;</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="k">select</span> <span class="p">{</span>
			<span class="k">case</span> <span class="nx">x</span><span class="p">,</span><span class="nx">ok</span><span class="o">:=&lt;-</span><span class="nx">in</span><span class="p">:</span>
				<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
					<span class="k">return</span>
				<span class="p">}</span>
				<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;continue&#34;</span><span class="p">,</span><span class="nx">x</span><span class="p">)</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">other</span><span class="p">:</span>
				<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;continue&#34;</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}()</span>
</code></pre></div><p>上述的例子只要channel in关闭则会主动退出协程。但还是存在多个channel，如果有指定个channel退出，则退出协程的情况，这里要用到<strong>select不会在nil的通道上进行等待</strong>，所以我们可以把关闭的通道全部设置为nil，在循环底部加上判断即可。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
   <span class="k">for</span> <span class="p">{</span>
      <span class="k">select</span> <span class="p">{</span>
      <span class="k">case</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">in1</span><span class="p">:</span>
         <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
            <span class="nx">in1</span> <span class="p">=</span> <span class="kc">nil</span>
         <span class="p">}</span>
      <span class="k">case</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">in2</span><span class="p">:</span>
         <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
            <span class="nx">in2</span> <span class="p">=</span> <span class="kc">nil</span>
         <span class="p">}</span>
      <span class="k">if</span> <span class="nx">in1</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">in2</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
         <span class="k">return</span>
      <span class="p">}</span>
   <span class="p">}</span>
<span class="p">}()</span>
</code></pre></div><h3 id="使用专门通道退出协程">使用专门通道退出协程<a href="#使用专门通道退出协程" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>这里传入了一个专门的channel<code>stopCh</code>,当main函数执行close(stopCh)时，所有协程里的<code>case &lt;-stopCh</code>都会收到信号，进而关闭，这比给stopCh发送多个数据方便多了</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">worker</span><span class="p">(</span><span class="nx">stopCh</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span> <span class="p">{</span>
   <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;worker exit&#34;</span><span class="p">)</span>
      <span class="c1">// Using stop channel explicit exit
</span><span class="c1"></span>      <span class="k">for</span> <span class="p">{</span>
         <span class="k">select</span> <span class="p">{</span>
         <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">stopCh</span><span class="p">:</span>
            <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Recv stop signal&#34;</span><span class="p">)</span>
            <span class="k">return</span>
         <span class="k">default</span><span class="p">:</span>
            <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;running&#34;</span><span class="p">)</span>
            <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
         <span class="p">}</span>
      <span class="p">}</span>
   <span class="p">}()</span>
   <span class="k">return</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">(){</span>
   <span class="nx">stopCh</span><span class="o">:=</span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
   <span class="k">go</span> <span class="nf">worker</span><span class="p">(</span><span class="nx">stopCh</span><span class="p">)</span>
   <span class="k">go</span> <span class="nf">worker</span><span class="p">(</span><span class="nx">stopCh</span><span class="p">)</span>
   <span class="k">go</span> <span class="nf">worker</span><span class="p">(</span><span class="nx">stopCh</span><span class="p">)</span>
   <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">((</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
   <span class="nb">close</span><span class="p">(</span><span class="nx">stopCh</span><span class="p">)</span>
   <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h2 id="reference">Reference<a href="#reference" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<ul>
<li><a href="https://www.topgoer.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/channel.html">https://www.topgoer.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/channel.html</a></li>
<li><a href="https://studygolang.com/articles/16774">https://studygolang.com/articles/16774</a></li>
</ul>
<h2 id="写在最后">写在最后<a href="#写在最后" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>说一个很有意思的事情，笔者曾在去年寒假认认真真学了两个月go，原因呢，主要还是想要<del>专精</del>于一门语言吧。c++大一留下了很不好的印象，php动态类型不太能接受，最后选择了golang。学习路线大概是：</p>
<ol>
<li>
<p><a href="https://books.studygolang.com/gopl-zh/">Go语言圣经</a> 这本书的评价相当高，我也首先选择了这本，大概在是异常的时候放弃了，感觉这本书的例子很有高度，但不太适合初学者，更像是有一定经验的gopher日常回味的感觉。</p>
</li>
<li>
<p><a href="https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/directory.md">the way to go </a>后来加了一个go语言学习群，在里面有师傅推荐了这一本书，然后就顺着一点一点看，看到并发那一章的时候，卡住了&hellip;可能是思想上没能转变过来，最后无意间搜到了一本非常通俗易懂的书</p>
</li>
<li>
<p><a href="https://www.topgoer.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E4%BB%8B%E7%BB%8D.html">Go语言中文文档</a> 准确来说这并不是一本书，是一个叫枯藤的go语言爱好者结合前人的资料，总结下来的一份非常全面的文档，后续的学习也基本上是在这个的基础上，不过寒假的学习基本上到gin就结束了，rpc什么的都是后续回学校有的没的看一些。还有收集一些非常好的资料，但是都甚至没能深入看看。</p>
</li>
<li>
<p><a href="https://chai2010.cn/advanced-go-programming-book/">Go语言高级编程</a> 这本书的需要一定的基础，从目录-&gt;<code>CGO</code>,<code>汇编</code>,<code>RPC</code>等等也能看出来</p>
</li>
<li>
<p><a href="https://github.com/astaxie/build-web-application-with-golang">build-web-application-with-golang</a> 主要是web方面，也是评价很高</p>
</li>
<li>
<p><a href="https://draveness.me/golang/">Go 语言设计与实现</a> 刚刚点开的时候发现出书了！！！必须支持！！信仰师傅是某天操作系统课上，骏哥推给我的。如果真要对标一本其他的书的话，这本书在go上的定位可能和《深入了解java虚拟机》在java上一样。(不过我只看了基础知识和编译原理部分)</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2021/12/20211203181902.png" alt="contents-mindnode"></p>
<p>但是我想说的是什么呢，之前和骏哥聊天，说想学一门语言。我的习惯是在知乎，豆瓣看各种推荐，书评，然后罗列一大堆，再<strong>精挑细选</strong>一本慢慢看。骏哥呢？一个字，<code>调</code>。go？并发好像是优势，直接上手写，不会的就看官方文档。java？直接编译jdk，开调。solidity？编译evm虚拟机，开调。</p>
<p>这就导致了一点，我好像永远停留在语言的层面上，并为之此乐此不疲，但也只是一些皮毛功夫。语言只是工具，项目驱动学习效果会更好一些。比如学习springboot，比起上来就依赖注入，控制反转等概念的介绍，不如先抄或者直接照搬一个别人的代码跑起来，断点看看数据的流向，有问题再逐个学习。</p>
<p>这样来看，新人学习的确很容易进入一个误区，就是想办法让自己学的全面，各种铺路，实话说到现在我也还没能改掉这个毛病。我们得明白学这门语言是为了什么，大多时候毫无意义的准备都是因为迷茫，如果你是为了想写扫描器学go，那不如了解一些基础语法后，马上上手项目。我感觉这是有一些本末倒置了,书籍还是适合在有一些经验的基础上，作为一种内功提升的工具，让你看完后感觉：<code>居然还能这样?我之前的写法真是nt</code>。该踩的坑还是要踩的，学习之路漫漫无期&hellip;</p>

			</div>
			<hr class="post-end">
			<footer class="post-info">
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg></p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>2021-12-02 23:30 &#43;0800</p>
			</footer>
		</article>
		<aside id="toc" class="show-toc">
			<div class="toc-title"></div>
			<nav id="TableOfContents">
  <ul>
    <li><a href="#前言">前言</a></li>
    <li><a href="#如何控制协程的通信">如何控制协程的通信</a>
      <ul>
        <li><a href="#引入全局变量">引入全局变量</a></li>
        <li><a href="#利用channel通信">利用channel通信</a></li>
      </ul>
    </li>
    <li><a href="#控制并发量">控制并发量</a></li>
    <li><a href="#退出协程的几种方式">退出协程的几种方式</a>
      <ul>
        <li><a href="#for-range退出">for-range退出</a></li>
        <li><a href="#select退出">select退出</a></li>
        <li><a href="#使用专门通道退出协程">使用专门通道退出协程</a></li>
      </ul>
    </li>
    <li><a href="#reference">Reference</a></li>
    <li><a href="#写在最后">写在最后</a></li>
  </ul>
</nav>
		</aside>
		<div class="post-nav thin">
			<a class="prev-post" href="https://theoyu.top/posts/cel-go/">
				<span class="post-nav-label">&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><br><span>Preliminary Study on CEL-Go</span>
			</a>
		</div>
		<div id="comments" class="thin">
</div>
	</main>

	<footer id="site-footer" class="section-inner thin animated fadeIn faster">
		<p>&copy; 2021 <a href="https://theoyu.top/">Theoyu</a> &#183; <a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></p>
		<p>
			Made with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> &#183; Theme <a href="https://github.com/Track3/hermit" target="_blank" rel="noopener">Hermit</a> &#183; <a href="https://theoyu.top/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
		</p>
	</footer>



	<script src="https://theoyu.top/js/bundle.min.7d8545daa55d62427355498dd8da13f98ff79a7938ce7d2a5e2ae1ec0de3beb8.js" integrity="sha256-fYVF2qVdYkJzVUmN2NoT+Y/3mnk4zn0qXirh7A3jvrg=" crossorigin="anonymous"></script>
	

</body>

</html>
