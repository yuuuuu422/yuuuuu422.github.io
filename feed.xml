<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-06-12T20:59:53+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Theoyu</title><subtitle>Be cool,but also be warm.
</subtitle><author><name>Theoyu</name><email>zeyu.ou@foxmail.com</email></author><entry><title type="html">毕业</title><link href="http://localhost:4000/2023/essay/graduate" rel="alternate" type="text/html" title="毕业" /><published>2023-06-12T00:00:00+08:00</published><updated>2023-06-12T00:00:00+08:00</updated><id>http://localhost:4000/2023/essay/graduate</id><content type="html" xml:base="http://localhost:4000/2023/essay/graduate"><![CDATA[<!--more-->

<div><iframe class="extensions extensions--audio" width="330" height="86" src="https://music.163.com/outchain/player?type=2&amp;id=22821100&amp;auto=1&amp;height=66" frameborder="no" border="0" marginwidth="0" marginheight="0">
</iframe>
</div>

<p>前几天突然发现地铁已经修到了学校门前，图书馆上方的钟不知什么时候变成了绿色，我站在那儿，可能立定了一秒钟，毕业季燥热的风携带着四年的短暂片段，抽帧似的呼啸而过。和我设想的一样，淡淡的、白开水般的毕业。乌泱泱一堆的来，各自散开的走。</p>

<p>我在学校完完整整待过的时间不算长，满打满算或许也不到三年，各种实习还有疫情把大学的记忆切割成许多碎片，实验室、传媒中心以及一群随叫随到的兄弟应该就可以全部涵盖，所谓记忆我想就是和这些朋友在一起的欢快时光，当然这也是我最快乐的时光。</p>

<p>我是一直都喜欢毕业的，我喜欢去新的地方，我想一步步脱离『学生 』这个角色，我没觉着大学就一定和青春挂钩。我不是一个『好的学生』，学霸、奖学金、学生干部，我都很少想过，我只想在这个独一无二的四年里，学想学的东西，翘想翘的课，做喜欢做的事，和朋友们一起，学习、娱乐，成为想成为的人。离开时，我希望的不是别人说我很牛，而是我和别人不一样。</p>

<p>或许我会偶尔怀念青春，但我一定不会怀念学生时代，我由衷感激遇到的好老师给过我的启发，我笃定离开校园后的人生完全有可能更加灿烂。毕业，想想就觉得：不错，人生越来越有盼头了。</p>

<p>在高铁上写了这篇文章，但选择发出来还是比较犹豫，每次看都感觉有很多想法难以表述，毕竟来日方长，也并非都后会有期。</p>

<p>最后，也祝你生活愉快。</p>]]></content><author><name>Theoyu</name></author><category term="essay" /><category term="essay" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">关于 2022</title><link href="http://localhost:4000/2023/About2022" rel="alternate" type="text/html" title="关于 2022" /><published>2023-03-17T00:00:00+08:00</published><updated>2023-03-17T00:00:00+08:00</updated><id>http://localhost:4000/2023/About2022</id><content type="html" xml:base="http://localhost:4000/2023/About2022"><![CDATA[<!--more-->

<h2 id="一">一</h2>

<p>我最喜欢的季节是冬天，喜欢系上围巾，把手揣在兜里的感觉，然后随着耳机的音乐点头、呼吸，雾气把眼镜朦胧了也没有关系。</p>

<p>我最讨厌夏天，无论是郴州的、徐州的、还是北京的，特别是要下雨的时候，闷热、潮湿，仿佛人都要融化了一般。我的宿舍比较节约，所以我经常跑去活动室吹空调，不过那好像已经是快两年前的事情。</p>

<h2 id="二">二</h2>

<p>我经常会看之前写的年终总结和随笔，一是它可以帮我回忆那一年大概是个什么样的光景，二是它时刻提醒着我<strong>那一年我想成为怎样的人</strong>。</p>

<p>失败还是成功？就目前而言我并不能对此下结论。读书时期年轻气盛，大一时我想在 CTF 上有所建树；大二我想成为一名红队；大三我执着于安全研究；但最后我找到了一份 CyberSecurity Construction 的工作。我大概率无法成为我想成为的人，但是我还是在努力让自己不成为讨厌的那个人。</p>

<p>很多次我也会质疑自己的能力，质疑自己的工作，从 Destroy 到 Create 的转变需要一个过程，这一次我告诉自己我会留下，而不是选择逃避。</p>

<h2 id="三">三</h2>

<blockquote>
  <p>很多人习惯于把最差和最糟糕的一面留给最熟悉的人，却把宽容和耐心留给陌生人。</p>
</blockquote>

<p>很不巧，我刚好踩到了上面这一点。不过与其说是在亲密的人面前展现了糟糕的一面，不如说是把真实的自己无防备的展露出来。在 20 年的总结上我写到：『 我是一个疲于长期维护一段感情的人 』，我比较自负，当我的观点和别人不一致时，我会下意识的否定别人。对朋友而言，我不是一个好的听众，甚至有一些刻薄。</p>

<p>很感谢在 22 年有几位朋友说出了我的缺点，新的一年里我需要学会管理自己的情绪，控制表达自己的情感。</p>

<h2 id="四">四</h2>

<p>从去年找到工作到现在，我基本上是一篇技术文章都没有输出，明显感到自己对研究技术的精力、甚至兴趣都消减了很多，这让我感到有一些不安。后来看到了 yds 的博客，以及和 mentor  主动 one one 之后我明白了一个道理：『<strong>顺势而为</strong>』。借用 Jobs 演讲中的一段话：</p>

<blockquote>
  <p>工作将占据你生命中很大的一部分</p>

  <p>Your work is going to fill a large part of your life</p>

  <p>只有相信自己所做的是伟大的工作，你才能获得快乐</p>

  <p>and the only way to be truly satisfied is to do what you believe is great work</p>
</blockquote>

<p>我的工作肯定说不上伟大， 而且也确实消磨了我生活的大部分意志，但无论我如何主观的去思考它，它都不会变得有意义或者失去意义，我能做的通过自己的努力让这份工作变得有意义。顺势，才能有所作为。这是工作教会我的第一课。</p>

<h2 id="五">五</h2>

<p>今年的总结比较简单，本来已经没有打算写了，但想了想这是大学的最后一篇总结，还是打算补上，有一些仪式感的味道。</p>

<p>最后也祝看到这里的你身体健康，万事如意。</p>]]></content><author><name>Theoyu</name></author><category term="essay" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">网络安全秋招之路</title><link href="http://localhost:4000/2022/essay/SecInterview" rel="alternate" type="text/html" title="网络安全秋招之路" /><published>2022-11-01T00:00:00+08:00</published><updated>2022-11-01T00:00:00+08:00</updated><id>http://localhost:4000/2022/essay/SecInterview</id><content type="html" xml:base="http://localhost:4000/2022/essay/SecInterview"><![CDATA[<!--more-->

<div><iframe class="extensions extensions--audio" width="330" height="86" src="https://music.163.com/outchain/player?type=2&amp;id=22821107&amp;auto=1&amp;height=66" frameborder="no" border="0" marginwidth="0" marginheight="0">
</iframe>
</div>

<h2 id="写在前面">写在前面</h2>

<p>我最初的意向是打算出国读个硕士（主要考虑北欧和西欧），大约在8月初左右结束了暑期实习，一直到9月中旬中秋前一直都在准备留学相关工作（成绩、雅思、文书等等），比较闲还上了国外几门很优秀的公开课（具体可见前面几篇文章），最后因为一些家庭因素<strong>暂时</strong>终止了这个想法。我也了解今年秋招是属于地狱难度，并且这个时间点也已经过了大多数提前批的截止日期，不过好在我自身也属于一个比较善于规划的人，于是在中秋三天里花了一天整理自己的简历，花了一天收集秋招公司信息，再花了一天海投，最后就是数不清的测评、笔试、面试，一直到十月末才差不多结束 ;-(。回顾我的秋招历程，其实并没有太多时间给我准备，基本上就是边面试边复盘总结的过程，于是有了此文。</p>

<p>不过所谓面试指南，经验、技巧等等，我认为都是建立在面试者已经具备了一定合格的能力的基础上，更何况信息安全本身也是一门重视实操的学科。如果面试者自身基础不扎实，哪怕问到了一些准备过的问题，面试官也很容易通过一些 <strong>follow-up</strong> 的提问问出面试者的真实水平。</p>

<p>关于面试本身，我觉得这不仅是一场测试，一场选拔，更多的可以把它当作一次充满沟通和交流的谈话，所以我们并不需要畏惧。对于面试官而言，他可能只是希望招到一个能够愉快工作的同事、或者一个值得培养的下属；对于面试者而言，其实这是进入职场前少有的可以和业界大佬们直接交流的机会，所以我非常珍惜每一次面试。整个招聘的过程也是候选人和面试官的双向选择，一次好的面试体验会让我对这家公司好感大增 (^-^) ；反之有的面试官态度傲慢、咄咄逼人也会让我情不自禁的打退堂鼓 ಠ_ಠ（非常少数）。</p>

<p>后续内容为我整个秋招经历的思考、心得与总结，包括面试前的准备、面试中的应对以及未来的一些规划。希望可以帮助到同样找工作的同学。</p>

<h2 id="甲方-or-乙方的选择">甲方 or 乙方的选择</h2>

<p>在秋招之前我已有了两段乙方实习经验，所以个人对乙方的安全产品研发以及红队攻防也有了一定了解。最初我还是向往乙方，因为觉得乙方的工作更加纯粹，并且在某个垂直领域能有比较深入的学习，像一些实验室性质的工作受业务压力影响较少，会有很多时间研究自己感兴趣的东西。产生去甲方的想法是实习一次吃饭时，和华子哥聊到 SAST、以及漏洞挖掘相关话题，在这之前我上过一段时间南大的 <a href="https://www.bilibili.com/video/BV1b7411K7P4/?zw">程序分析课程</a> ，但我发现红队向的漏洞挖掘（直白一些就是面向 Pre-GetShell 的审计）更多的还是依靠人工的能力，我也有想过尝试自动化去辅助，但不同项目、业务的代码质量良莠不齐，基本上还是属于审完一套换一套的流水线。这时华子哥和我说如果受限于目前的工作模式，可以考虑去甲方看看。的确在甲方庞大的业务代码下，想只依靠人工直接审计的方式有些不太现实，也衍生出了 SAST、DAST、IAST 等等自动化测试技术以及 DevSecOps 的理念。这一些知识是在乙方环境下比较难去触碰的。</p>

<p>如果是站在甲方的这一点，我们可以考虑的就有非常多了，上到互联网、金融、区块链、最近火热的新能源汽车；下到国企、银行、医疗等等。在甲方公司进行选择的话，抛开物质上的因素（薪资、工作城市等等，虽然这个很重要，不过一般是放在拿到 offer 之后再需要考虑的），我在意的点只有有一个：<strong>公司业务是否对安全有真正的诉求</strong>，换句话来说就是<strong>安全部门是否有真正的话语权</strong>。上有喜茶网络安全部门被裁，下有马斯克血洗 Twitter 网安部门，虽然在进入信息安全专业那一天起，我们系主任就嚷嚷着：『没有网络安全就没有国家安全。』但我们不得不承认：安全的确不会带来直接的利益。如果公司对安全没有强诉求，对信息安全建设的重视和投入不足，那么安全部门在公司可能只是一个背锅的存在，在这样的环境下提心吊胆的工作我认为也是一件很痛苦的事情。</p>

<h2 id="简历是一切的开始">简历是一切的开始</h2>

<p>我认为简历上最关键的点有以下三项：学历、项目、实习。</p>

<ul>
  <li>学历：安全相比于开发，更不用说算法，其实对学历要求还没有那么严格，只不过今年部分公司的个别部门也有本硕 23 所以及目标院校的这一概念。但是学历这一块是定死的，我们也不能改变什么。</li>
  <li>项目：项目的话分安全开发项目和攻防实战项目两大类，但不管是什么，我认为最好还是遵从 STAR 法则：情境(situation)、任务(task)、行动(action)、结果(result)，即在什么背景下，做了什么东西，为什么这样做，取得了怎样的成果。即使是一个 demo 型的小项目或者校园内的简单渗透测试任务，好好准备也是有东西可以聊的。</li>
  <li>实习：实习同样遵循 STAR 法则，并且实习是基本上每一次面试都会占比较大比重的部分，但与之而来的问题是其实一部分短期实习，我们做的工作有限，甚至有的只是一些打杂的活，这就需要我们主动学习相关领域的知识，毕竟只有知识是永远属于自己的。如果面试官问起来既没有产出，也不知道细节，那不如不写这一段实习经历（面试官给我的原话 ）。</li>
</ul>

<p>除了以上三点，还有一些成果性的荣誉奖项，比如 CTF 比赛、发表的论文、高质量漏洞等等。但对我而言 CTF 基本上面试环节都没有提起过，甚至有些面试官问我 CTF 的全称是什么；漏洞相关也只是大概问一个挖掘思路，不过也可能是因为其并不是属于那种通用框架型漏洞的缘故。</p>

<h2 id="基础需要扎实">基础需要扎实</h2>

<p>这里的基础我分为三样：算法基础、计算机基础、安全基础。</p>

<p>算法基础是很多同学都容易忽视的一点，包括我在春招找实习时，笔试需要做算法的公司我都一律 pass …后来秋招意识到不对，基本上大多数公司的笔试题都有算法，有的甚至和开发放在一起纯算法笔试，不过我还是没有进行系统的准备，大约就简单温习了 STL 一些数据结构的调用。直到中秋后的第一场面试，整体都比较顺利，快结束时面试官说我们走个流程做一道算法吧，卒，然后面试官换了一道，磕磕碰碰写了出来，但结果不对，我说能不能让我在 Clion 上调试一下，面试官看了看时间让我说思路就行，卒 。之后便找了开发的同学，推荐了 <a href="https://programmercarl.com/">代码随想录</a>，大约花了一周，每天 10 小时左右爆刷，因为时间实在是不够，争取做一道就总结一道，前前后后大概做了 100 出头，少部分见下图（贪心和动态规划以及后面刷的一些题目没有纳入其中）：</p>

<p><img src="../../assets/images/image-20221108173126777.png" alt="image-20221108173126777" /></p>

<p>对我而言 100 多题手撕代码基本上足够了，安全方向的话主要以考察基本数据结构为主，当然时间充裕的话最好还是把代码随想录整体过一遍比较好，大约在 200 左右会更加有底气。</p>

<p>计算机基础基本上为计算机网络和操作系统两块，这里一样是开发同学推荐的  <a href="https://xiaolincoding.com/network/">小林coding</a> ，当然不建议像八股文那样去背，我觉得简单过一下就行，和之前说的一样信息安全还是一门重视实操的学科。打个比方面试官很少会直接问你 『 TCP 三次握手和四次挥手的过程 』，但是可能会问 『 NMap 支持哪些端口扫描方式，可以分别说说对应 TCP  三次握手和四次挥手的哪一环节吗？』</p>

<p>安全基础因人而异，web 安全的话至少 OWASP Top 10 得非常熟悉，从漏洞原理到利用到预防。这里推荐 <a href="https://websec.readthedocs.io/zh/latest/">Web安全学习笔记</a> 作为自己查漏补缺的资料，当然不同公司侧重点也会很不一样，就拿最基础的 Sql 注入来说，有的公司可能会对利用这一块要求比较高，比如</p>

<pre><code class="language-txt">xxx 被过滤了如何绕过？
如何判断数据库类型？不同数据库打法上有什么不一样？
不同数据库版本之间的各种tricks
</code></pre>

<p>但有的公司可能会对原理上考察更加全面：</p>

<pre><code class="language-txt">sql 注入如何预防？
预编译的原理是什么？在业务中有哪些不能使用预编译的点，为什么？
WAF如何检测sql注入、RASP如何检测、了解AST吗？
</code></pre>

<p>基础这一块可以选择多看看面经，慢慢总结完善。不过如果是打 CTF 出身并且基础扎实的同学，我认为还是不用太担心的。</p>

<h2 id="找准自己的领域">找准自己的领域</h2>

<p>随着各种业务高速发展，安全行业的需求其实也是逐步增长，人的精力终归有限，找到属于自己的领域对无论自我认知还是发展都非常重要。</p>

<p>在大一刚接触安全时，老师把我们简单分为 Web 和二进制两个方向；后来打 CTF 时，我根据 CTF 的题目类型把安全分为 web、逆向、pwn、密码和杂项（取证、隐写）。这样划分终归还是比较片面，如果我们能对自己有一个深刻的认知，找到一个适合自己的方向，进而在简历和面试中凸显出来，至少能告诉面试官：『 我想做这个方向，我觉得我比较合适 』。</p>

<p>单从网络安全来说，不同的人侧重点可能完全不一样：有的人打点很厉害、手握不少 0day；有的人内网漫游、对各类云环境也非常熟悉；有的人擅长漏扫和白盒、对SDL有自己的理解和实践 …安全同时需要广度和深度，如果能在适合自己的领域长期学习和发展，我觉得是一件很快乐和有价值的事情。</p>

<h2 id="提前应对通用问题">提前应对通用问题</h2>

<p>在面试中有很大一部分时间都会交给我们自己来说，就我而言以下问题是基本上每次面试都会问到的：</p>

<pre><code class="language-txt">1. 自我介绍
2. 介绍实习
3. 介绍项目
4. 最有印象的一道CTF题目？
5. 最有意思的一次挖洞/渗透经历？
6. 给你一套代码，如何做代码审计？
7. 给你一个网站，如何做渗透测试？
......
</code></pre>

<p>上面这些问题的答案，尽可能提前总结记录下来，能比较流畅的介绍，如果条件允许的话可以说给志同道合的朋友。我和室友就经常会互相模拟面试问答 (*^^*) ，这样比较 open 的方式经常会暴露很多自己看不到的问题，也是收获很多。</p>

<h2 id="写在最后">写在最后</h2>

<p>秋招属实不易，让我最直观的感受就是 <strong>个人在大环境下实在渺小</strong>，而我很大一部分的焦虑就源自于和别人的比较，后来想开了也就没有那么多的精神内耗。<strong>降低预期，减少攀比，顺势而为</strong>，毕竟一切都得向前看，不是吗？</p>

<p>受限于我的眼界和水平，文章很多观点可能非常片面和不妥，还请谅解，欢迎批评指正；如果你在阅读之后能有一些收获，那也是我莫大的荣幸。</p>

<p>最后，还要感谢一路上众多师傅以及学长们的指导帮助，</p>

<p>当然，</p>

<p>也要感谢在寒冬下没有放弃的自己。</p>

<p>开启一段新的征途吧。</p>]]></content><author><name>Theoyu</name></author><category term="essay" /><category term="essay" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">『 CS61C 』 Labs</title><link href="http://localhost:4000/2022/cource/cs61c_labs" rel="alternate" type="text/html" title="『 CS61C 』 Labs" /><published>2022-09-10T00:00:00+08:00</published><updated>2022-09-10T00:00:00+08:00</updated><id>http://localhost:4000/2022/cource/cs61c_labs</id><content type="html" xml:base="http://localhost:4000/2022/cource/cs61c_labs"><![CDATA[<!--more-->

<h2 id="lab-1-c--cgdb">Lab 1: C &amp; CGDB</h2>

<h3 id="learning-goals">Learning Goals</h3>

<ol>
  <li>练习使用指针、字符串和结构体。</li>
  <li>学会基础的调试技巧：编译警告消除、断言以及 GDB 。</li>
</ol>

<p>Exercise 1 是一个 C 语言的 Warm Up，实现几个简易函数即可。</p>

<p>Exercise 2 需要我们使用 GDB，发现并修改程序中的一些逻辑 BUG，这里我使用的是 CGDB，相比于 GDB 来说可以更加方便的在源码上下断点跟进。</p>

<p><img src="../../assets/images/image-20220926083553611.png" alt="image-20220926083553611" /></p>

<p>注意，如果我们需要用 CGDB 在源码层面上进行调试，需要在编译时指定 -g 参数，gcc 会在编译时做以下额外操作：</p>

<ol>
  <li>创建调试符号表，符号表包含了程序中使用的变量名称等信息。</li>
  <li>关闭所有的优化机制，以便程序严格按照源码流程执行。</li>
</ol>

<p>下面是CGDB的一些常用指令</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>空格      断点
run r    运行
start    从第一行开始单步运行
next n   单步调试 F8
step s   进入内部 F10
until u  快速运行完循环、until localtion 运行到目的行
continue 运行到下一个断点 F6
finish   跳出当前栈帧 F7
info locals 打印本地变量
print p  显示变量
display  持续打印某个变量
watch 
o        打开文件列表
</code></pre></div></div>

<p>Exercise 3 还是对 CGDB 的练习，需要我们通过调试，找到并修改链表中的一个 segfaults （段错误）。</p>

<p>Exercise 4 需要我们实现一个链表有环的判断，用双指针即可。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">ll_has_cycle</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* TODO: Implement ll_has_cycle */</span>
    <span class="n">node</span> <span class="o">*</span> <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="n">node</span> <span class="o">*</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">fast</span> <span class="o">&amp;&amp;</span> <span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">){</span>
        <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span> <span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">fast</span> <span class="o">==</span> <span class="n">slow</span><span class="p">){</span>
            <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="lab-2-c-memory-management-valgrind">Lab 2: C Memory Management, Valgrind</h2>

<h3 id="learning-goals-1">Learning Goals</h3>

<ol>
  <li>练习简单的位操作。</li>
  <li>学会使用 Valgrind 进行内存泄漏检查。</li>
  <li>练习编写安全的程序。</li>
</ol>

<h3 id="exercise-1-bit-operations">Exercise 1: Bit Operations</h3>

<p>需要我们只通过简单的位运算符实现以下三个函数：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Returns the Nth bit of X. Assumes 0 &lt;= N &lt;= 31. */</span>
<span class="kt">unsigned</span> <span class="nf">get_bit</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">x</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* YOUR CODE HERE */</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* UPDATE WITH THE CORRECT RETURN VALUE*/</span>
<span class="p">}</span>

<span class="cm">/* Set the nth bit of the value of x to v. Assumes 0 &lt;= N &lt;= 31, and V is 0 or 1 */</span>
<span class="kt">void</span> <span class="nf">set_bit</span><span class="p">(</span><span class="kt">unsigned</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">n</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* YOUR CODE HERE */</span>
<span class="p">}</span>

<span class="cm">/* Flips the Nth bit in X. Assumes 0 &lt;= N &lt;= 31.*/</span>
<span class="kt">void</span> <span class="nf">flip_bit</span><span class="p">(</span><span class="kt">unsigned</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* YOUR CODE HERE */</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这一关和 CSAPP 里位运算的那一个 lab 很类似，算是简化版，稍微想一下就能很快写出来。</p>

<h3 id="exercise-2-valgrind">Exercise 2: Valgrind</h3>

<p>Valgrind 是一款用于程序调试和分析的开源工具，可以用于检测和追溯内存泄漏。</p>

<p>在编译时，指定 -g 参数，可有助于调试时定位到具体代码行，这里我们以一个创建链表为例：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">add_to_front</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>运行 <code class="language-plaintext highlighter-rouge">valgrind --leak-check=full ./linked_list</code></p>

<p>输出：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Congrats! All of the test cases passed!
==58781== 
==58781== HEAP SUMMARY:
==58781==     in use at exit: 80 bytes in 5 blocks
==58781==   total heap usage: 6 allocs, 1 frees, 1,104 bytes allocated
==58781== 
==58781== 80 (16 direct, 64 indirect) bytes in 1 blocks are definitely lost in loss record 2 of 2
==58781==    at 0x4849D8C: malloc (in /usr/lib/aarch64-linux-gnu/valgrind/vgpreload_memcheck-arm64-linux.so)
==58781==    by 0x1089BF: create_node (linked_list.c:8)
==58781==    by 0x108A67: add_to_front (linked_list.c:35)
==58781==    by 0x108C77: main (test_linked_list.c:14)
==58781== 
==58781== LEAK SUMMARY:
==58781==    definitely lost: 16 bytes in 1 blocks
==58781==    indirectly lost: 64 bytes in 4 blocks
==58781==      possibly lost: 0 bytes in 0 blocks
==58781==    still reachable: 0 bytes in 0 blocks
==58781==         suppressed: 0 bytes in 0 blocks
==58781== 
==58781== For lists of detected and suppressed errors, rerun with: -s
==58781== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
</code></pre></div></div>

<p>从上面信息可以定位到一共有 5 个内存泄漏点，其中 1 个为直接泄漏，即 head 指向的那一个节点；4 个为间接泄漏，即之后四个节点。</p>

<p>下面通过几个案例进一步学习 Valgrind的使用。</p>

<h4 id="访问未初始化的内存"><strong>访问未初始化的内存</strong>：</h4>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="../../assets/images/image-20220927182400743.png" alt="image-20220927182400743" /></p>

<h4 id="内存释放后读写"><strong>内存释放后读写</strong></h4>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"malloc.h"</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="n">free</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="../../assets/images/image-20220927195638840.png" alt="image-20220927195638840" /></p>

<h4 id="动态内存越界读写">动态内存越界读写</h4>

<p><img src="../../assets/images/image-20220927201108831.png" alt="image-20220927201108831" /></p>

<h4 id="double-free">double free</h4>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"malloc.h"</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mh">0x4</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="../../assets/images/image-20220927202554310.png" alt="image-20220927202554310" /></p>

<h3 id="exercise-3-memory-management">Exercise 3: Memory Management</h3>

<p>这部分需要我们补充一个缺陷的 vector，非常的基础，可以结合之前所学的 CGDB 调试以及 Valgrind 检测内存情况。</p>

<h2 id="lab-3-risc-v-assembly">Lab 3: RISC-V Assembly</h2>

<h3 id="learning-goals-2">Learning Goals</h3>

<ol>
  <li>熟悉使用 Venus 模拟 RISC-V 的运行。</li>
  <li>了解 C 代码和 RISC -V 之间的相互转化。</li>
  <li>编写正确的 RISC -V 函数调用。</li>
</ol>

<p>Exercise 1 需要我们配置好 venus 的环境，简单来说就是把虚拟机或者 docker 里的 lab 文件夹映射到某个 web 路径下，然后通过 <a href="https://venus.cs61c.org/">venus 的网站</a> 进行访问，从而对本地文件进行调试分析。</p>

<p>但是后来发现 vscode 自身就有相关的插件，也还不错，效果如下：</p>

<p><img src="../../assets/images/image-20220929222126647.png" alt="image-20220929222126647" /></p>

<p>Exercise 2 通过一个斐波那契的例子，熟悉 Venus 对 RISC-V 调试分析。</p>

<p>Exercise 3 还是一个阅读理解，通过给出的 c 和 RISC-V 代码，找到两者的联系。</p>

<p>Exercise 4 需要我们使用 RISC-V  来实现阶乘，算是对之前所学的函数调用以及循环控制的一个练习。</p>

<h3 id="exercise-5-risc-v-function-calling-with-map">Exercise 5: RISC-V function calling with <code class="language-plaintext highlighter-rouge">map</code></h3>

<p>这一小节需要我们完善一个链表以及 <code class="language-plaintext highlighter-rouge">map</code> 函数，该函数可以穿入一个链表以及函数指针来修改链表的内容。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">node</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">map</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="kt">int</span><span class="p">))</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">head</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">);</span>
    <span class="n">map</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span><span class="n">f</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这里提一下链表，我们在 C 语言中如果想创建一个<code class="language-plaintext highlighter-rouge">9-&gt;8-&gt;7...-&gt;2-&gt;1</code> 的链表，一般是按顺序创建结点和修改指向</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>node_9-&gt;data=9;
node_9-&gt;next=node_8;
node_8-&gt;data=8;
node_8-&gt;next=node_7...
node_1-&gt;data=1;
node_1-&gt;next=NULL;
</code></pre></div></div>

<p>按照这个思路，我们需要把头节点暂存，然后每次把尾节点指向一个 malloc 分配的空间，重复操作，再返回头节点，这些许有些麻烦。</p>

<p>代码框架是从用从 1 到 9 的创建顺序，这样可以省去很多寄存器的使用，并且最后返回的就是头节点。</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">li</span> <span class="n">a0</span><span class="p">,</span> <span class="mi">8</span>            <span class="c1">#     molloc 8 bytes on heap</span>
    <span class="n">jal</span> <span class="n">ra</span><span class="p">,</span> <span class="n">malloc</span>      <span class="c1">#     Allocate memory for the next node</span>
    <span class="n">sw</span> <span class="n">s1</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="n">a0</span><span class="p">)</span>        <span class="c1">#     node-&gt;value = i</span>
    <span class="n">sw</span> <span class="n">s0</span><span class="p">,</span> <span class="mi">4</span><span class="p">(</span><span class="n">a0</span><span class="p">)</span>        <span class="c1">#     node-&gt;next = last</span>
    <span class="n">add</span> <span class="n">s0</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="n">x0</span>      <span class="c1">#     last = node</span>
    <span class="n">addi</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="mi">1</span>      <span class="c1">#     i++</span>
    <span class="n">addi</span> <span class="n">t0</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="mi">10</span>
    <span class="n">bne</span> <span class="n">s1</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">loop</span>    <span class="c1"># ... while i!= 10  </span>
</code></pre></div></div>

<h2 id="lab-4-risc-v-functions-pointers">Lab 4: RISC-V Functions, Pointers</h2>

<p>Exercise 1 需要我们补充 <code class="language-plaintext highlighter-rouge">f</code> 函数，使得调用传入数组和不同的 key ，输出不同的 value。</p>

<p>Exercise 2 需要我们修复  <code class="language-plaintext highlighter-rouge">cc_test.s</code> 中的访问错误，主要涉及到 s 寄存器的保存。</p>

<p>Exercise 3 要去我们使用规定的寄存器完成对以下 node 的遍历以及修改。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">node</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">arr</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>这一节的坑点还是挺多的，主要是需要灵活的在不同场景使用不同寄存器。</p>

<h2 id="lab-5-logisim">Lab 5: Logisim</h2>

<p>这一节算是给 project3 去做一个铺垫，也是终于进入了硬件部分，实验采用了  logisim 软件模拟和仿真数字电路。</p>

<h3 id="exercise-2-sub-circuits">Exercise 2: Sub-Circuits</h3>

<p>需要我们只用 <code class="language-plaintext highlighter-rouge">AND</code>, <code class="language-plaintext highlighter-rouge">OR</code>,<code class="language-plaintext highlighter-rouge">NOT </code>三种门电路实现NAND、NOR、XOR、MUX，前面几个比较简单，最后一个需要我们实现 4-to-1 Multiplexor，需要我们复用用上一个实现的 2-to-1 Multiplexor。</p>

<p><img src="../../assets/images/image-20221017181928848.png" alt="image-20221017181928848" /></p>

<p>Exercise 3: Storing State 这一节照着示意图做就可以，让我们用寄存器和加法器去理解存储的这个中间状态。</p>

<h3 id="exercise-4-rotate-right">Exercise 4: Rotate Right</h3>

<p>这一节需要我们实现算术右移 <code class="language-plaintext highlighter-rouge">RotRight</code>，根据输入的 INPUT0 ，将其整体右移 AMOUNT 位。</p>

<p>这里我们可以先分别实现右移1位、2位、4位、8位，再用 MUX 组合起来。</p>

<p>单个的 rot 可以利用 Splitters 组件简单实现 bit 交换。</p>

<p><img src="../../assets/images/image-20221019220418880.png" alt="image-20221019220418880" /></p>

<h2 id="lab-6-cpu-pipelining">Lab 6: CPU, Pipelining</h2>

<h3 id="exercise-1---constructing-immediates">Exercise 1 - Constructing Immediates</h3>

<p>这一节需要我们生成 S型指令中的立即数，S型指令结构如下图：</p>

<p><img src="../../assets/images/image-20221113133558814.png" alt="image-20221113133558814" /></p>

<p>最后还需要进行一个 12 位到 32 位的符号拓展：</p>

<p><img src="../../assets/images/image-20221113142854106.png" alt="image-20221113142854106" /></p>

<h3 id="exercise-2---constructing-the-brun-control-signal">Exercise 2 - Constructing the BrUn Control Signal</h3>

<p>这一节需要我们根据 B型指令中的 <strong>funct3</strong> 属性判断 branch 的跳转比较是有符号还是无符号，如下图：</p>

<p><img src="../../assets/images/image-20221113145135873.png" alt="image-20221113145135873" /></p>

<p>如果是无符号 BrUn 输出1，有符号则输出0，这里直接拿第13位进行：</p>

<p><img src="../../assets/images/image-20221113150537288.png" alt="image-20221113150537288" /></p>

<p>官网的提示想让我们用比较器，去综合比较 funct3 的值，如下也可以：</p>

<p><img src="../../assets/images/image-20221113150853508.png" alt="image-20221113150853508" /></p>

<p>Exercise 4 初步引入了 pipeline 的概念，如果一条指令依赖于前一条指令的输出，可以采用流水线的理念分层进行。</p>

<p><img src="../../assets/images/image-20221113153900852.png" alt="image-20221113153900852" /></p>

<h2 id="lab-7-caches">Lab 7: Caches</h2>

<h2 id="lab-8-simd-instructions">Lab 8: SIMD Instructions</h2>

<h2 id="lab-9-thread-level-parallelism">Lab 9: Thread-Level Parallelism</h2>

<h2 id="lab-10-virtual-memory">Lab 10: Virtual Memory</h2>]]></content><author><name>Theoyu</name></author><category term="cource" /><category term="cource" /><category term="CS61C" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">『 CS61C 』Project 2 Classify</title><link href="http://localhost:4000/2022/cource/cs61c_project2" rel="alternate" type="text/html" title="『 CS61C 』Project 2 Classify" /><published>2022-09-05T00:00:00+08:00</published><updated>2022-09-05T00:00:00+08:00</updated><id>http://localhost:4000/2022/cource/cs61c_project2</id><content type="html" xml:base="http://localhost:4000/2022/cource/cs61c_project2"><![CDATA[<!--more-->

<h2 id="part-a">Part A</h2>

<h3 id="task-2-relu">Task 2: ReLU</h3>

<h4 id="concept">Concept</h4>

<p>这一节需要我们实现 <code class="language-plaintext highlighter-rouge">relu</code> 函数，该函数输入一个数组和数组长度，需要把数组内的负数元素置为 0。</p>

<p><img src="../../assets/images/image-20221007122605265.png" alt="image-20221007122605265" /></p>

<h4 id="code">Code</h4>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">loop_start</span><span class="o">:</span>
	<span class="n">addi</span> <span class="n">sp</span><span class="p">,</span><span class="n">sp</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span>
	<span class="n">sw</span> <span class="n">s0</span><span class="p">,</span><span class="mi">0</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
	<span class="n">li</span> <span class="n">t0</span><span class="p">,</span><span class="mi">0</span>

<span class="n">loop</span><span class="o">:</span>
	<span class="n">beq</span> <span class="n">t0</span><span class="p">,</span><span class="n">a1</span><span class="p">,</span><span class="n">loop_end</span>      <span class="c1"># if  t0 == length go</span>
	<span class="n">slli</span> <span class="n">t1</span> <span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="mi">2</span>	        <span class="c1"># offset, t1 = t0 * 4</span>
	<span class="n">add</span> <span class="n">s0</span><span class="p">,</span><span class="n">a0</span><span class="p">,</span><span class="n">t1</span>            <span class="c1"># s0 = &amp;a0[t0]</span>
	<span class="n">lw</span> <span class="n">t2</span><span class="p">,</span><span class="mi">0</span><span class="p">(</span><span class="n">s0</span><span class="p">)</span>	            <span class="c1"># t2 = a0[t0]</span>
	<span class="n">bge</span> <span class="n">t2</span><span class="p">,</span><span class="n">x0</span><span class="p">,</span><span class="n">loop_continue</span> <span class="c1"># if t2 &gt;= 0 go</span>
	<span class="n">sw</span> <span class="n">x0</span><span class="p">,</span><span class="mi">0</span><span class="p">(</span><span class="n">s0</span><span class="p">)</span>             <span class="c1"># else a0[t0] = 0</span>
<span class="n">loop_continue</span><span class="o">:</span>
	<span class="n">addi</span> <span class="n">t0</span><span class="p">,</span><span class="n">t0</span><span class="p">,</span><span class="mi">1</span>            <span class="c1"># t0 = t0 + 1</span>
	<span class="n">j</span> <span class="n">loop</span>
<span class="n">loop_end</span><span class="o">:</span>
	<span class="c1"># Epilogue</span>
	<span class="n">lw</span> <span class="n">s0</span><span class="p">,</span><span class="mi">0</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
	<span class="n">addi</span> <span class="n">sp</span><span class="p">,</span><span class="n">sp</span><span class="p">,</span><span class="mi">4</span>
	<span class="n">ret</span>
<span class="n">error</span><span class="o">:</span>
	<span class="n">li</span> <span class="n">a0</span><span class="p">,</span><span class="mi">36</span>
	<span class="n">j</span> <span class="k">exit</span>
</code></pre></div></div>

<h3 id="task-3-argmax">Task 3: Argmax</h3>

<h4 id="concept-1">Concept</h4>

<p><code class="language-plaintext highlighter-rouge">argmax</code> 需要我们输入一个数组和数组长度，返回该数组中最大元素的下标。</p>

<h4 id="code-1">Code</h4>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mf">.</span><span class="n">globl</span> <span class="n">argmax</span>

<span class="mf">.</span><span class="n">text</span>
<span class="c1"># =================================================================</span>
<span class="c1"># FUNCTION: Given a int array, return the index of the largest</span>
<span class="c1">#   element. If there are multiple, return the one</span>
<span class="c1">#   with the smallest index.</span>
<span class="c1"># Arguments:</span>
<span class="c1">#   a0 (int*) is the pointer to the start of the array</span>
<span class="c1">#   a1 (int)  is the # of elements in the array</span>
<span class="c1"># Returns:</span>
<span class="c1">#   a0 (int)  is the first index of the largest element</span>
<span class="c1"># Exceptions:</span>
<span class="c1">#   - If the length of the array is less than 1,</span>
<span class="c1">#     this function terminates the program with error code 36</span>
<span class="c1"># =================================================================</span>
<span class="n">argmax</span><span class="o">:</span>
	<span class="c1"># Prologue</span>
	<span class="n">li</span> <span class="n">t0</span><span class="p">,</span><span class="mi">1</span>
	<span class="n">blt</span> <span class="n">a1</span><span class="p">,</span><span class="n">t0</span><span class="p">,</span><span class="n">error</span>

<span class="n">loop_start</span><span class="o">:</span>
	<span class="n">addi</span> <span class="n">sp</span><span class="p">,</span><span class="n">sp</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span>
	<span class="n">sw</span> <span class="n">s0</span><span class="p">,</span><span class="mi">0</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
	<span class="n">li</span> <span class="n">t0</span><span class="p">,</span><span class="mi">1</span>
	<span class="n">li</span> <span class="n">t3</span><span class="p">,</span><span class="mi">0</span>	                <span class="c1"># max_index = 0</span>
	<span class="n">lw</span> <span class="n">t4</span><span class="p">,</span><span class="mi">0</span><span class="p">(</span><span class="n">a0</span><span class="p">)</span>             <span class="c1"># max_value = num[0]</span>

<span class="n">loop</span><span class="o">:</span>
	<span class="n">beq</span> <span class="n">t0</span><span class="p">,</span><span class="n">a1</span><span class="p">,</span><span class="n">loop_end</span>      <span class="c1"># if  t0 == length go</span>
	<span class="n">slli</span> <span class="n">t1</span> <span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="mi">2</span>	        <span class="c1"># offset, t1 = t0 * 4</span>
	<span class="n">add</span> <span class="n">s0</span><span class="p">,</span><span class="n">a0</span><span class="p">,</span><span class="n">t1</span>            <span class="c1"># s0 = &amp;num[t0]</span>
	<span class="n">lw</span> <span class="n">t2</span><span class="p">,</span><span class="mi">0</span><span class="p">(</span><span class="n">s0</span><span class="p">)</span>	            <span class="c1"># t2 = num[t0]</span>
	<span class="n">blt</span> <span class="n">t2</span><span class="p">,</span><span class="n">t4</span><span class="p">,</span><span class="n">loop_continue</span> <span class="c1"># if t2 &lt; max_value  go</span>
	<span class="n">mv</span> <span class="n">t3</span><span class="p">,</span><span class="n">t0</span>                <span class="c1"># else max_index = t0</span>
	<span class="n">mv</span> <span class="n">t4</span><span class="p">,</span><span class="n">t2</span>                <span class="c1">#      max_value = t4</span>
<span class="n">loop_continue</span><span class="o">:</span>
	<span class="n">addi</span><span class="p">,</span><span class="n">t0</span><span class="p">,</span><span class="n">t0</span><span class="p">,</span><span class="mi">1</span>
	<span class="n">j</span> <span class="n">loop</span>
<span class="n">loop_end</span><span class="o">:</span>
	<span class="c1"># Epilogue</span>
	<span class="n">mv</span> <span class="n">a0</span><span class="p">,</span><span class="n">t3</span>
	<span class="n">lw</span> <span class="n">s0</span><span class="p">,</span><span class="mi">0</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
	<span class="n">addi</span> <span class="n">sp</span><span class="p">,</span><span class="n">sp</span><span class="p">,</span><span class="mi">4</span>
	<span class="n">ret</span>

<span class="n">error</span><span class="o">:</span>
	<span class="n">li</span> <span class="n">a0</span><span class="p">,</span><span class="mi">36</span>
	<span class="n">j</span> <span class="k">exit</span>

</code></pre></div></div>

<h3 id="task-4-dot-product">Task 4: Dot Product</h3>

<h4 id="concept-2">Concept</h4>

<p>这一节将输入两个数组，每个数组以输入的 stride 遍历 n 个元素，把每轮的两个元素相乘的结果最后相加返回。</p>

<p><img src="../../assets/images/image-20221007125341085.png" alt="image-20221007125341085" /></p>

<h4 id="code-2">Code</h4>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mf">.</span><span class="n">globl</span> <span class="n">dot</span>

<span class="mf">.</span><span class="n">text</span>
<span class="c1"># =======================================================</span>
<span class="c1"># FUNCTION: Dot product of 2 int arrays</span>
<span class="c1"># Arguments:</span>
<span class="c1">#   a0 (int*) is the pointer to the start of arr0</span>
<span class="c1">#   a1 (int*) is the pointer to the start of arr1</span>
<span class="c1">#   a2 (int)  is the number of elements to use</span>
<span class="c1">#   a3 (int)  is the stride of arr0</span>
<span class="c1">#   a4 (int)  is the stride of arr1</span>
<span class="c1"># Returns:</span>
<span class="c1">#   a0 (int)  is the dot product of arr0 and arr1</span>
<span class="c1"># Exceptions:</span>
<span class="c1">#   - If the length of the array is less than 1,</span>
<span class="c1">#     this function terminates the program with error code 36</span>
<span class="c1">#   - If the stride of either array is less than 1,</span>
<span class="c1">#     this function terminates the program with error code 37</span>
<span class="c1"># =======================================================</span>
<span class="n">dot</span><span class="o">:</span>
    <span class="n">li</span> <span class="n">t0</span><span class="p">,</span><span class="mi">1</span>
    <span class="n">blt</span> <span class="n">a2</span><span class="p">,</span><span class="n">t0</span><span class="p">,</span><span class="n">error1</span>
    <span class="n">blt</span> <span class="n">a3</span><span class="p">,</span><span class="n">t0</span><span class="p">,</span><span class="n">error2</span>
    <span class="n">blt</span> <span class="n">a4</span><span class="p">,</span><span class="n">t0</span><span class="p">,</span><span class="n">error2</span>


<span class="n">loop_start</span><span class="o">:</span>
    <span class="n">addi</span> <span class="n">sp</span><span class="p">,</span><span class="n">sp</span><span class="p">,</span><span class="o">-</span><span class="mi">8</span>
    <span class="n">sw</span> <span class="n">s0</span><span class="p">,</span><span class="mi">0</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>     
    <span class="n">sw</span> <span class="n">s1</span><span class="p">,</span><span class="mi">4</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
    <span class="n">mv</span> <span class="n">s0</span><span class="p">,</span><span class="n">a0</span>
    <span class="n">mv</span> <span class="n">s1</span><span class="p">,</span><span class="n">a1</span>
    <span class="n">li</span> <span class="n">t0</span><span class="p">,</span><span class="mi">0</span>           <span class="c1"># for loop</span>
    <span class="n">li</span> <span class="n">t1</span><span class="p">,</span><span class="mi">4</span>
    <span class="n">mul</span> <span class="n">t1</span><span class="p">,</span><span class="n">t1</span><span class="p">,</span><span class="n">a3</span>      <span class="c1"># offset for a0</span>
    <span class="n">li</span> <span class="n">t2</span> <span class="mi">4</span>
    <span class="n">mul</span> <span class="n">t2</span><span class="p">,</span><span class="n">t2</span><span class="p">,</span><span class="n">a4</span>      <span class="c1"># offset for a1</span>
    <span class="n">li</span> <span class="n">t6</span><span class="p">,</span><span class="mi">0</span>           <span class="c1"># sum</span>
<span class="n">loop</span><span class="o">:</span>
    <span class="n">beq</span> <span class="n">t0</span><span class="p">,</span><span class="n">a2</span><span class="p">,</span><span class="n">loop_end</span> 
    <span class="n">lw</span> <span class="n">t3</span><span class="p">,</span><span class="mi">0</span><span class="p">(</span><span class="n">s0</span><span class="p">)</span>
    <span class="n">add</span> <span class="n">s0</span><span class="p">,</span><span class="n">s0</span><span class="p">,</span><span class="n">t1</span>      <span class="c1"># s0 = &amp;a0[t0]</span>
    <span class="n">lw</span> <span class="n">t4</span><span class="p">,</span><span class="mi">0</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>
    <span class="n">add</span> <span class="n">s1</span><span class="p">,</span><span class="n">s1</span><span class="p">,</span><span class="n">t2</span>      <span class="c1"># s1 = &amp;a1[t0]</span>
    <span class="n">mul</span> <span class="n">t5</span><span class="p">,</span><span class="n">t3</span><span class="p">,</span><span class="n">t4</span>
    <span class="n">add</span> <span class="n">t6</span><span class="p">,</span><span class="n">t6</span><span class="p">,</span><span class="n">t5</span>
    <span class="n">addi</span> <span class="n">t0</span><span class="p">,</span><span class="n">t0</span><span class="p">,</span><span class="mi">1</span>
    <span class="n">j</span> <span class="n">loop</span> 
<span class="n">loop_end</span><span class="o">:</span>
    <span class="n">mv</span> <span class="n">a0</span><span class="p">,</span><span class="n">t6</span>
    <span class="n">lw</span> <span class="n">s0</span><span class="p">,</span><span class="mi">0</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
    <span class="n">lw</span> <span class="n">s1</span><span class="p">,</span><span class="mi">4</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
    <span class="n">addi</span> <span class="n">sp</span><span class="p">,</span><span class="n">sp</span><span class="p">,</span><span class="mi">8</span>
    <span class="n">ret</span>
<span class="n">error1</span><span class="o">:</span>
	<span class="n">li</span> <span class="n">a0</span><span class="p">,</span><span class="mi">36</span>
	<span class="n">j</span> <span class="k">exit</span>
<span class="n">error2</span><span class="o">:</span>
	<span class="n">li</span> <span class="n">a0</span><span class="p">,</span><span class="mi">37</span>
	<span class="n">j</span> <span class="k">exit</span>
    

</code></pre></div></div>

<h3 id="task-5-matrix-multiplication">Task 5: Matrix Multiplication</h3>
<h4 id="concept-3">Concept</h4>

<p>这一节需要我们用汇编实现矩阵乘法。</p>

<p>对于一个矩阵而言，我们完全可以把它看作一个数组，只不过是会根据横向和纵向决定其排列顺序。</p>

<p><img src="../../assets/images/image-20221013155628163.png" alt="image-20221013155628163" /></p>

<p><img src="../../assets/images/image-20221007211215736.png" alt="image-20221007211215736" /></p>

<p>如上图，我们把矩阵看作一个数组，每轮矩阵相乘可以看作一次 dot 运算（见上一节），其中 a2 为 a0 的列和 a1 的行，a3 为 1，a4 为 a1 的行（说起来有些抽象，画个图能很好理解）。</p>

<p>这样我们可以通过两层循环来进行计算，每轮调用一次 <code class="language-plaintext highlighter-rouge">dot</code> 函数，再根据具体情况对数组进行偏移。</p>

<p>需要注意的是在调用外部函数之前，我们需要保存 temp 寄存器和 a 寄存器的一些值以防。</p>

<h4 id="code-3">Code</h4>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mf">.</span><span class="n">globl</span> <span class="n">matmul</span>
<span class="mf">.</span><span class="n">text</span>
<span class="c1"># =======================================================</span>
<span class="c1"># FUNCTION: Matrix Multiplication of 2 integer matrices</span>
<span class="c1">#   d = matmul(m0, m1)</span>
<span class="c1"># Arguments:</span>
<span class="c1">#   a0 (int*)  is the pointer to the start of m0</span>
<span class="c1">#   a1 (int)   is the # of rows (height) of m0</span>
<span class="c1">#   a2 (int)   is the # of columns (width) of m0</span>
<span class="c1">#   a3 (int*)  is the pointer to the start of m1</span>
<span class="c1">#   a4 (int)   is the # of rows (height) of m1</span>
<span class="c1">#   a5 (int)   is the # of columns (width) of m1</span>
<span class="c1">#   a6 (int*)  is the pointer to the the start of d</span>
<span class="c1"># Returns:</span>
<span class="c1">#   None (void), sets d = matmul(m0, m1)</span>
<span class="c1"># Exceptions:</span>
<span class="c1">#   Make sure to check in top to bottom order!</span>
<span class="c1">#   - If the dimensions of m0 do not make sense,</span>
<span class="c1">#     this function terminates the program with exit code 38</span>
<span class="c1">#   - If the dimensions of m1 do not make sense,</span>
<span class="c1">#     this function terminates the program with exit code 38</span>
<span class="c1">#   - If the dimensions of m0 and m1 don't match,</span>
<span class="c1">#     this function terminates the program with exit code 38</span>
<span class="c1"># =======================================================</span>
<span class="n">matmul</span><span class="o">:</span>

	<span class="c1"># Error checks</span>
   <span class="n">li</span> <span class="n">t0</span><span class="p">,</span><span class="mi">1</span>
   <span class="n">blt</span> <span class="n">a1</span><span class="p">,</span><span class="n">t0</span><span class="p">,</span><span class="n">error</span>
   <span class="n">blt</span> <span class="n">a2</span><span class="p">,</span><span class="n">t0</span><span class="p">,</span><span class="n">error</span>
   <span class="n">blt</span> <span class="n">a4</span><span class="p">,</span><span class="n">t0</span><span class="p">,</span><span class="n">error</span>
   <span class="n">blt</span> <span class="n">a5</span><span class="p">,</span><span class="n">t0</span><span class="p">,</span><span class="n">error</span>
   <span class="n">bne</span> <span class="n">a2</span><span class="p">,</span><span class="n">a4</span><span class="p">,</span><span class="n">error</span>

	<span class="c1"># Prologue</span>
    <span class="n">li</span> <span class="n">t0</span><span class="p">,</span><span class="mi">0</span>       <span class="c1"># t0 for all loop count </span>

<span class="n">outer_loop_start</span><span class="o">:</span>
    <span class="c1">#init</span>
    <span class="n">li</span> <span class="n">t1</span><span class="p">,</span><span class="mi">0</span>       <span class="c1"># t1 for outer_loop count</span>

<span class="n">outer_loop</span><span class="o">:</span>
    <span class="n">beq</span> <span class="n">t1</span><span class="p">,</span><span class="n">a1</span><span class="p">,</span><span class="n">outer_loop_end</span>

<span class="n">inner_loop_start</span><span class="o">:</span>
    <span class="c1">#init </span>
    <span class="n">li</span> <span class="n">t2</span><span class="p">,</span><span class="mi">0</span>       <span class="c1"># t2 for inner_loop count </span>
    <span class="n">mv</span> <span class="n">t4</span><span class="p">,</span><span class="n">a3</span>      <span class="c1"># t4 = &amp;a3</span>
<span class="n">inner_loop</span><span class="o">:</span>
    <span class="n">beq</span> <span class="n">t2</span><span class="p">,</span><span class="n">a5</span><span class="p">,</span><span class="n">inner_loop_end</span>
    <span class="n">addi</span> <span class="n">sp</span><span class="p">,</span><span class="n">sp</span><span class="p">,</span><span class="o">-</span><span class="mi">52</span>
    <span class="n">sw</span> <span class="n">ra</span><span class="p">,</span><span class="mi">0</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
    <span class="n">sw</span> <span class="n">a0</span><span class="p">,</span><span class="mi">4</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
    <span class="n">sw</span> <span class="n">a1</span><span class="p">,</span><span class="mi">8</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
    <span class="n">sw</span> <span class="n">a2</span><span class="p">,</span><span class="mi">12</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
    <span class="n">sw</span> <span class="n">a3</span><span class="p">,</span><span class="mi">16</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
    <span class="n">sw</span> <span class="n">a4</span><span class="p">,</span><span class="mi">20</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
    <span class="n">sw</span> <span class="n">a5</span><span class="p">,</span><span class="mi">24</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
    <span class="n">sw</span> <span class="n">t0</span><span class="p">,</span><span class="mi">28</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
    <span class="n">sw</span> <span class="n">t1</span><span class="p">,</span><span class="mi">32</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
    <span class="n">sw</span> <span class="n">t2</span><span class="p">,</span><span class="mi">36</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
    <span class="n">sw</span> <span class="n">t3</span><span class="p">,</span><span class="mi">40</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
    <span class="n">sw</span> <span class="n">t4</span><span class="p">,</span><span class="mi">44</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
    <span class="n">sw</span> <span class="n">a6</span><span class="p">,</span><span class="mi">48</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
    <span class="n">mv</span> <span class="n">a1</span><span class="p">,</span><span class="n">t4</span>
    <span class="n">li</span> <span class="n">a3</span><span class="p">,</span><span class="mi">1</span>
    <span class="n">mv</span> <span class="n">a4</span><span class="p">,</span><span class="n">a5</span>
    <span class="n">jal</span> <span class="n">ra</span><span class="p">,</span><span class="n">dot</span>    <span class="c1"># dot(a0,a3,a2,1,a5) </span>
    <span class="n">lw</span> <span class="n">t0</span><span class="p">,</span><span class="mi">28</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
    <span class="n">lw</span> <span class="n">a6</span><span class="p">,</span><span class="mi">48</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
    <span class="n">slli</span> <span class="n">t0</span><span class="p">,</span><span class="n">t0</span><span class="p">,</span><span class="mi">2</span>
    <span class="n">add</span> <span class="n">t3</span><span class="p">,</span><span class="n">a6</span><span class="p">,</span><span class="n">t0</span>  <span class="c1"># t3 = &amp;a6[t0]</span>
    <span class="n">sw</span> <span class="n">a0</span><span class="p">,</span><span class="mi">0</span><span class="p">(</span><span class="n">t3</span><span class="p">)</span>   <span class="c1"># a6[t0] = sum</span>
    <span class="n">srli</span> <span class="n">t0</span><span class="p">,</span><span class="n">t0</span><span class="p">,</span><span class="mi">2</span>
    <span class="n">lw</span> <span class="n">ra</span><span class="p">,</span><span class="mi">0</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
    <span class="n">lw</span> <span class="n">a0</span><span class="p">,</span><span class="mi">4</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
    <span class="n">lw</span> <span class="n">a1</span><span class="p">,</span><span class="mi">8</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
    <span class="n">lw</span> <span class="n">a2</span><span class="p">,</span><span class="mi">12</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
    <span class="n">lw</span> <span class="n">a3</span><span class="p">,</span><span class="mi">16</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
    <span class="n">lw</span> <span class="n">a4</span><span class="p">,</span><span class="mi">20</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
    <span class="n">lw</span> <span class="n">a5</span><span class="p">,</span><span class="mi">24</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
    <span class="n">lw</span> <span class="n">t1</span><span class="p">,</span><span class="mi">32</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
    <span class="n">lw</span> <span class="n">t2</span><span class="p">,</span><span class="mi">36</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
    <span class="n">lw</span> <span class="n">t3</span><span class="p">,</span><span class="mi">40</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
    <span class="n">lw</span> <span class="n">t4</span><span class="p">,</span><span class="mi">44</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
    <span class="n">addi</span> <span class="n">sp</span><span class="p">,</span><span class="n">sp</span><span class="p">,</span><span class="mi">52</span>
    <span class="n">addi</span> <span class="n">t0</span><span class="p">,</span><span class="n">t0</span><span class="p">,</span><span class="mi">1</span>
    <span class="n">addi</span> <span class="n">t2</span><span class="p">,</span><span class="n">t2</span><span class="p">,</span><span class="mi">1</span> 
    <span class="n">addi</span> <span class="n">t4</span><span class="p">,</span><span class="n">t4</span><span class="p">,</span><span class="mi">4</span>
    <span class="n">j</span> <span class="n">inner_loop</span> 
<span class="n">inner_loop_end</span><span class="o">:</span>
    <span class="n">slli</span> <span class="n">a2</span><span class="p">,</span><span class="n">a2</span><span class="p">,</span><span class="mi">2</span>
    <span class="n">add</span> <span class="n">a0</span><span class="p">,</span><span class="n">a0</span><span class="p">,</span><span class="n">a2</span>
    <span class="n">srli</span> <span class="n">a2</span><span class="p">,</span><span class="n">a2</span><span class="p">,</span><span class="mi">2</span>
    <span class="n">addi</span> <span class="n">t1</span><span class="p">,</span><span class="n">t1</span><span class="p">,</span><span class="mi">1</span>
    <span class="n">j</span> <span class="n">outer_loop</span> 

<span class="n">outer_loop_end</span><span class="o">:</span>
	<span class="n">ret</span>
<span class="n">error</span><span class="o">:</span>
    <span class="n">li</span> <span class="n">a0</span><span class="p">,</span><span class="mi">38</span>
    <span class="n">j</span> <span class="k">exit</span>
</code></pre></div></div>

<h3 id="task-6-testing">Task 6: Testing</h3>

<p>这一节和之前相反，是给出了我们汇编代码，需要我们阅读之前的 test framework 来编写 python 调用 asm 的测试用例。</p>

<h2 id="part-b">Part B</h2>

<p>Part B 主要设计一些对文件读写的操作，</p>

<h3 id="task-7-read-matrix">Task 7: Read Matrix</h3>

<p>​	从前面几个小节我们知道，矩阵可以用数组的形式存储，只是我们需要提前给出行列值。下图为一个矩阵在文件中以16进制打开的形式，其中第一个字节为行数，第二个字节为列数：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>🌀  read-matrix-1 <span class="o">[</span>main] ⚡  xxd <span class="nt">-e</span> input.bin 
00000000: 00000003 00000003 00000001 00000002  ................
00000010: 00000003 00000004 00000005 00000006  ................
00000020: 00000007 00000008 00000009           ............
</code></pre></div></div>

<p><a href="https://inst.eecs.berkeley.edu/~cs61c/sp22/projects/proj2/function-definitions/">Appendix</a> 里有我们可能需要调用函数的全部 api ，对着写即可：</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mf">.</span><span class="n">globl</span> <span class="n">read_matrix</span>

<span class="mf">.</span><span class="n">text</span>
<span class="c1"># ==============================================================================</span>
<span class="c1"># FUNCTION: Allocates memory and reads in a binary file as a matrix of integers</span>
<span class="c1">#
# FILE FORMAT:</span>
<span class="c1">#   The first 8 bytes are two 4 byte ints representing the # of rows and columns</span>
<span class="c1">#   in the matrix. Every 4 bytes afterwards is an element of the matrix in</span>
<span class="c1">#   row-major order.</span>
<span class="c1"># Arguments:</span>
<span class="c1">#   a0 (char*) is the pointer to string representing the filename</span>
<span class="c1">#   a1 (int*)  is a pointer to an integer, we will set it to the number of rows</span>
<span class="c1">#   a2 (int*)  is a pointer to an integer, we will set it to the number of columns</span>
<span class="c1"># Returns:</span>
<span class="c1">#   a0 (int*)  is the pointer to the matrix in memory</span>
<span class="c1"># Exceptions:</span>
<span class="c1">#   - If malloc returns an error,</span>
<span class="c1">#     this function terminates the program with error code 26</span>
<span class="c1">#   - If you receive an fopen error or eof,</span>
<span class="c1">#     this function terminates the program with error code 27</span>
<span class="c1">#   - If you receive an fclose error or eof,</span>
<span class="c1">#     this function terminates the program with error code 28</span>
<span class="c1">#   - If you receive an fread error or eof,</span>
<span class="c1">#     this function terminates the program with error code 29</span>
<span class="c1"># ==============================================================================</span>
<span class="n">read_matrix</span><span class="o">:</span>

	<span class="c1"># Prologue</span>
	<span class="n">addi</span> <span class="n">sp</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span>
	<span class="n">sw</span> <span class="n">ra</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span> 
	<span class="n">sw</span> <span class="n">s0</span><span class="p">,</span> <span class="mi">4</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
	<span class="n">sw</span> <span class="n">s1</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>  <span class="c1"># store the rows</span>
	<span class="n">sw</span> <span class="n">s2</span><span class="p">,</span><span class="mi">12</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>  <span class="c1"># store the columns</span>
	<span class="n">sw</span> <span class="n">s3</span><span class="p">,</span><span class="mi">16</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
		
	<span class="c1"># Epilogue</span>
	<span class="n">mv</span> <span class="n">s1</span><span class="p">,</span><span class="n">a1</span>
	<span class="n">mv</span> <span class="n">s2</span><span class="p">,</span><span class="n">a2</span>
	<span class="n">li</span> <span class="n">a1</span><span class="p">,</span><span class="mi">0</span>    <span class="c1">#only-read</span>
	<span class="n">jal</span> <span class="n">ra</span><span class="p">,</span><span class="n">fopen</span>
	<span class="n">li</span> <span class="n">t0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span>
	<span class="n">beq</span> <span class="n">a0</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">fopen_error</span> <span class="c1"># if a0 == t0 then fopen_error</span>
	
	<span class="c1">#read the rows</span>
	<span class="n">mv</span> <span class="n">s0</span><span class="p">,</span><span class="n">a0</span>   <span class="c1">#store the file descriptor </span>
	<span class="n">mv</span> <span class="n">a1</span><span class="p">,</span><span class="n">s1</span>
	<span class="n">li</span> <span class="n">a2</span><span class="p">,</span><span class="mi">4</span>
	<span class="n">mv</span> <span class="n">s3</span><span class="p">,</span><span class="n">a2</span>
	<span class="n">jal</span> <span class="n">ra</span><span class="p">,</span><span class="n">fread</span>
	<span class="n">bne</span> <span class="n">s3</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="n">fread_error</span> <span class="c1"># if a2 != t0 then fread_error</span>

	<span class="c1">#read the columns</span>
	<span class="n">mv</span> <span class="n">a0</span><span class="p">,</span><span class="n">s0</span>   <span class="c1">#restore the file descriptor </span>
	<span class="n">mv</span> <span class="n">a1</span><span class="p">,</span><span class="n">s2</span>
	<span class="n">li</span> <span class="n">a2</span><span class="p">,</span><span class="mi">4</span>
	<span class="n">mv</span> <span class="n">s3</span><span class="p">,</span><span class="n">a2</span> 
	<span class="n">jal</span> <span class="n">ra</span><span class="p">,</span><span class="n">fread</span>
	<span class="n">bne</span> <span class="n">s3</span><span class="p">,</span><span class="n">a0</span><span class="p">,</span> <span class="n">fread_error</span> <span class="c1"># if a2 != t0 then fread_error</span>

	<span class="n">lw</span> <span class="n">t1</span><span class="p">,</span><span class="mi">0</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>   <span class="c1"># rows</span>
	<span class="n">lw</span> <span class="n">t2</span><span class="p">,</span><span class="mi">0</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>   <span class="c1"># columns</span>
	<span class="n">mul</span> <span class="n">s1</span><span class="p">,</span><span class="n">t1</span><span class="p">,</span><span class="n">t2</span> 
	<span class="n">slli</span> <span class="n">s1</span><span class="p">,</span><span class="n">s1</span><span class="p">,</span><span class="mi">2</span>  <span class="c1"># the size of the memory to be allocated </span>

	<span class="n">mv</span> <span class="n">a0</span><span class="p">,</span><span class="n">s1</span>
	<span class="n">jal</span> <span class="n">ra</span><span class="p">,</span><span class="n">malloc</span>
	<span class="n">li</span> <span class="n">t0</span><span class="p">,</span><span class="mi">0</span>
	<span class="n">beq</span> <span class="n">a0</span><span class="p">,</span><span class="n">t0</span><span class="p">,</span><span class="n">malloc_error</span>

	<span class="n">mv</span> <span class="n">s2</span><span class="p">,</span><span class="n">a0</span>
	<span class="n">mv</span> <span class="n">a1</span><span class="p">,</span><span class="n">s2</span>
	<span class="n">mv</span> <span class="n">a0</span><span class="p">,</span><span class="n">s0</span>
	<span class="n">mv</span> <span class="n">a2</span><span class="p">,</span><span class="n">s1</span>
	<span class="n">jal</span> <span class="n">ra</span><span class="p">,</span><span class="n">fread</span>
	<span class="n">bne</span> <span class="n">s1</span><span class="p">,</span><span class="n">a0</span><span class="p">,</span><span class="n">fread_error</span>

	<span class="n">mv</span> <span class="n">a0</span><span class="p">,</span><span class="n">s0</span>
	<span class="n">jal</span> <span class="n">ra</span><span class="p">,</span><span class="n">fclose</span>
	<span class="n">bnez</span> <span class="n">a0</span><span class="p">,</span><span class="n">fclose_error</span>
	<span class="n">mv</span> <span class="n">a0</span><span class="p">,</span><span class="n">s2</span>

	<span class="n">lw</span> <span class="n">ra</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span> 
	<span class="n">lw</span> <span class="n">s0</span><span class="p">,</span> <span class="mi">4</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
	<span class="n">lw</span> <span class="n">s1</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>  
	<span class="n">lw</span> <span class="n">s2</span><span class="p">,</span><span class="mi">12</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span> 
	<span class="n">lw</span> <span class="n">s3</span><span class="p">,</span><span class="mi">16</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
	<span class="n">addi</span> <span class="n">sp</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="mi">20</span>

	<span class="n">ret</span>

<span class="n">fopen_error</span><span class="o">:</span>
	<span class="n">li</span> <span class="n">a0</span><span class="p">,</span> <span class="mi">27</span>
	<span class="n">j</span> <span class="k">exit</span>

<span class="n">fread_error</span><span class="o">:</span>
	<span class="n">li</span> <span class="n">a0</span><span class="p">,</span> <span class="mi">29</span>
	<span class="n">j</span> <span class="k">exit</span>

<span class="n">malloc_error</span><span class="o">:</span>
	<span class="n">li</span> <span class="n">a0</span><span class="p">,</span> <span class="mi">26</span>
	<span class="n">j</span> <span class="k">exit</span>

<span class="n">fclose_error</span><span class="o">:</span>
	<span class="n">li</span> <span class="n">a0</span><span class="p">,</span> <span class="mi">28</span>
	<span class="n">j</span> <span class="k">exit</span>
</code></pre></div></div>

<h3 id="task-8-write-matrix">Task 8: Write Matrix</h3>

<p>这一节和上节差不多，只是从读变成了写</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mf">.</span><span class="n">globl</span> <span class="n">write_matrix</span>

<span class="mf">.</span><span class="n">text</span>
<span class="c1"># ==============================================================================</span>
<span class="c1"># FUNCTION: Writes a matrix of integers into a binary file</span>
<span class="c1"># FILE FORMAT:</span>
<span class="c1">#   The first 8 bytes of the file will be two 4 byte ints representing the</span>
<span class="c1">#   numbers of rows and columns respectively. Every 4 bytes thereafter is an</span>
<span class="c1">#   element of the matrix in row-major order.</span>
<span class="c1"># Arguments:</span>
<span class="c1">#   a0 (char*) is the pointer to string representing the filename</span>
<span class="c1">#   a1 (int*)  is the pointer to the start of the matrix in memory</span>
<span class="c1">#   a2 (int)   is the number of rows in the matrix</span>
<span class="c1">#   a3 (int)   is the number of columns in the matrix</span>
<span class="c1"># Returns:</span>
<span class="c1">#   None</span>
<span class="c1"># Exceptions:</span>
<span class="c1">#   - If you receive an fopen error or eof,</span>
<span class="c1">#     this function terminates the program with error code 27</span>
<span class="c1">#   - If you receive an fclose error or eof,</span>
<span class="c1">#     this function terminates the program with error code 28</span>
<span class="c1">#   - If you receive an fwrite error or eof,</span>
<span class="c1">#     this function terminates the program with error code 30</span>
<span class="c1"># ==============================================================================</span>
<span class="n">write_matrix</span><span class="o">:</span>

	<span class="c1"># Prologue</span>
	<span class="n">addi</span> <span class="n">sp</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="o">-</span><span class="mi">24</span>
	<span class="n">sw</span> <span class="n">ra</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span> 
	<span class="n">sw</span> <span class="n">s0</span><span class="p">,</span> <span class="mi">4</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
	<span class="n">sw</span> <span class="n">s1</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span> 
	<span class="n">sw</span> <span class="n">s2</span><span class="p">,</span><span class="mi">12</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>  
	<span class="n">sw</span> <span class="n">s3</span><span class="p">,</span><span class="mi">16</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
	<span class="n">sw</span> <span class="n">s4</span><span class="p">,</span><span class="mi">20</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>

	<span class="c1"># Epilogue</span>
	<span class="n">mv</span> <span class="n">s1</span><span class="p">,</span><span class="n">a1</span>    <span class="c1">#pointer to matrix</span>
	<span class="n">mv</span> <span class="n">s2</span><span class="p">,</span><span class="n">a2</span>    <span class="c1">#rows</span>
	<span class="n">mv</span> <span class="n">s3</span><span class="p">,</span><span class="n">a3</span>    <span class="c1">#columns</span>
	<span class="n">li</span> <span class="n">a1</span><span class="p">,</span><span class="mi">1</span>     <span class="c1">#write</span>
	<span class="n">jal</span> <span class="n">ra</span><span class="p">,</span><span class="n">fopen</span>
	<span class="n">li</span> <span class="n">t0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span>
	<span class="n">beq</span> <span class="n">a0</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">fopen_error</span>
	<span class="n">mv</span> <span class="n">s0</span><span class="p">,</span><span class="n">a0</span>

	<span class="n">li</span> <span class="n">a0</span><span class="p">,</span><span class="mi">8</span>
	<span class="n">jal</span> <span class="n">ra</span><span class="p">,</span><span class="n">malloc</span>
	<span class="n">beqz</span> <span class="n">a0</span><span class="p">,</span><span class="n">malloc_error</span>

	<span class="c1">#write the rows and columns</span>
	<span class="n">mv</span> <span class="n">s4</span><span class="p">,</span><span class="n">a0</span>
	<span class="n">sw</span> <span class="n">s2</span><span class="p">,</span><span class="mi">0</span><span class="p">(</span><span class="n">s4</span><span class="p">)</span>
	<span class="n">sw</span> <span class="n">s3</span><span class="p">,</span><span class="mi">4</span><span class="p">(</span><span class="n">s4</span><span class="p">)</span>
	<span class="n">mv</span> <span class="n">a1</span><span class="p">,</span><span class="n">s4</span>
	<span class="n">mv</span> <span class="n">a0</span><span class="p">,</span><span class="n">s0</span>
	<span class="n">li</span> <span class="n">a2</span><span class="p">,</span><span class="mi">2</span>
	<span class="n">mv</span> <span class="n">s4</span><span class="p">,</span><span class="n">a2</span>
	<span class="n">li</span> <span class="n">a3</span><span class="p">,</span><span class="mi">4</span>
	<span class="n">jal</span> <span class="n">ra</span><span class="p">,</span><span class="n">fwrite</span>
	<span class="n">bne</span> <span class="n">a0</span><span class="p">,</span><span class="n">s4</span><span class="p">,</span><span class="n">fwrite_error</span>

	<span class="n">mv</span> <span class="n">a0</span><span class="p">,</span><span class="n">s0</span>
	<span class="n">mv</span> <span class="n">a1</span><span class="p">,</span><span class="n">s1</span>
	<span class="n">mul</span> <span class="n">a2</span><span class="p">,</span><span class="n">s2</span><span class="p">,</span><span class="n">s3</span>
	<span class="n">mv</span> <span class="n">s4</span><span class="p">,</span><span class="n">a2</span>
	<span class="n">li</span> <span class="n">a3</span><span class="p">,</span><span class="mi">4</span>
	<span class="n">jal</span> <span class="n">ra</span><span class="p">,</span><span class="n">fwrite</span>
	<span class="n">bne</span> <span class="n">a0</span><span class="p">,</span><span class="n">s4</span><span class="p">,</span><span class="n">fwrite_error</span>

	<span class="n">mv</span> <span class="n">a0</span><span class="p">,</span><span class="n">s0</span>
	<span class="n">jal</span> <span class="n">ra</span><span class="p">,</span><span class="n">fclose</span>
	<span class="n">bnez</span> <span class="n">a0</span><span class="p">,</span><span class="n">fclose_error</span>

	<span class="n">lw</span> <span class="n">ra</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span> 
	<span class="n">lw</span> <span class="n">s0</span><span class="p">,</span> <span class="mi">4</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
	<span class="n">lw</span> <span class="n">s1</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>  
	<span class="n">lw</span> <span class="n">s2</span><span class="p">,</span><span class="mi">12</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span> 
	<span class="n">lw</span> <span class="n">s3</span><span class="p">,</span><span class="mi">16</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
	<span class="n">lw</span> <span class="n">s4</span><span class="p">,</span><span class="mi">20</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
	<span class="n">addi</span> <span class="n">sp</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="mi">24</span>
	<span class="n">ret</span>

<span class="n">malloc_error</span><span class="o">:</span>
	<span class="n">li</span> <span class="n">a0</span><span class="p">,</span> <span class="mi">26</span>
	<span class="n">j</span> <span class="k">exit</span>
<span class="n">fopen_error</span><span class="o">:</span>
	<span class="n">li</span> <span class="n">a0</span><span class="p">,</span> <span class="mi">27</span>
	<span class="n">j</span> <span class="k">exit</span>

<span class="n">fclose_error</span><span class="o">:</span>
	<span class="n">li</span> <span class="n">a0</span><span class="p">,</span> <span class="mi">28</span>
	<span class="n">j</span> <span class="k">exit</span>

<span class="n">fwrite_error</span><span class="o">:</span>
	<span class="n">li</span> <span class="n">a0</span><span class="p">,</span> <span class="mi">30</span>
	<span class="n">j</span> <span class="k">exit</span>
</code></pre></div></div>]]></content><author><name>Theoyu</name></author><category term="cource" /><category term="cource" /><category term="CS61C" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">『 CMU-15445 』课程小结</title><link href="http://localhost:4000/2022/cource/15445_notes" rel="alternate" type="text/html" title="『 CMU-15445 』课程小结" /><published>2022-08-30T00:00:00+08:00</published><updated>2022-08-30T00:00:00+08:00</updated><id>http://localhost:4000/2022/cource/15445_notes</id><content type="html" xml:base="http://localhost:4000/2022/cource/15445_notes"><![CDATA[<!--more-->

<p>我的学习顺序，快速过一遍 Notes，了解一下这一节的大纲和重点，之后根据自己的能力选择是看视频还是直接看 slides（并发控制之前的章节难度还 ok ），学习完一章后，尝试用自己的话把一章的重点梳理一遍，最后选择性阅读帆船书。</p>

<p>以下内容为我归纳整理的一些问答式：</p>

<pre><code class="language-txt">1. 为什么不使用 OS 自带的磁盘管理模块 （mmap）？
2. 存储模型 N-Ary Storage Model (NSM) 和 Decomposition Storage Model (DSM) 的优缺性？
3. 为什么会有 buffer pool？
4. buffer pool 可以做哪些优化？
5. 为什么数据库BUFFER POOL需要LRU-K的策略？
6. 有哪一些哈希方案？
7. 是否当有节点不到 half-full，就 MERGE 节点？
8. B+ 树的优化
9. B+树的 Latch Crabbing 是什么？
10. Lock 和 Latch 的区别是什么？
11. 108个页，内存 buffer pools 中只能容下5个页，怎么利用 General (K-way) Merge Sort 做外部排序？
12. 有哪一些做 aggregation（聚集）的方案？
13. join算法有哪些？以下述例子分析复杂的：
14. 有哪一些数据库执行模型？
15. 有哪一些数据读取的方法？
16. 单个 Intra-Query 如何做并行？
17. 谈一谈数据库执行的逻辑优化和物理优化？
18. 简单介绍一下ACID？
19. 如何判断事务的执行顺序（schedule）是否与其串行执行（serial）等价？
20. 什么是 View Serializability？
21. 什么是两阶段锁？如何解决集联中止和死锁的问题？
22. 什么是 LOCK GRANULARITIES ，为什么要这么设计？
23. 如何基于时间戳进行并发控制？
24. 并行事务可能出现怎样的问题？事务有哪几种隔离级别，有什么特点及其实现？
25. MVCC 设计需要考虑哪几个方面？
26. 能否不使用 LOG 实现 undo 和 redo？
27. 什么是 WAL？
</code></pre>

<ol>
  <li>
    <p>为什么不使用 OS 自带的磁盘管理模块 （mmap）？</p>

    <blockquote>
      <p>if i die in this class , you  want to have a memorial something just Say Andy hated mmap</p>
    </blockquote>

    <p>Andy专门写了一篇论文批判不应该在数据库中使用 mmap ：<a href="https://db.cs.cmu.edu/mmap-cidr2022/">Are You Sure You Want to Use MMAP in Your Database Management System? (CIDR 2022)</a></p>

    <p>简单来说作为底层的操作系统，他只能看到毫无规律的读取和调用，而 DBMS 希望自己拥有足够的控制权。</p>
  </li>
  <li>
    <p>存储模型 N-Ary Storage Model (NSM) 和 Decomposition Storage Model (DSM) 的优缺性？</p>
  </li>
  <li>
    <p>为什么会有 buffer pool？</p>

    <p>优点：内存速度大于磁盘</p>

    <p>缺点：命中率很低，刷新很快 -&gt;  BUFFER POOL BYPASS</p>

    <p>把一些查询不放入buffer pool中</p>
  </li>
  <li>
    <p>buffer pool 可以做哪些优化？</p>

    <ol>
      <li>MULTIPLE BUFFER POOLS</li>
      <li>PRE-FETCHING</li>
      <li>SCAN SHARING</li>
      <li>BUFFER POOL BYPASS</li>
    </ol>
  </li>
  <li>
    <p>为什么数据库BUFFER POOL需要LRU-K的策略？</p>

    <p>LRU ( Least Recently Used )：最近最久未使用，防止了SEQUENTIAL FLOODING，提高了命中率。</p>
  </li>
  <li>
    <p>有哪一些哈希方案？</p>

    <ul>
      <li>
        <p>静态哈希方案：</p>

        <ul>
          <li>
            <p>Linear Probe Hashing</p>

            <p>线性探测法是开放寻址法（Open Addressing）中的一种，插入元素时，若存在哈希冲突，则往后顺移，直到找到一个空的位置。</p>

            <p>线性探测法会导致<strong>同类哈希的聚集 (Primary Clustering)</strong>。</p>
          </li>
          <li>
            <p>Robin Hood Hashing</p>

            <p>罗宾汉是英国民间传说中的英雄人物，劫富济贫，整治暴戾。罗宾汉哈希是线性探测法的拓展，传统的线性探测只是无条件的顺移，而罗宾汉哈希会记录每个键离本来应该插入的位置的距离，当有新的键冲突，往后顺移的同时会比较冲突位置 key 的距离和自身距离的大小，如果自身的距离已经超过冲突的位置 key 的距离，则选择替换该项，顺移被替换的 key 。</p>

            <p><img src="../../assets/images/image-20220726141842367.png" alt="image-20220726141842367" /></p>

            <p>罗宾汉哈希可以显著降低探测长度的<strong>方差</strong>，把 <strong>rich</strong> key 的位置交给  <strong>poor</strong> key，从而使大部分元素的探测长度趋于平均值。但是每次 insert 时又增加了新的比对开销，这是不可避免的。</p>
          </li>
          <li>
            <p>Cuckoo Hashing</p>

            <p>Cuckoo Hashing 采用多个 hash table，每个 hash table 都采用不同的 hash function seed 。</p>

            <p>对于任何一个 key ，都可以选择其中一个没有冲突 hash table 插入，若全部 hash table 都没有空的位置，则随机选择一个 hash table 中对应的位置插入，并取出原来这位置上的 key 重新插入。</p>

            <p>在容量不够的情况下，连锁的冲突可能会导致死循环，解决办法只能扩容然后 rehash。</p>
          </li>
        </ul>
      </li>
      <li>
        <p>动态哈希方案</p>

        <ul>
          <li>
            <p>Chained Hashing</p>

            <p>每个 slot 维护一个  linked list，对于冲突的哈希则直接追加到链表后面。</p>

            <p>如果数据很大链表过长，时间复杂度又退回到 O (n)，我们内部会维护一个负载因子（最长链表长度 / slot 个数），当负载因子达到某个阈值便扩容 slot 并 rehash。</p>
          </li>
          <li>
            <p>Extendible Hashing</p>

            <p>简单来说 Extendible Hashing = Hash + Trie( 字典树 )</p>

            <p><img src="../../assets/images/image-20220726142640107.png" alt="image-20220726142640107" /></p>

            <p>Extendible Hashing 会在 project 2 中实现，详细请见：</p>
          </li>
          <li>
            <p>Linear Hashing</p>

            <p>http://queper.in/drupal/blogs/dbsys/linear_hashing</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>是否当有节点不到 half-full，就 MERGE 节点？</p>

    <p>MERGE  有一定的开销，可以先把该节点保存，然后过一段时间周期性的批量处理这些节点（重新建树）。</p>
  </li>
  <li>
    <p>B+ 树的优化</p>

    <ol>
      <li>
        <p>Prefix Compression 前缀压缩</p>

        <p>在同一个叶子节点上，如果 key 有共同的前缀，可以提取出来节省空间。</p>
      </li>
      <li>
        <p>Suffix Truncation 后缀截断</p>

        <p>对于内部节点，如果前面的数据就足够做 ROUTE ，后面的数据没有区分度，那么就可以把没有帮助的部分截断。</p>
      </li>
      <li>
        <p>Bulk Insert</p>

        <p>在构建一棵 B+ 树时，如果逐个插入节点可能会比较慢，Bulk Insert 就是先对 key 排序，然后自底向上先生成叶子节点，再根据叶子节点形成内部节点。Bulk Insert 让我们能更快去构建一棵 B+ Tree。</p>
      </li>
      <li>
        <p>Pointer Swizzling</p>
      </li>
    </ol>
  </li>
  <li>
    <p>B+树的 Latch Crabbing 是什么？</p>

    <p>因为 B+树会经常涉及到分离和归并，所以我们需要严格进行锁处理。</p>

    <p>我们从上到下先拿到父 latch，再拿到孩子的 latch：</p>

    <ul>
      <li>针对于 read 的情况，只要拿到孩子的读锁，就可以把祖先们的读锁给解开。</li>
      <li>针对 insert 或 delete 的情况，如果孩子是 safe 的（比如 insert 不会导致分离，delete 不会导致归并），则可以把其祖先们的锁全部解开。</li>
    </ul>

    <p>上面这样有一个问题，我们发现根节点始终是一个上锁的状态，这样对效率的影响比较大。我们可以采取一个 『 乐观 』的态度，我们假设叶子节点都是安全的，所以无论是增还是删都先上读锁，等到具体情况如果发现并不安全，则重头再按照写锁的逻辑来一次。</p>
  </li>
  <li>
    <p>Lock 和 Latch 的区别是什么？</p>

    <p>Lock 是一个高级别，逻辑意义上的锁，一般特指事务锁，用于保护数据库内容免受其他 transactions 的影响 ，而且需要考虑一个事务回滚的问题。</p>

    <p>Latch 是一个低级别的锁，用于维护 DBMS 内部数据结构在多线程情况下安全读写，比如互斥锁 mutex。</p>
  </li>
  <li>
    <p>108个页，内存 buffer pools 中只能容下5个页，怎么利用 General (K-way) Merge Sort 做外部排序？</p>

    <ul>
      <li>第一轮：108个页每次放入5个页进行排序，排序后写入磁盘，这样会得到 108 /5 = 22 个排序文件。</li>
      <li>第二轮：buffer pools 的5个页4个页用作输入，1个页用作输出，从22个文件中选取4个做归并，最后得到 22 /4 =6个排序文件。</li>
      <li>第三轮：同上 buffer pools 的5个页4个页用作输入，1个页用作输出，得到 6/4 = 2个文件。</li>
      <li>第四轮：同上 得到一个有序文件。</li>
    </ul>
  </li>
  <li>
    <p>有哪一些做 aggregation（聚集）的方案？</p>

    <ol>
      <li>
        <p>排序聚集</p>

        <p>对于本身需要排序的例子（order by），先排序再去重。</p>
      </li>
      <li>
        <p>哈希聚集</p>

        <p>如果不需要排序（group by、distinct），再排序的话开销就会很大，这时候我们可以选择哈希聚集。</p>

        <p>外部哈希聚集（external hash agg）主要分为两部：</p>

        <ol>
          <li>Partition：通过 HASH$_1$，我们用1个把数据输出到磁盘</li>
          <li>ReHash</li>
        </ol>
      </li>
    </ol>
  </li>
  <li>
    <p>join算法有哪些？以下述例子分析复杂的：</p>

    <blockquote>
      <ul>
        <li>
          <p>M pages in table R (Outer Table), m tuples total</p>
        </li>
        <li>
          <p>N pages in table S (Inner Table), n tuples total</p>
        </li>
      </ul>
    </blockquote>

    <ol>
      <li>
        <p>Nested Loop Join</p>

        <ul>
          <li>
            <p>Simple Nested Loop Join (stupid)</p>

            <p>把外表的每一个元组和内表的元组进行比对。</p>

            <p>Cost：$M +(m×N)$</p>
          </li>
          <li>
            <p>Block Nested Loop Join</p>

            <p>利用 buffer pools  存储一个一个块扫描，假设buffer pools 容量为B</p>

            <p>Cost：$M+(\lceil \frac{M}{B-2}\rceil×N)$</p>
          </li>
          <li>
            <p>Index Nested Loop Join</p>

            <p>利用B+Tree索引</p>

            <p>Cost：$M +(m×C)$  C是一个常数</p>
          </li>
        </ul>
      </li>
      <li>
        <p>Sort-Merge Join</p>

        <p>先排序，再归并</p>

        <p>排序复杂度可见上面的 (K-way) Merge Sort</p>

        <ul>
          <li>Sort Cost for Table R：$2M×(1+\lceil\log_{B-1}\lceil \frac {M}{B} \rceil\rceil)$</li>
          <li>Sort Cost for Table S：$2N×(1+\lceil\log_{B-1}\lceil \frac {N}{B} \rceil\rceil)$</li>
          <li>Merge Cost: $(M+N)$</li>
        </ul>

        <p><strong>Total Cost: Sort + Merge</strong></p>
      </li>
      <li>
        <p>Hash Join</p>

        <p>把两个表数据做 Hash 然后存储到外部文件，再读取文件进行比对 join 连接。</p>

        <ul>
          <li>Partitioning Phase Cost: $2 × (M + N )$</li>
          <li>Probe Phase Cost: $(M + N )$</li>
        </ul>

        <p><strong>Total Cost: $3 × (M + N)$</strong></p>
      </li>
    </ol>
  </li>
  <li>
    <p>有哪一些数据库执行模型？</p>

    <ol>
      <li>
        <p>Iterator Model</p>

        <p>迭代器模型，又称为火山模型，每个关系函数都会调用自己的<code class="language-plaintext highlighter-rouge">next</code>方法直到有数据元组返回（整个调用过程有点像栈，先进后出，直到叶子节点返回数据，再一路回到顶，像火山的流动一样）。</p>

        <p><img src="../../assets/images/image-20220807235353723.png" alt="image-20220807235353723" /></p>

        <p>一些关系函数会堵塞，直到所有数据返回（比如 joins, subqueries, order by），也被称作  <em>pipeline breakers</em>.</p>
      </li>
      <li>
        <p>Materialization Model</p>

        <p>相比于火山模型流式的一条条返回和读取数据，物化模型会把所有数据全部打包好一次性返回。</p>

        <p><img src="../../assets/images/image-20220808101846497.png" alt="image-20220808101846497" /></p>
      </li>
      <li>
        <p>Vectorization Model</p>

        <p>向量化模型是以上两种模型的折中模型，其内部也实现了<code class="language-plaintext highlighter-rouge">next</code>方法，但是每个<code class="language-plaintext highlighter-rouge">next</code>方法返回的是一批数据而不是单个元组，自定义数据大小也避免了物化模型中数据量返回过大的可能。</p>

        <p><img src="../../assets/images/image-20220808102946859.png" alt="image-20220808102946859" /></p>
      </li>
    </ol>
  </li>
  <li>
    <p>有哪一些数据读取的方法？</p>

    <ol>
      <li>
        <p>Sequential Scan</p>

        <p>顺序扫描，或者说全表扫描。数据库维护一个扫描当前页的指针，顺序扫描有以下优化方法：</p>

        <ul>
          <li>
            <p>Prefetching</p>
          </li>
          <li>
            <p>Buffer Pool Bypass</p>

            <p>上面两种方法都是站在缓存池的角度，具体可以看 <code class="language-plaintext highlighter-rouge">6. buffer pool 可以做哪些优化？</code></p>
          </li>
          <li>
            <p>Parallelization</p>
          </li>
          <li>
            <p>Zone Map</p>

            <p>维护一个额外的分区表去缓存页信息，可以降低扫描时读取页面的总次数。</p>

            <p><img src="../../assets/images/image-20220808114454425.png" alt="image-20220808114454425" /></p>
          </li>
          <li>
            <p>Late Materialization</p>

            <p>延迟物化，即数据传递中，自底向上只传入一个关键信息（比如关键字段、偏移量等），需要用到具体数据时再获取全部的信息。此方法只在 DSM（列存储）中有效。</p>
          </li>
        </ul>
      </li>
      <li>
        <p>Index Scan</p>

        <p>优化器选择<strong>最合适的索引</strong>去扫描（该索引的选择率最高）。</p>

        <p>还有一种方式是采用 bitmap 多索引扫描，再根据具体语句选择交集或者并集。</p>
      </li>
    </ol>
  </li>
  <li>
    <p>单个 Intra-Query 如何做并行？</p>

    <ol>
      <li>
        <p>Intra-Operator Parallelism (Horizontal)</p>

        <p>算子内并行（水平切分），指把单个数据集拆分为多个单位，然后在数据子集上执行相同的函数，最后再利用<code class="language-plaintext highlighter-rouge">Exchange</code>操作进行合并。</p>
      </li>
      <li>
        <p>Inter-Operator Parallelism (Vertical)</p>

        <p>算子间并行（垂直切分），有一点像火山模型中的流式处理，</p>

        <p><img src="../../assets/images/image-20220811114914461.png" alt="image-20220811114914461" /></p>
      </li>
      <li>
        <p>Bushy Parallelism</p>

        <p>相当于水平切分+垂直切分，底层数据读取使用水平切分，数据往上传递使用垂直切分。</p>
      </li>
    </ol>
  </li>
  <li>
    <p>谈一谈数据库执行的逻辑优化和物理优化？</p>

    <p>逻辑优化是站在代数级别的，通常是通过一些静态规则和启发函数（<em>heuristics</em>），在代数等价的前提下对表达式进行优化，比如谓词下放、投影下放等优化。</p>

    <p>物理优化是站在开销的角度，这个开销可以指多方面，比如 CPU、Disk I/O、Memory、Network，然后在执行层进行等价优化，比如单个 join连接 有多种算法，单个数据读取有索引读取和全表读取，优化器就会根据具体的开销决定执行哪一种算法。最后再用动态规划确定整个执行的所有方式，如果需要 join 的表很多，动态规划的开销本身也很大，可以选择遗传算法的思想确定。</p>
  </li>
  <li>
    <p>简单介绍一下ACID？</p>

    <ul>
      <li>Atomicity：原子性，即事务中的所有操作要么全部执行，要不都不执行，原子性通常通过 Logging 的方式保证。</li>
      <li>Consistency：一致性，站在一个 high - level 的角度，事务执行前后的逻辑都是正确的。</li>
      <li>Isolation：隔离性，虽然事务是并行运行的，但是对站在单个事务的视角其互不影响，其通过并发控制保证。</li>
      <li>Durability：持久性，所有事务提交的数据不会丢失。</li>
    </ul>
  </li>
  <li>
    <p>如何判断事务的执行顺序（schedule）是否与其串行执行（serial）等价？</p>

    <p>如果 schedule 只有两个事务，可以交换事务间的非冲突操作（冲突指读写冲突、	写写冲突等），如果最终可以转换到 serial schedule（即一个事务的所有操作结束完再执行另外一个，而不是 interleave ），则说明这个 schedule 是可串行的（serializable）。</p>

    <p>如果 schedule 包含多个事务，可以用依赖图判断，如果一个来自事务 A 的操作和来自事务 B 的操作冲突，并且 A 先于 B 执行，则我们加一条从 A -&gt; B 的边，以此遍历，若最后依赖图有环，则说明此 schedule unserializable；若最后依赖图无环，则根据箭头顺序，可构造 serial schedule。</p>

    <p><img src="../../assets/images/image-20220828213351195.png" alt="image-20220828213351195" /></p>
  </li>
  <li>
    <p>什么是 View Serializability？</p>

    <p>上述我们判断是否可串行化，是通过冲突判断的，但是这样有弊端，因为有的事务具体的执行之间即使发生冲突，也不会影响最终结果，我们认为这两者还是可以调度的，这是基于观察的判断，比基于冲突更加缓和一些。这是一种理想化的判断，可以作为是否可串行化的标准，但是很难实现。</p>
  </li>
  <li>
    <p>什么是两阶段锁？如何解决集联中止和死锁的问题？</p>

    <p>两段锁协议 2PL（two-Parse-locking）指一个事务分为 <strong>Growing</strong> 和 <strong>Shrinking</strong> 两个阶段，第一个阶段事务所有操作申请锁，从一个锁释放开始进入第二个阶段，事务只能释放锁不能再申请。2PL 解决了一致性的问题（某个事物对多个变量操作，不会被其他事务所 interleave）：</p>

    <p><img src="../../assets/images/image-20220829093451882.png" alt="image-20220829093451882" /></p>

    <p>但是 2PL 还是有两个问题需要解决，一个是 cascading aborts ，如果事务 T2 读取了事务 T1 的某个中间状态，但是事务 T1 最后没有 commit 而是 abort，那么事务 T2 也应该回滚。解决的办法是采用 <em>Strong Strict 2PL</em>，即事务只有在最后时刻（commit、abort）才会一同释放锁，这是一种更加悲观的决定，也限制了并发。</p>

    <p>还有一个问题就是死锁，上面这张图中的 T2 事务，如果先申请 B 的锁再申请 A，就会导致 T1 申请 B时被锁住，导致死锁。</p>

    <p>站在死锁检测（<em>Detection</em>）的角度，我们创建一个锁依赖图，如果存在 T1 事务申请锁被 T2 事务堵塞的情况，则绘制一条从 T1 到 T2 的边，如果依赖图成环，则表明存在死锁，我们需要选取一名 <em>victim</em> 事务，对它进行 abort 或者 recommit，以打破死锁。<em>victim</em> 的选择需要考虑多方面，比如已经开始的时间、已经执行的操作、多少事务需要被回滚等等。</p>

    <p>死锁检测是已经发生死锁后再进行处理，死锁预防（<em>Prevention</em>）是在死锁发生前 kill 一个事务，我们给事务定义一个优先级，在这里我们认为决定因素是起始时间，开始早的为 old，晚的为 young</p>

    <ul>
      <li>
        <p>Wait-Die (“Old Waits for Young”)：如果是新事务占有，老事务申请，则选择等待；反之老事务占有，新事务申请，则新事物直接 abort 。（碰瓷）</p>
      </li>
      <li>
        <p>Wound-Wait (“Young Waits for Old”)：如果是新事物占有，老事务申请，则新事物直接 abort，老事务占有锁（抢过来），反之选择等待。</p>

        <p><img src="../../assets/images/image-20220829181531617.png" alt="image-20220829181531617" /></p>
      </li>
    </ul>

    <p>还需要注意一点，一个事务如果 abort，begin 时间应该不能改变，不然很有可能导致饥饿。</p>
  </li>
  <li>
    <p>什么是 <em>LOCK GRANULARITIES</em> ，为什么要这么设计？</p>

    <p>假设一个表有 100 行数据，我们需要更新里面所有的数据，我们可能需要 100 把锁。所以我们需要引入锁的粒度，也叫 <em>Hierarchical locks</em>（分层锁协议）。 锁可以是面向 Page 的，也可以是面向 Table，再往小还有 Tuple，如果我们往低级别上锁的同时，也给高级别一个标记，可以减少实际的锁用量，这里引入意向锁的概念：</p>

    <ul>
      <li>Intention-Shared (<strong>IS</strong>)：将给下面低级别上 S 锁。</li>
      <li>Intention-Exclusive (<strong>IX</strong>)：将给下面低级别上 X 锁。</li>
      <li>Shared+Intention-Exclusive (<strong>SIX</strong>)：将给下面低级别上 X 锁，并自身上 S 锁。</li>
    </ul>

    <p>我们以下面这个例子为例：</p>

    <p><img src="../../assets/images/image-20220829205706562.png" alt="image-20220829205706562" /></p>

    <p>T1：扫描 R 并更新几个 Tuple ，我们需要给 Table R 上 SIX 锁，并给更新的Tuple 上 X 锁。</p>

    <p>T2：从 R 中读取一个 Tuple ，给Table R 上 IS 锁，并给读取的 Tuple 上 S 锁。</p>

    <p>T3：扫描 R，需要给 R 上 S 锁，和之前的 SIX 冲突，被堵塞。</p>

    <p><img src="../../assets/images/image-20220829211137385.png" alt="image-20220829211137385" /></p>

    <p>还有一个问题，我们需要去设计一个这个颗粒度，比如我们读取多个 Tuple，并不是只有读取全部才上 S 锁，从 IS 到 S 有一个自适应的升级过程，需要我们去权衡。</p>
  </li>
  <li>
    <p>如何基于时间戳进行并发控制？</p>

    <p>比较基础的方式是 <em>Timestamp Ordering</em> (T/O)，每一个事务 $T_i$  有一个起始时间戳  $TS(T_i)$ ，若 $ TS(T_i)&lt;TS(T_j)$ ，则说明 $T_i$ 的执行顺序应在 $T_j$ 之前。</p>

    <p>对于每一个数据库 item 都全局使用 $R-TS(X)$ 和 $W-TS(X)$ 记录上一次被读、写的时间戳。</p>

    <p>当事务需要读写 item 时，就会去检查上面的这个时间戳，如果发现是将</p>

    <ul>
      <li>读取一个未来已写的 item</li>
      <li>修改一个未来已读或写的 item</li>
    </ul>

    <p>则选择 abort 该事务，并设置新的 timestamp。</p>

    <p>可以看到 T/O 是一种乐观的事务模型，并没有使用锁机制。但是如果存在某个长事务，会不断被后面的一些短事务中止，有可能出现饥饿的情况。</p>

    <p>如果我确定所有的事务都很短并且冲突较少，<em>Optimistic Concurrency Control</em>（OCC）也是一种很好的乐观处理方式，OCC 中每个事务都有一个私有的属性表，用于暂存读写的内容，并在 <strong>Validation Phase</strong> 阶段判断是否 abort，通过则把私有表刷新到数据库。（ OCC 是最后一起判断是否通过，所以长事务更加容易饥饿）</p>
  </li>
  <li>
    <p>并行事务可能出现怎样的问题？事务有哪几种隔离级别，有什么特点及其实现？</p>

    <p>从上往下对一致性的影响依次减轻：</p>

    <ul>
      <li>Dirty Read（脏读）：读取到了其他事务还未提交的数据。</li>
      <li>Unrepeatable Reads（不可重复读）：一个事务前后读取到的数据不一致。</li>
      <li>Phantom Reads（幻读）：一个事务前后读取的记录数量不一致。幻读和不可重复读的区别在于后者通常是 update 导致，前者为在两次顺序遍历时 insert or delete 导致前后不一致。</li>
    </ul>

    <p>四种隔离级别，从上往下隔离级别递增，性能效率递减：</p>

    <ul>
      <li>READ-UNCOMMITTED（读未提交）：一个事务还未提交，它所做的变更就会变其他事物看到。上面三种问题都有可能发生。</li>
      <li>READ - COMMITTED（读提交）：一个事务提交之后，它所做的变更才能被其他事物所看到。解决了脏读的问题。</li>
      <li>REPEATABLE READS（可重复读）：一个事务在启动到结束中看到的数据都是一致的。解决了不可重复读的问题。</li>
      <li>SERIALIZABLE（可串行化）：这个我们已经了解很多了，serializable 通常通过 <em>Strong Strict 2PL</em> 实现。</li>
    </ul>
  </li>
  <li>
    <p>MVCC 设计需要考虑哪几个方面？</p>

    <p>MVCC （Multi- Version Concurrency Control）的核心思想为读写互不堵塞，一共需要考虑以下四个方面：</p>

    <ul>
      <li>
        <p>Concurrency Control Protocol</p>

        <p>选取一种并发控制协议，也就是我们前面所谈到的 2PL、T/O、OCC 等。</p>
      </li>
      <li>
        <p>Version Storage</p>

        <p>DBMS 为每个 tuple 维护了一个全局属性表， tuple 不同版本之间通过链表连接起来，根据存储逻辑的不同也分为三种：</p>

        <ul>
          <li>Append-Only Storage：全部 tuple 存储到一个表空间内。</li>
          <li>Time - Travel Storage：用一个 单独的 time-travel 表维护老版本的 tuple。</li>
          <li>Delta Storage：和前者类似，不过表内只维护变化的数据，而不是整个列数据。</li>
        </ul>
      </li>
      <li>
        <p>Garbage Collection</p>

        <p>那些用不上的旧版本属性，我们需要垃圾回收，GC可以站在 tuple 的角度，一些线程定时扫描整个 table，寻找可回收的旧版本；或者站在事务的角度，事务自身决定哪些  tuple 需要被回收。</p>
      </li>
      <li>
        <p>Index Management
我们可以通过索引查询数据，所以索引也是需要链接到多版本的。</p>
      </li>
    </ul>
  </li>
  <li>
    <p>能否不使用 LOG 实现 undo 和 redo？</p>

    <ul>
      <li>撤销（Undo）：未完成或者由于各种原因发生回滚（rollback）、中断（abort）的事务，其修改需要被撤销，即回滚为事务之前的旧值。</li>
      <li>重做（Redo）：已经提交的事务，其修改操作的效果需要体现为新值。</li>
    </ul>
  </li>
</ol>

<p>SHADOW PAGING 对 database 有 master 和 shadow 两份拷贝，更新只改变 shadow 拷贝的部分，当提交时只需要改变 DB Root 的指向，把 shadow Page 刷盘并 GC 之前的 master。如果 undo 则不需要做任何更改。缺陷是在内存中拷贝一份复制代价太大。</p>

<p><img src="../../assets/images/image-20220903112133287.png" alt="image-20220903112133287" /></p>

<ol>
  <li>
    <p>什么是 WAL？</p>

    <p>WAL 即（Write-Ahead Logging），是现在主流的备份形式。在事务提交前所有操作都会被记录到 WAL，主要包括事务ID、Object ID、Before Value（用来 UNDO）、After Value（用来REDO）。</p>

    <p>WAL的记录格式分为三种：</p>

    <ol>
      <li>Physical Logging：记录具体的页偏移位置的变化。</li>
      <li>Logical Logging：直接记录事务层的操作语句。</li>
      <li>Physiological Logging：混合上面两种，只记录页的某个 slot 的变化。</li>
    </ol>

    <p><img src="../../assets/images/image-20220903145626008.png" alt="image-20220903145626008" /></p>

    <p>随着 WAL LOG的增大，DBMS 会定时给 WAL 写入 Checkpoints（类似游戏中的存档点），在 checkpoints 之前的日志如果已经 commit，我们可以确保已经写入磁盘，则可以把这部分内容清除。</p>
  </li>
</ol>

<blockquote>
  <p>后续一部分关于分布式数据库的知识，打算有时间结合 6.824 一起学习。</p>
</blockquote>]]></content><author><name>Theoyu</name></author><category term="cource" /><category term="cource" /><category term="CMU-15445" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">『 CMU-15445 』Project 4 并发控制</title><link href="http://localhost:4000/2022/cource/15445_proj4" rel="alternate" type="text/html" title="『 CMU-15445 』Project 4 并发控制" /><published>2022-08-26T00:00:00+08:00</published><updated>2022-08-26T00:00:00+08:00</updated><id>http://localhost:4000/2022/cource/15445_proj4</id><content type="html" xml:base="http://localhost:4000/2022/cource/15445_proj4"><![CDATA[<!--more-->

<p>这一部分主要是涉及到数据库并发控制，这是一个很大并且很有意思的领域，光是课程上的理论知识就足够消化很长一段时间。包括后面还有一些分布式数据库的知识，因为时间关系先暂时搁置，以后有机会再结合 6.824 一起学习。</p>]]></content><author><name>Theoyu</name></author><category term="cource" /><category term="cource" /><category term="CMU-15445" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">『 CMU-15445 』Project 3 Query Execution</title><link href="http://localhost:4000/2022/cource/15445_proj3" rel="alternate" type="text/html" title="『 CMU-15445 』Project 3 Query Execution" /><published>2022-08-25T00:00:00+08:00</published><updated>2022-08-25T00:00:00+08:00</updated><id>http://localhost:4000/2022/cource/15445_proj3</id><content type="html" xml:base="http://localhost:4000/2022/cource/15445_proj3"><![CDATA[<!--more-->

<h2 id="前言">前言</h2>

<p>第三个实验需要我们实现一个执行器（并非解释器），我认为这个实验和 project2 来说各有各的难点。project2 难在即使非常清楚了可拓展哈希表的流程，在多线程、各种锁的折腾下还是很容易出错，每一个小 TASK 都需要debug很长时间。而这个 project 难在已经实现的类、及其成员变量非常繁杂，相互之间的调用很不清晰，完全不知道各个变量的具体含义。所以在做这个 project 之前，梳理已给代码非常重要。</p>

<h2 id="task-1---executors">TASK #1 - EXECUTORS</h2>

<p>整个 project 只有这一个 task，需要我们实现以下9个执行器：</p>

<ul>
  <li>读取：Sequential Scan（顺序扫描）</li>
  <li>增删改查： Insert, Update, Delete</li>
  <li>其他：Nested Loop Join, Hash Join, Aggregation, Limit, Distinct</li>
</ul>

<h3 id="思路">思路</h3>

<p>在前言中我们提到各种成员变量，包括</p>

<pre><code class="language-txt">Catalog、Tuple、Schema、TableHeap、TableHeapIterator、Value、Column...等待
</code></pre>

<p>其每个变量都在具体数据库中有一个对应，我是通过 debug 慢慢摸索出其含义，后来发现<a href="https://www.cnblogs.com/sun-lingyu/p/15316626.html"> 这篇文章 </a>总结非常好，在做第一个执行器（Sequential Scan）的时候强烈推荐结合文章理清楚各个类的交互关系。</p>

<h3 id="提示">提示</h3>

<p>说一下我踩的几个坑，应该是我对聚合算子本身不来熟悉，导致一些比较乌龙的错误。</p>

<p>一个是要注意 <code class="language-plaintext highlighter-rouge">group by</code> 是可以接多个列的，站在数据库层表示以 n 个完全相同的列进行分组，在代码中体现就是 <code class="language-plaintext highlighter-rouge">AggregateKey</code> 的成员变量 <code class="language-plaintext highlighter-rouge">group_bys_</code> 是一个 <code class="language-plaintext highlighter-rouge">vector</code>。</p>

<p>二是我在看聚合的测试文件时，发现 <code class="language-plaintext highlighter-rouge">ValueExpression</code> 必须指定输出列是否为 <code class="language-plaintext highlighter-rouge">is_group_by_term</code>。根据执行逻辑如果是则代表其为 <code class="language-plaintext highlighter-rouge">group by</code> 的字段，如果不是则代表其为聚合的字段。</p>

<p>比如这样的语句：<code class="language-plaintext highlighter-rouge">select count(Id),City from Employee group by City </code>，前者则为false，后者则为 true。</p>

<p>后来我突发奇想，如果是这样的语句<code class="language-plaintext highlighter-rouge">select count(Id),City,Address from Employee group by City </code>，其中 <code class="language-plaintext highlighter-rouge">Address</code> 既不是 <code class="language-plaintext highlighter-rouge">group by</code> 的字段，也不是聚合的字段，那该怎么支持呢？</p>

<table>
  <thead>
    <tr>
      <th>count(ID)</th>
      <th>City</th>
      <th>Address</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>Kirkland</td>
      <td>722 Moss Bay Blvd.</td>
    </tr>
    <tr>
      <td>4</td>
      <td>London</td>
      <td>14 Garrett Hill</td>
    </tr>
    <tr>
      <td>1</td>
      <td>Redmond</td>
      <td>4110 Old Redmond Rd.</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Seattle</td>
      <td>507 - 20th Ave. E. Apt. 2A</td>
    </tr>
    <tr>
      <td>1</td>
      <td>Tacoma</td>
      <td>908 W. Capital Way</td>
    </tr>
  </tbody>
</table>

<p>后来想了想在聚合里这个字段也没有意义，如果一个组有多个数据，可能只会随机输出一个，真实情况下我们一般会考虑<code class="language-plaintext highlighter-rouge">group_concat</code>:</p>

<p><code class="language-plaintext highlighter-rouge">select count(Id),City,group_concat(Address,' ;') from Employee group by City</code></p>

<table>
  <thead>
    <tr>
      <th>count(ID)</th>
      <th>City</th>
      <th>group_concat(Address,’ ;’)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>Kirkland</td>
      <td>722 Moss Bay Blvd.</td>
    </tr>
    <tr>
      <td>4</td>
      <td>London</td>
      <td>14 Garrett Hill ;Coventry House Miner Rd. ;Edgeham Hollow Winchester Way ;7 Houndstooth Rd.</td>
    </tr>
    <tr>
      <td>1</td>
      <td>Redmond</td>
      <td>4110 Old Redmond Rd.</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Seattle</td>
      <td>507 - 20th Ave. E. Apt. 2A ;4726 - 11th Ave. N.E.</td>
    </tr>
    <tr>
      <td>1</td>
      <td>Tacoma</td>
      <td>908 W. Capital Way</td>
    </tr>
  </tbody>
</table>

<p>那这样的话就又得支持新的算子了，虽然感觉上不难… 不过我暂时还没有实现 XD</p>

<h2 id="最后">最后</h2>

<p>最重要的一点，请不要使用官方的打包命令，gradescope 上莫名其妙把一堆自带的 GTEST 给检测，其 check-lint G了一大片，后来群里大哥说加上 <code class="language-plaintext highlighter-rouge">src/include/storage/page/tmp_tuple_page.h</code> 可以解决，原因位置：</p>

<pre><code class="language-txt">zip project3-submission.zip \
src/include/buffer/lru_replacer.h \
src/buffer/lru_replacer.cpp \
src/include/buffer/buffer_pool_manager_instance.h \
src/buffer/buffer_pool_manager_instance.cpp \
src/include/storage/page/hash_table_directory_page.h \
src/storage/page/hash_table_directory_page.cpp \
src/include/storage/page/hash_table_bucket_page.h \
src/storage/page/hash_table_bucket_page.cpp \
src/include/container/hash/extendible_hash_table.h \
src/container/hash/extendible_hash_table.cpp \
src/include/execution/execution_engine.h \
src/include/execution/executors/seq_scan_executor.h \
src/include/execution/executors/insert_executor.h \
src/include/execution/executors/update_executor.h \
src/include/execution/executors/delete_executor.h \
src/include/execution/executors/nested_loop_join_executor.h \
src/include/execution/executors/hash_join_executor.h \
src/include/execution/executors/aggregation_executor.h \
src/include/execution/executors/limit_executor.h \
src/include/execution/executors/distinct_executor.h \
src/execution/seq_scan_executor.cpp \
src/execution/insert_executor.cpp \
src/execution/update_executor.cpp \
src/execution/delete_executor.cpp \
src/execution/nested_loop_join_executor.cpp \
src/execution/hash_join_executor.cpp \
src/execution/aggregation_executor.cpp \
src/execution/limit_executor.cpp \
src/execution/distinct_executor.cpp \
src/include/storage/page/tmp_tuple_page.h
</code></pre>

<p><img src="../../assets/images/image-20220828085926610.png" alt="image-20220828085926610" /></p>

<p><img src="../../assets/images/image-20220828090016838.png" alt="image-20220828090016838" /></p>]]></content><author><name>Theoyu</name></author><category term="cource" /><category term="cource" /><category term="CMU-15445" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">『 CMU-15445 』Project 2 哈希索引</title><link href="http://localhost:4000/2022/cource/15445_proj2" rel="alternate" type="text/html" title="『 CMU-15445 』Project 2 哈希索引" /><published>2022-08-15T00:00:00+08:00</published><updated>2022-08-15T00:00:00+08:00</updated><id>http://localhost:4000/2022/cource/15445_proj2</id><content type="html" xml:base="http://localhost:4000/2022/cource/15445_proj2"><![CDATA[<!--more-->

<h2 id="前言">前言</h2>

<p>第二个实验需要我们实现一个磁盘支持的可拓展哈希表，哈希表只负责快速搜索，不必大规模遍历表内的每一条记录。（后者用 B+ Tree 索引更加合适，20 年的实验实现的就是这个，感兴趣也可以做一做）。</p>

<p>我们先跟着 <a href="https://www.geeksforgeeks.org/extendible-hashing-dynamic-approach-to-dbms/">geeksforgeeks</a> 这个网址，快速过一遍可拓展哈希表的实现。</p>

<p><img src="../../assets/images/Basic-Structure-of-Extendible-Hashing.png" alt="img" /></p>

<p>在上述示意图中，一共设计以下 4 种属性：</p>

<ol>
  <li><strong>Directories</strong>：目录，你可以理解为一个数组，其中每一个元素存储一个指向 bucket 的指针，bucket 本身也是一个页，所以只需要存储 <code class="language-plaintext highlighter-rouge">page_id</code>即可。</li>
  <li><strong>Buckets</strong>：存取 key 和 value ，一个 bucket 可以存取多个键值对。</li>
  <li><strong>Global Depth</strong>：整个 directories 维护了一个全局的 <strong>global depth</strong>，针对一个被 hash 后的 key，比如 <code class="language-plaintext highlighter-rouge">5 = 00...00101 </code>,意味着这个结果的后 <strong>global depth</strong> 位有效（我们默认使用 <strong>LSB</strong> Least Significant Bit：最低有效位），在上图中 <strong>global depth</strong> = 2 表示 5 将落在 01 所对应的 bucket 上。你也可以发现任意时刻 directory 的数目 = <code class="language-plaintext highlighter-rouge">2^global_depth</code>，但这并不意味着 bucket 的数目，因为还有一个 <strong>Local Depth</strong>。</li>
  <li><strong>Local Depth</strong> 是针对每一个 bucket 而言，自身维护的深度，任何时刻 <strong>Local Depth</strong>  的大小总 ≤  <strong>Global Depth</strong> ，这个我们会在后面提到。</li>
</ol>

<p>一个 bucket 可以维护的数据大小由具体情况而定，这里我们假定为 3 ，然后 hash 算法就用 int 的二进制表示，我们通过以下的例子理解：</p>

<p>假设初始的 directories 和 buckets 状态如下，</p>

<p><img src="../../assets/images/hash11.png" alt="img" /></p>

<p>这时候插入数据 16（1000<strong>0</strong>），global_depth 为 1，所以它会落在 bucket_index = 0 的 bucket 上。</p>

<p><img src="../../assets/images/hash23.png" alt="img" /></p>

<p>后续同理插入 4(10<strong>0</strong>) 和 6(11<strong>0</strong>) ：</p>

<p><img src="../../assets/images/hash32.png" alt="img" /></p>

<p>我们再插入22 (1011<strong>0</strong>)，这时候 bucket 容量已满，我们需要对 0 号 bucket 进行分裂，但是此时 0号 bucket 的local_depth = global_depth，所以我们需要先对 global_depth 也就是 directories 进行扩容：</p>

<p><img src="../../assets/images/hash42.png" alt="img" /></p>

<p>扩容第一步也就是 <code class="language-plaintext highlighter-rouge">global_depth++</code>，这时候上述 directories 包含 <code class="language-plaintext highlighter-rouge">00、01、10、11</code>，然后需要进行一步 <strong>rehash</strong>：每一个扩容前的 bucket 都需要找到它的 <strong>brother_bucket</strong>（即不算新的一位后续完全一致），然后重新排列内部的数据</p>

<p><img src="../../assets/images/image-20220817003332686.png" alt="image-20220817003332686" /></p>

<p>之后再选择插入 22(101<strong>10</strong>)</p>

<p><img src="../../assets/images/hash52.png" alt="img" /></p>

<p>针对以上的例子，我们有三个需要注意的地方：</p>

<ol>
  <li>
    <p>任何时刻，所有的 local_depth ≤ global_depth</p>
  </li>
  <li>
    <p>每个 bucket 有 <code class="language-plaintext highlighter-rouge">2^(global_depth-local_depth)</code> 数目个索引指向它：</p>

    <p>这个其实比较好理解，因为目录扩容时，没有发生 split 的 bucket 将保持不变，索引也会翻倍，split 时索引会减半，这会导致不同local_depth 的 bucket 索引不同 。</p>
  </li>
  <li>
    <p>指向同一个 bucket 的 local_depth 相同：</p>

    <p>local_depth 并不是 bucket 自身的成员属性，而是在 directories 内的一个 <code class="language-plaintext highlighter-rouge">local_depths_[bucket_index]</code> 数组，所以我们在 split 和 merge 操作时需要注意。</p>
  </li>
</ol>

<p>在这个教程中没有介绍 remove 和 merge，我也就随便画个草图：</p>

<p>同样是上述例子，假设我们 把 6、22 都删除后，变为：</p>

<p><img src="../../assets/images/image-20220817170615637.png" alt="image-20220817170615637" /></p>

<p>此时 01 所对应的 bucket 为空，我们需要进行 merge 操作。</p>

<p>merge 其实很简单，就是当 remove 之后，发现该 bucket 为空，则删除这个 bucket 页，并在 directories 中把所有指向该 bucket 的 索引 指向它的 brother_bucket ，并修改 local_depth 。</p>

<p><img src="../../assets/images/image-20220817171206185.png" alt="image-20220817171206185" /></p>

<p>这里我们发现所有的 local_depth &lt; global_depth ，换句话来说就是每一个 bucket 都至少有两个索引指向它，并且这多个索引对是 互为 brother 的关系，我们就可以直接 <code class="language-plaintext highlighter-rouge">global_depth--</code>，全局收缩 directories 。</p>

<p><img src="../../assets/images/image-20220817175036981.png" alt="image-20220817175036981" /></p>

<p>相当于回到了扩容前的状态。</p>

<p>有了以上基础，我们完成 project 就会简单很多。</p>

<h2 id="task-1---page-layouts">TASK #1 - PAGE LAYOUTS</h2>

<p>这一部分，需要我们完成 directories 和 bucket 的内部实现。</p>

<h3 id="思路">思路</h3>

<p>我们先看看 directories 的内部成员变量：</p>

<ul>
  <li>page_id_ ：directories 的页 id</li>
  <li>lsn_：暂时还没能用上</li>
  <li>global_depth_：全局 bucket 深度</li>
  <li>local_depths_[bucket_index]：每个 bucket 的深度</li>
  <li>bucket_page_ids_[bucket_index]：每个 bucket 的page_id</li>
</ul>

<p>directories 需要实现的方法没什么好说的，根据注释一步一步写就行了，如果你对 split 不太了解可能会对 <code class="language-plaintext highlighter-rouge">GetSplitImageIndex</code> 这个方法感到奇怪，这个其实就是上面我们所说的去一个 bucket 的 <strong>brother_bucket</strong>，也可以先空着，后面具体实现再补上。</p>

<p>再来看看 bucket 的成员变量：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>char occupied_[(BUCKET_ARRAY_SIZE - 1) / 8 + 1];
char readable_[(BUCKET_ARRAY_SIZE - 1) / 8 + 1];

MappingType array_[1];
</code></pre></div></div>

<p>occupied_ 和 readable_ 都是 char 数组，一个 char类型占一个字节，也就是8位，从<code class="language-plaintext highlighter-rouge">00000000-&gt;11111111</code>，所以对于任何一个 bucket_index，我们只需要用 <code class="language-plaintext highlighter-rouge">bucket_index / 8</code> 判断在哪一个数组内，再用 <code class="language-plaintext highlighter-rouge">bucket_index % 8</code> 判断在8位中的哪一位即可。</p>

<p>其中 readable_ 表示某一位是否有元素占用，occupied_ 表示某一位是否有过元素占用，简单来说就是经过 remove，前者将变为 0 而后者仍为 1，知乎上有讨论 occupied_ 的实际作用，其实在 bucket 有一个 <code class="language-plaintext highlighter-rouge">PrintBucket()</code> 用于打印当前 bucket 的状态，里面就用到了 occupied_ ，所以我能给出的唯一解释可能也只是用作调试分析吧。</p>

<p>最后的 <code class="language-plaintext highlighter-rouge">array_[1]</code> 是一个变长数组，用于存储真正的 kv。</p>

<h3 id="提示">提示</h3>

<p>在 directories 中有一个 <code class="language-plaintext highlighter-rouge">VerifyIntegrity()</code>方法，用于检测 所有 bucket 的状态是否正确，其注释为：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * (1) All LD &lt;= GD.
 * (2) Each bucket has precisely 2^(GD - LD) pointers pointing to it.
 * (3) The LD is the same at each index with the same bucket_page_id
 */</span>
</code></pre></div></div>

<p>这三点我在前言中提到过，这个非常重要，我的大多半 bug 都是产生于此 XD。</p>

<h2 id="task-2---hash-table-implementation">TASK #2 - HASH TABLE IMPLEMENTATION</h2>

<h2 id="task-3---concurrency-control">TASK #3 - CONCURRENCY CONTROL</h2>

<p>TASK 2 是具体实现我们的可拓展哈希表，TASK 3是在 TASK 2 的基础上加锁，实现线程安全。我个人建议这两个 TASK 一起完成，因为重新 review 代码很容易漏掉一些考虑不全的点。</p>

<h3 id="思路-1">思路</h3>

<p>首先确定一下，无论是 insert、remove 还是 getValue，步骤应该都是：</p>

<ol>
  <li>拿到 directory 的目录页。</li>
  <li>通过 key 的 hash，找到具体的 bucket 页</li>
  <li>对 bucket 进行操作。</li>
</ol>

<p>怎么拿到页呢？其实就是通过我们 Project1 所实现的 <code class="language-plaintext highlighter-rouge">buffer_pool_manager_</code> ，extend_hash_table 自身维护了一个 BufferPoolManager 私有成员，可通过 <code class="language-plaintext highlighter-rouge">FetchPage</code> 或 <code class="language-plaintext highlighter-rouge">NewPage</code>  拿到 Page。</p>

<p>拿到 Page 我们还需要进行一次类型转换，这里我们用 <code class="language-plaintext highlighter-rouge">reinterpret_cast</code> 强制类型转换，把 Page 转换为我们所需的 directory 或者 bucket 。注意每次我们使用完 directory 或者 bucket之后，记得 <code class="language-plaintext highlighter-rouge">UnpinPage</code> 。</p>

<p>剩下的内容其实就是对我们前言部分对完善，所以接下来着重说一下并发控制。</p>

<p>对可拓展哈希表而言，其私有成员<code class="language-plaintext highlighter-rouge">ReaderWriterLatch table_latch_</code>是一把读写锁，用于控制 directory 的线程安全；对于每一个 bucket 而言，其本身也是一个 Page （从获取来看我们也是先拿到 Page 再通过强制类型转换得到 bucket ），在 <code class="language-plaintext highlighter-rouge">page.h</code>  中我们可以看到每个 Page 也维护了一把读写锁 <code class="language-plaintext highlighter-rouge">ReaderWriterLatch rwlatch_</code>，所以我们所有并发控制都是通过这两把锁来考虑的。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Insert</code> : directory 读锁、bucket 写锁。</li>
  <li><code class="language-plaintext highlighter-rouge">SplitInsert</code> : directory 写锁、两个 bucket 都上写锁。（<code class="language-plaintext highlighter-rouge">SplitInsert</code>会设计 bucket 和 brother_bucket 两个桶）</li>
  <li><code class="language-plaintext highlighter-rouge">Remove</code>： directory 读锁、bucket 写锁。</li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Merge</code>：directory 读锁、bucket 读锁</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">FetchDirectoryPage</code>：这里我在 extend_hash_table 中加了一个锁成员，在 <code class="language-plaintext highlighter-rouge">directory_page_id_ == INVALID_PAGE_ID</code> 之前锁住，防止并发时 INVALID_PAGE_ID 的判断错误。</li>
</ul>

<h3 id="提示-1">提示</h3>

<p>在 merge 的官方注释上，有三点：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="cm">/**
   * Optionally merges an empty bucket into it's pair.  This is called by Remove,
   * if Remove makes a bucket empty.
   *
   * There are three conditions under which we skip the merge:
   * 1. The bucket is no longer empty.
   * 2. The bucket has local depth 0.
   * 3. The bucket's local depth doesn't match its split image's local depth.
   */</span>
</code></pre></div></div>

<p>这个第一点很有意思，我们是在 bucket 为空的时候进入 merge ，然后在 merge 的同时还需要判断一次 bucket 是否为空，因为这里的锁并不是一直关上，两个方法调度时是有一个空档让其他线程执行的。</p>

<p>我在 debug 的时候发现多线程重复插入 500 个key，经常会出现多次 split 的情况（int 类型一个 bucket默认大小为496，按道理只会 split 一次），就是因为在进入 <code class="language-plaintext highlighter-rouge">SplitInsert</code> 我没有重新判断 <code class="language-plaintext highlighter-rouge">bucket-&gt;IsFull()</code>，当然这个由美每个人具体的写法而定，我也只是说一下我踩的坑hh。</p>

<h2 id="最后">最后</h2>

<p>这个 project 最主要还是提高了我多线程并发的调试能力，合理运用 Log 定位到出问题的点。</p>

<p><img src="../../assets/images/image-20220815194028040.png" alt="image-20220815194028040" /></p>

<p><img src="../../assets/images/image-20220816163255496.png" alt="image-20220816163255496" /></p>

<p>排名感觉还不错，另外前 20 名时间都在 1s 内，估计是把 test 给 bypass 了，面向测试用例编程  💤。</p>]]></content><author><name>Theoyu</name></author><category term="cource" /><category term="cource" /><category term="CMU-15445" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">『 CMU-15445 』Project 1 缓冲池管理器</title><link href="http://localhost:4000/2022/cource/15445_proj1" rel="alternate" type="text/html" title="『 CMU-15445 』Project 1 缓冲池管理器" /><published>2022-08-05T00:00:00+08:00</published><updated>2022-08-05T00:00:00+08:00</updated><id>http://localhost:4000/2022/cource/15445_proj1</id><content type="html" xml:base="http://localhost:4000/2022/cource/15445_proj1"><![CDATA[<!--more-->

<p>总完成时长  11小时。</p>

<h2 id="task-1---lru-replacement-policy">TASK #1 - LRU REPLACEMENT POLICY</h2>

<p>实现 LRU页面替换策略。</p>

<h3 id="思路">思路</h3>

<p>如果之前对 LRU 没有怎么接触，推荐可以先去 LeetCode 上做一下这道题：<a href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存</a></p>

<p>数据结构选取双向链表 + 哈希表，双向链表有助于我们在移动节点时更方便的找到某个节点的前节点。</p>

<p>同时设置 <code class="language-plaintext highlighter-rouge">dummy_tail</code> ，因为在置换时我们总是需要移除最后一个节点。</p>

<h3 id="提示">提示</h3>

<p>理清 <code class="language-plaintext highlighter-rouge">Pin</code> 和 <code class="language-plaintext highlighter-rouge">Unpin</code> 的含义，注意我们需要实现的只是一个 <code class="language-plaintext highlighter-rouge">POLICY</code> ，具体的实现是在下一个 TASK，如果直接当 buffer pool 处理很多含义都是相反的。</p>

<p><code class="language-plaintext highlighter-rouge">Pin</code>：代表有线程正在占用这个 frame，所以需要从 <code class="language-plaintext highlighter-rouge">cache_</code> 和 <code class="language-plaintext highlighter-rouge">DLinkedNode</code> 中删除，防止被替换。</p>

<p><code class="language-plaintext highlighter-rouge">Unpin</code>：占用结束，重新把 frame 加入  <code class="language-plaintext highlighter-rouge">cache_</code> 和 <code class="language-plaintext highlighter-rouge">DLinkedNode</code> ，<strong>重复 Unpin 不会影响节点的位置</strong>。</p>

<p>另外，如果你和我一样是自己实现的双向链表而不是用 STL 中的 list，一定要记住在 remove(node)后将 node 给 delete（我直接搬运了 leetcode 代码没考虑太多…），我这一节是满分过了，但是 project2 的内存检测后来死活过不了，才意识到问题…</p>

<h2 id="task-2---buffer-pool-manager-instance">TASK #2 - BUFFER POOL MANAGER INSTANCE</h2>

<p>实现缓冲器管理器实例。</p>

<h3 id="思路-1">思路</h3>

<p>首先明确一下 <code class="language-plaintext highlighter-rouge">BufferPoolManagerInstance</code>  中几个成员变量的含义：</p>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">std::list&lt;frame_id_t&gt; free_list_;	</code></p>

    <p>缓冲池剩余空间的 frames 用<code class="language-plaintext highlighter-rouge">free_list_</code> 表示，初始大小为 <code class="language-plaintext highlighter-rouge">pool_size_</code> 的大小，<code class="language-plaintext highlighter-rouge">free_list_</code> 为空，则说明此时 buffer pool已满，需要用上一个 TASK 完成的 LRU 获取新的 frame 。</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">std::unordered_map&lt;page_id_t, frame_id_t&gt; page_table_</code></p>

    <p><code class="language-plaintext highlighter-rouge">frame_id</code> 是 缓冲池中的帧序号。</p>

    <p><code class="language-plaintext highlighter-rouge">page_id</code> 是页的标识符。</p>

    <p>每当把 page 放入缓冲池，相当于在 <code class="language-plaintext highlighter-rouge">page_table_</code> 对两者做一个映射。</p>

    <p><img src="../../assets/images/image-20220724191830647.png" alt="image-20220724191830647" /></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Page *pages_;</code></p>

    <p>缓冲池 page 的数组，以 frame_id 为索引。</p>
  </li>
</ol>

<p>根据 <code class="language-plaintext highlighter-rouge">page_table_</code>  和  <code class="language-plaintext highlighter-rouge">pages_</code>  ，如果给定一个 <code class="language-plaintext highlighter-rouge">page_id</code> ，我们可以通过 <code class="language-plaintext highlighter-rouge">page_table_.find(page_id)</code>，去获取这个<code class="language-plaintext highlighter-rouge">page_id</code> 所对应在内存中的 <code class="language-plaintext highlighter-rouge">frame_id</code>，再通过 <code class="language-plaintext highlighter-rouge">Page* page = pages_[framge_id]</code> 即获取到了这个 <code class="language-plaintext highlighter-rouge">page</code>.</p>

<p>注意，在 Page 类中已经把 BufferPoolManagerInstance 设置为友元，所以我们可以直接访问 Page 对象中的私有成员进行修改。</p>

<p>需要实现的方法注释已经非常详细</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">FetchPgImp</span><span class="p">(</span><span class="n">page_id_t</span> <span class="n">page_id</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Page</span> <span class="o">*</span> <span class="k">override</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">NewPgImp</span><span class="p">(</span><span class="n">page_id_t</span> <span class="o">*</span><span class="n">page_id</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Page</span> <span class="o">*</span> <span class="k">override</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">UnpinPgImp</span><span class="p">(</span><span class="n">page_id_t</span> <span class="n">page_id</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">is_dirty</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="k">override</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">FlushPgImp</span><span class="p">(</span><span class="n">page_id_t</span> <span class="n">page_id</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="k">override</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">DeletePgImp</span><span class="p">(</span><span class="n">page_id_t</span> <span class="n">page_id</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="k">override</span><span class="p">;</span>
<span class="kt">void</span> <span class="n">FlushAllPgsImp</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
</code></pre></div></div>

<p>不过其实很多代码都是可以重用的，比如 <code class="language-plaintext highlighter-rouge">NewPgImp</code> 和 <code class="language-plaintext highlighter-rouge">FetchPgImp</code> 都会涉及到从<code class="language-plaintext highlighter-rouge">free_list </code>和<code class="language-plaintext highlighter-rouge">lru</code> 中获取一个新的<code class="language-plaintext highlighter-rouge">frame</code>，我们可以将其包装为<code class="language-plaintext highlighter-rouge">auto GetFreeFrame() -&gt; frame_id_t;</code>，还有比如脏页我们需要重新写回磁盘、涉及到对 <code class="language-plaintext highlighter-rouge">page</code> 的 Reset ，如果追求代码简约的话都可以封装一下。</p>

<h3 id="坑点">坑点</h3>

<p>记录一个我犯的挺蠢的错误…</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">page_table_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">page_id</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">iter</span> <span class="o">!=</span> <span class="n">page_table</span><span class="p">.</span><span class="n">end</span><span class="p">()){</span>
  <span class="n">xxxx</span><span class="p">...</span>
  <span class="n">page_table_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">page_id</span><span class="p">);</span>
  <span class="n">free_list_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">);</span>
  <span class="n">xxxx</span><span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>原因在于我把 <code class="language-plaintext highlighter-rouge">page_table_.erase(page_id); </code>写在了前面，而 <code class="language-plaintext highlighter-rouge">iterator</code> 只是 STL 中指针的封装，erase 之后这片地址空间发生了改变，再去调用<code class="language-plaintext highlighter-rouge">iter-&gt;second </code>就发生了错误。</p>

<p><img src="../../assets/images/DEAF2FE06B66BDE82A6C793AC9A0B978.jpg" alt="DEAF2FE06B66BDE82A6C793AC9A0B978" /></p>

<p>还有可能是我自作聪明，过多封装了一些方法，导致锁处理有一些麻烦 .. gradescope 上跑出了几个timeout（死锁），如果和我一样写单元测试不太熟练，可以尝试把测试文件输出出来：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">ifstream</span> <span class="nf">file</span><span class="p">(</span><span class="s">"/autograder/bustub/test/buffer/grading_buffer_pool_manager_instance_test.cpp"</span><span class="p">);</span>
<span class="n">string</span> <span class="n">line</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">file</span><span class="p">.</span><span class="n">good</span><span class="p">()){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span><span class="n">file</span><span class="p">,</span><span class="n">line</span><span class="p">);</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">line</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>把上述代码放在一个会涉及到的方法里即可，不过还是推荐自己写单元测试 debug 。</p>

<h2 id="task-3---parallel-buffer-pool-manager">TASK #3 - PARALLEL BUFFER POOL MANAGER</h2>

<p>实现并行缓冲池管理器。</p>

<h3 id="思路-2">思路</h3>

<p>因为缓冲池实例的操作必须上锁，随着缓冲池数据规模的增大锁的开销也增大了。这一个 TASK 就是让我们实现一个缓冲池管理器，其内部维护了一个 vector 容器。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">BufferPoolManagerInstance</span> <span class="o">*&gt;</span> <span class="n">buffer_pool_manager_</span><span class="p">;</span>
</code></pre></div></div>

<p>这样我们可以根据 <code class="language-plaintext highlighter-rouge">page_id % num_instances_</code>的值，均匀分配给不同的缓冲池实例。</p>

<h2 id="最后">最后：</h2>

<p><img src="../../assets/images/image-20220725234228930.png" alt="image-20220725234228930" /></p>]]></content><author><name>Theoyu</name></author><category term="cource" /><category term="cource" /><category term="CMU-15445" /><summary type="html"><![CDATA[]]></summary></entry></feed>